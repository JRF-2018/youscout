<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Time-stamp: "2024-02-29T18:56:23Z" -->
  <!-- 次は animate_determine_stay から -->
  
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Language" content="ja,en" />

<title>略式易双六 Simplified Youscout ～ Tarot Solitaire</title>

<meta name="author" content="JRF" />
<meta name="version" content="0.34" />
<meta name="keywords" content="tarot,タロット,solitaire,ソリティア,易,yi-king,yi-ching,iching" />
<meta name="description" lang="en" content="A sort of solitaire games playing with tarot cards, inspired by arguments about Yi-Ching divination." />
<meta name="description" lang="ja" content="タロットカードを使ったソリティアの一種。易経の理論からヒントを得ている。" />

<!-- <link rel="shortcut icon" href="simplest/youscout.ico" type="image/x-icon" /> -->
<link rel="shortcut icon" href="simplest/token.png" type="image/png" />


<style type="text/css">
  #setting_window {
    padding: 10px;
    font: 18px 'MS PGothic',sans-serif;
    color: white;
    background: rgba(0, 0, 0, 0.4);
    z-index: 110;
    overflow: auto;
  }

  #status_window {
    padding: 5px 5px 10px 10px;
    font: 18px 'MS PGothic',sans-serif;
    color: white;
    border: double 3px white;
    background: rgba(0, 0, 0, 0.4);
    z-index: 20;
  }

  #status_window p {
    margin: 0;
  }

  #status_window em {
    font-style: normal;
    font-weight: bold;
    text-decoration: underline;
    color: yellow;
    margin: 0;
  }

  #ad_area {
/*    display: none;*/
    text-align: center;
    padding: 0;
    margin: 0;
    padding-bottom: 10px;
  }

  #ad_google {
    display: inline-block;
    margin-left: auto;
    margin-right: auto;
  }
</style>

<script type="text/javascript">

var FORCE_DEFAULT_TAROT = false;

if (location.href.match(/[?&]tarot=([^&]+)/i)) {
  FORCE_DEFAULT_TAROT = RegExp.$1;
}

var LANG = "ja";
if (location.href.match(/[?&]default_lang=(en|ja)/)) {
  LANG = RegExp.$1;
}

var TABLE_OF_MAJOR_ARCANA = [
  // (0) 愚者 The Fool (使わない Not Use)
  {S_O: 0, S_D: 5, D_P: 5, D_G: 5, H_U: 5, H_L: 5, C_U: 3, C_L: 5},
  // (1) 魔術師 The Magician
  {S_O: 3, S_D: 3, D_P: 5, D_G: 7, H_U: 0, H_L: 3, C_U: 7, C_L: 5},
  // (2) 女教皇 The High Priestess
  {S_O: 0, S_D: 5, D_P: 7, D_G: 3, H_U: 7, H_L: 5, C_U: 3, C_L: 3},
  // (3) 女帝 The Empress
  {S_O: 3, S_D: 3, D_P: 0, D_G: 3, H_U: 7, H_L: 5, C_U: 5, C_L: 7},
  // (4) 皇帝 The Emperor
  {S_O: 3, S_D: 3, D_P: 0, D_G: 3, H_U: 5, H_L: 7, C_U: 7, C_L: 5},
  // (5) 法王 The Hierophant
  {S_O: 5, S_D: 0, D_P: 7, D_G: 3, H_U: 3, H_L: 3, C_U: 7, C_L: 5},
  // (6) 恋人 The Lovers
  {S_O: 3, S_D: 3, D_P: 5, D_G: 3, H_U: 5, H_L: 7, C_U: 7, C_L: 0},
  // (7) 戦車 The Chariot
  {S_O: 7, S_D: 7, D_P: 3, D_G: 3, H_U: 0, H_L: 3, C_U: 5, C_L: 5},
  // (8) 力 Strength
  {S_O: 5, S_D: 5, D_P: 0, D_G: 3, H_U: 7, H_L: 7, C_U: 3, C_L: 3},
  // (9) 隠者 The Hermit
  {S_O: 0, S_D: 7, D_P: 7, D_G: 3, H_U: 3, H_L: 3, C_U: 5, C_L: 5},
  // (10) 運命の輪 Wheel of Fortune
  {S_O: 5, S_D: 5, D_P: 5, D_G: 5, H_U: 5, H_L: 5, C_U: 3, C_L: 0},
  // (11) 正義 Justice
  {S_O: 5, S_D: 5, D_P: 5, D_G: 5, H_U: 0, H_L: 3, C_U: 5, C_L: 5},
  // (12) 吊るされた男 The Hanged Man
  {S_O: 3, S_D: 5, D_P: 3, D_G: 7, H_U: 3, H_L: 5, C_U: 0, C_L: 7},
  // (13) 死神 Death (使わない Not Use)
  {S_O: 5, S_D: 0, D_P: 5, D_G: 5, H_U: 5, H_L: 3, C_U: 5, C_L: 5},
  // (14) 節制 Temperance
  {S_O: 5, S_D: 5, D_P: 7, D_G: 3, H_U: 3, H_L: 7, C_U: 0, C_L: 3},
  // (15) 悪魔 The Devil
  {S_O: 5, S_D: 3, D_P: 3, D_G: 7, H_U: 5, H_L: 0, C_U: 3, C_L: 7},
  // (16) 塔 The Tower
  {S_O: 5, S_D: 7, D_P: 5, D_G: 3, H_U: 7, H_L: 0, C_U: 3, C_L: 3},
  // (17) 星 The Star
  {S_O: 5, S_D: 3, D_P: 5, D_G: 7, H_U: 3, H_L: 3, C_U: 7, C_L: 0},
  // (18) 月 The Moon
  {S_O: 3, S_D: 7, D_P: 0, D_G: 7, H_U: 5, H_L: 5, C_U: 3, C_L: 3},
  // (19) 太陽 The Sun
  {S_O: 7, S_D: 3, D_P: 0, D_G: 7, H_U: 3, H_L: 3, C_U: 5, C_L: 5},
  // (20) 審判 Judgement
  {S_O: 5, S_D: 0, D_P: 7, D_G: 3, H_U: 3, H_L: 5, C_U: 3, C_L: 7},
  // (21) 世界 The World
  {S_O: 0, S_D: 5, D_P: 3, D_G: 7, H_U: 7, H_L: 3, C_U: 3, C_L: 5}
];

var CARD_NAME_RIDER_WAITE = [
  {ja: "(0) 愚者", en: "(0) The Fool"},
  {ja: "(1) 魔術師", en: "(I) The Magician"},
  {ja: "(2) 女教皇", en: "(II) The High Priestess"},
  {ja: "(3) 女帝", en: "(III) The Empress"},
  {ja: "(4) 皇帝", en: "(IV) The Emperor"},
  {ja: "(5) 法王", en: "(V) The Hierophant"},
  {ja: "(6) 恋人", en: "(VI) The Lovers"},
  {ja: "(7) 戦車", en: "(VII) The Chariot"},
  {ja: "(8) 力", en: "(VIII) Strength"},
  {ja: "(9) 隠者", en: "(IX) The Hermit"},
  {ja: "(10) 運命の輪", en: "(X) Wheel of Fortune"},
  {ja: "(11) 正義", en: "(XI) Justice"},
  {ja: "(12) 吊るされた男", en: "(XII) The Hanged Man"},
  {ja: "(13) 死神", en: "(XIII) Death"},
  {ja: "(14) 節制 ", en: "(XIV) Temperance"},
  {ja: "(15) 悪魔", en: "(XV) The Devil"},
  {ja: "(16) 塔", en: "(XVI) The Tower"},
  {ja: "(17) 星", en: "(XVII) The Star"},
  {ja: "(18) 月", en: "(XVIII) The Moon"},
  {ja: "(19) 太陽", en: "(XIX) The Sun"},
  {ja: "(20) 審判", en: "(XX) Judgement"},
  {ja: "(21) 世界", en: "(XXI) The World"}
];

var HEXAGRAM = [ // Comments from wikipedia:"I Ching".
  //02. ¦¦¦¦¦¦ Field (坤 kūn) 	The Receptive 	Needing Knowledge & Skill; Do not force matters and go with the flow
  /* 0b000000 */ {ja: "坤", en: "坤 Field"},
  //23. ¦¦¦¦¦| Stripping (剝 bō) 	Splitting Apart 	Stripping, Flaying
  /* 0b000001 */ {ja: "剝", en: "剝 Stripping"},
  //08. ¦¦¦¦|¦ Grouping (比 bǐ) 	Holding Together 	Union
  /* 0b000010 */ {ja: "比", en: "比 Grouping"},
  //20. ¦¦¦¦|| Viewing (觀 guān) 	Contemplation 	The Withholding
  /* 0b000011 */ {ja: "觀", en: "觀 Viewing"},
  //16. ¦¦¦|¦¦ Providing-For (豫 yù) 	Enthusiasm 	Inducement, New Stimulus
  /* 0b000100 */ {ja: "豫", en: "豫 Providing-For"},
  //35. ¦¦¦|¦| Prospering (晉 jìn) 	Progress 	Expansion, Promotion
  /* 0b000101 */ {ja: "晉", en: "晉 Prospering"},
  //45. ¦¦¦||¦ Clustering (萃 cuì) 	Gathering Together 	Association, Companionship
  /* 0b000110 */ {ja: "萃", en: "萃 Clustering"},
  //12. ¦¦¦||| Obstruction (否 pǐ) 	Standstill 	Stagnation
  /* 0b000111 */ {ja: "否", en: "否 Obstruction"},
  //15. ¦¦|¦¦¦ Humbling (謙 qiān) 	Modesty 	Being Reserved, Refraining
  /* 0b001000 */ {ja: "謙", en: "謙 Humbling"},
  //52. ¦¦|¦¦| Bound (艮 gèn) 	The Keeping Still 	Immobility
  /* 0b001001 */ {ja: "艮", en: "艮 Bound"},
  //39. ¦¦|¦|¦ Limping (蹇 jiǎn) 	Obstruction 	Halting, Hardship
  /* 0b001010 */ {ja: "蹇", en: "蹇 Limping"},
  //53. ¦¦|¦|| Infiltrating (漸 jiàn) 	Development 	Auspicious Outlook, Infiltration
  /* 0b001011 */ {ja: "漸", en: "漸 Infiltrating"},
  //62. ¦¦||¦¦ Small Exceeding (小過 xiǎo guò) 	Small Preponderance 	Small Surpassing
  /* 0b001100 */ {ja: "小過", en: "小過 Small Exceeding"},
  //56. ¦¦||¦| Sojourning (旅 lǚ) 	The Wanderer 	Travel
  /* 0b001101 */ {ja: "旅", en: "旅 Sojourning"},
  //31. ¦¦|||¦ Conjoining (咸 xián) 	Influence 	Attraction
  /* 0b001110 */ {ja: "咸", en: "咸 Conjoining"},
  //33. ¦¦|||| Retiring (遯 dùn) 	Retreat 	Withdrawing
  /* 0b001111 */ {ja: "遯", en: "遯 Retiring"},
  //07. ¦|¦¦¦¦ Leading (師 shī) 	The Army 	Bringing Together, Teamwork
  /* 0b010000 */ {ja: "師", en: "師 Leading"},
  //04. ¦|¦¦¦| Enveloping (蒙 méng) 	Youthful Folly 	Detained, Enveloped and Inexperienced
  /* 0b010001 */ {ja: "蒙", en: "蒙 Enveloping"},
  //29. ¦|¦¦|¦ Gorge (坎 kǎn) 	The Abysmal Water 	Darkness, Gorge
  /* 0b010010 */ {ja: "坎", en: "坎 Gorge"},
  //59. ¦|¦¦|| Dispersing (渙 huàn) 	Dispersion 	Dispersal
  /* 0b010011 */ {ja: "渙", en: "渙 Dispersing"},
  //40. ¦|¦|¦¦ Taking-Apart (解 xiè) 	Deliverance 	Liberation, Solution
  /* 0b010100 */ {ja: "解", en: "解 Taking-Apart"},
  //64. ¦|¦|¦| Not-Yet Fording (未濟 wèi jì)
  /* 0b010101 */ {ja: "未濟", en: "未濟 Not-Yet Fording"},
  //47. ¦|¦||¦ Confining (困 kùn) 	Oppression 	Exhaustion
  /* 0b010110 */ {ja: "困", en: "困 Confining"},
  //06. ¦|¦||| Arguing (訟 sòng) 	Conflict 	Engagement in Conflict
  /* 0b010111 */ {ja: "訟", en: "訟 Arguing"},
  //46. ¦||¦¦¦ Ascending (升 shēng) 	Pushing Upward 	Growing Upward
  /* 0b011000 */ {ja: "升", en: "升 Ascending"},
  //18. ¦||¦¦| Corrupting (蠱 gǔ) 	Work on the Decayed 	Repairing
  /* 0b011001 */ {ja: "蠱", en: "蠱 Corrupting"},
  //48. ¦||¦|¦ Welling (井 jǐng) 	The Well 	Replenishing, Renewal
  /* 0b011010 */ {ja: "井", en: "井 Welling"},
  //57. ¦||¦|| Ground (巽 xùn) 	The Gentle 	Subtle Influence
  /* 0b011011 */ {ja: "巽", en: "巽 Ground"},
  //32. ¦|||¦¦ Persevering (恆 héng) 	Duration 	Perseverance
  /* 0b011100 */ {ja: "恆", en: "恆 Persevering"},
  //50. ¦|||¦| Holding (鼎 dǐng) 	The Cauldron 	Establishing the New
  /* 0b011101 */ {ja: "鼎", en: "鼎 Holding"},
  //28. ¦||||¦ Great Exceeding (大過 dà guò) 	Great Preponderance 	Great Surpassing
  /* 0b011110 */ {ja: "大過", en: "大過 Great Exceeding"},
  //44. ¦||||| Coupling (姤 gòu) 	Coming to Meet 	Encountering
  /* 0b011111 */ {ja: "姤", en: "姤 Coupling"},
  //24. |¦¦¦¦¦ Returning (復 fù) 	Return 	Returning
  /* 0b100000 */ {ja: "復", en: "復 Returning"},
  //27. |¦¦¦¦| Swallowing (頤 yí) 	Mouth Corners 	Seeking Nourishment
  /* 0b100001 */ {ja: "頤", en: "頤 Swallowing"},
  //03. |¦¦¦|¦ Sprouting (屯 zhūn) 	Difficulty at the Beginning 	Sprouting
  /* 0b100010 */ {ja: "屯", en: "屯 Sprouting"},
  //42. |¦¦¦|| Augmenting (益 yì) 	Increase 	Increase
  /* 0b100011 */ {ja: "益", en: "益 Augmenting"},
  //51. |¦¦|¦¦ Shake (震 zhèn) 	Arousing 	Mobilizing
  /* 0b100100 */ {ja: "震", en: "震 Shake"},
  //21. |¦¦|¦| Gnawing Bite (噬嗑 shì kè) 	Biting Through 	Deciding
  /* 0b100101 */ {ja: "噬嗑", en: "噬嗑 Gnawing Bite"},
  //17. |¦¦||¦ Following (隨 suí) 	Following 	Following
  /* 0b100110 */ {ja: "隨", en: "隨 Following"},
  //25. |¦¦||| Without Embroiling (無妄 wú wàng) 	Innocence 	Without Rashness
  /* 0b100111 */ {ja: "無妄", en: "無妄 Without Embroiling"},
  //36. |¦|¦¦¦ Brightness Hiding (明夷 míng yí) 	Darkening of the Light 	Brilliance Injured
  /* 0b101000 */ {ja: "明夷", en: "明夷 Brightness Hiding"},
  //22. |¦|¦¦| Adorning (賁 bì) 	Grace 	Embellishing
  /* 0b101001 */ {ja: "賁", en: "賁 Adorning"},
  //63. |¦|¦|¦ Already Fording (既濟 jì jì) 	After Completion 	Completion
  /* 0b101010 */ {ja: "既濟", en: "既濟 Already Fording"},
  //37. |¦|¦|| Dwelling People (家人 jiā rén) 	The Family 	Family
  /* 0b101011 */ {ja: "家人", en: "家人 Dwelling People"},
  //55. |¦||¦¦ Abounding (豐 fēng) 	Abundance 	Goal Reached, Ambition Achieved
  /* 0b101100 */ {ja: "豐", en: "豐 Abounding"},
  //30. |¦||¦| Radiance (離 lí) 	The Clinging 	Clinging, Attachment
  /* 0b101101 */ {ja: "離", en: "離 Radiance"},
  //49. |¦|||¦ Skinning (革 gé) 	Revolution 	Abolishing the Old
  /* 0b101110 */ {ja: "革", en: "革 Skinning"},
  //13. |¦|||| Concording People (同人 tóng rén) 	Fellowship 	Fellowship, Partnership
  /* 0b101111 */ {ja: "同人", en: "同人 Concording People"},
  //19. ||¦¦¦¦ Nearing (臨 lín) 	Approach 	Approaching Goal, Arriving
  /* 0b110000 */ {ja: "臨", en: "臨 Nearing"},
  //41. ||¦¦¦| Diminishing (損 sǔn) 	Decrease 	Decrease
  /* 0b110001 */ {ja: "損", en: "損 Diminishing"},
  //60. ||¦¦|¦ Articulating (節 jié) 	Limitation 	Discipline
  /* 0b110010 */ {ja: "節", en: "節 Articulating"},
  //61. ||¦¦|| Centre Confirming (中孚 zhōng fú) 	Inner Truth 	Staying Focused, Avoid Misrepresentation
  /* 0b110011 */ {ja: "中孚", en: "中孚 Centre Confirming"},
  //54. ||¦|¦¦ Converting The Maiden (歸妹 guī mèi) 	The Marrying Maiden 	Marrying
  /* 0b110100 */ {ja: "歸妹", en: "歸妹 Converting The Maiden"},
  //38. ||¦|¦| Polarising (睽 kuí) 	Opposition 	Division, Divergence
  /* 0b110101 */ {ja: "睽", en: "睽 Polarising"},
  //58. ||¦||¦ Open (兌 duì) 	The Joyous 	Overt Influence
  /* 0b110110 */ {ja: "兌", en: "兌 Open"},
  //10. ||¦||| Treading (履 lǚ) 	Treading (Conduct) 	Continuing with Alertness
  /* 0b110111 */ {ja: "履", en: "履 Treading"},
  //11. |||¦¦¦ Pervading (泰 tài) 	Peace 	Pervading
  /* 0b111000 */ {ja: "泰", en: "泰 Pervading"},
  //26. |||¦¦| Great Accumulating (大畜 dà chù) 	Great Taming 	Accumulating Wisdom
  /* 0b111001 */ {ja: "大畜", en: "大畜 Great Accumulating"},
  //05. |||¦|¦ Attending (需 xū) 	Waiting 	Uninvolvement (Wait for now), Nourishment
  /* 0b111010 */ {ja: "需", en: "需 Attending"},
  //09. |||¦|| Small Accumulating (小畜 xiǎo chù) 	Small Taming 	Accumulating Resources
  /* 0b111011 */ {ja: "小畜", en: "小畜 Small Accumulating"},
  //34. ||||¦¦ Great Invigorating (大壯 dà zhuàng) 	Great Power 	Great Boldness
  /* 0b111100 */ {ja: "大壯", en: "大壯 Great Invigorating"},
  //14. ||||¦| Great Possessing (大有 dà yǒu) 	Great Possession 	Independence, Freedom
  /* 0b111101 */ {ja: "大有", en: "大有 Great Possessing"},
  //43. |||||¦ Parting (夬 guài) 	Breakthrough 	Separation
  /* 0b111110 */ {ja: "夬", en: "夬 Parting"},
  //01. |||||| Force (乾 qián) 	The Creative 	Possessing Creative Power & Skill
  /* 0b111111 */ {ja: "乾", en: "乾 Force"}
];

var CHAR_SWORD = "\u2660"; // ♠
var CHAR_COIN = "\u2666";  // ♦
var CHAR_CUP = "\u2665";   // ♥
var CHAR_WAND = "\u2663";  // ♣
var CHAR_SLASH = "/";
var CHAR_UPDOWN = "\u223D"; // ∽
var CHAR_DIVISION = "|";


var setting_default = {
  lang: LANG,
  page_help: "index_sy.html",
  cards: (! FORCE_DEFAULT_TAROT)? ((window.innerHeight && window.innerWidth && window.innerHeight >= 1024 && window.innerWidth >= 1280)? 'jrf_tarot_medium' : 'jrf_tarot_small_dense') : FORCE_DEFAULT_TAROT,

  rule_terminals: 3,
  rule_court_card: "K14",
  // K14 == { K: 14, Q: 13, C: 12, J: 11 },
  // K13a == { K: 13, Q: 12, C: 12, J: 11 },
  // K13b == { K: 13, Q: 12, C: 11, J: 11 },
  // K10 == { K: 10, Q: 10, C: 10, J: 10 },
  rule_major_influence: 2,
  rule_swap_8_11: "memorial",

  rule_determinant: "greater",

  calc_screen: true,

  // for system.
  load_status: 'done'
};

var current_cards;

var cards_simplest = {
  window_width: 1024,
  window_height: 768,
//  window_background: '#223776',
  window_background: '#10431f',
  page_background: '#10431f',
  status_window_height: 128,
  dialog_window_font: "32px 'MS PGothic',sans-serif",
  dialog_window_height: 48,
  
  card_width: 80,
  card_height: 128,

  img_logo: "simplest/logo_sy.png",
  img_cards: "simplest/cards.png",
  img_backs: "simplest/backs.png",
  img_talon: "simplest/talon.png",
  img_discarded: "simplest/discarded.png",
  img_token: "simplest/token.png",

  card_name: CARD_NAME_RIDER_WAITE,
  number_table: TABLE_OF_MAJOR_ARCANA
};

var jrf_tarot_dir = 'jrf_tarot';

var cards_jrf_tarot_small = {
  window_width: 1024,
  window_height: 768,

  card_width: 82,
  card_height: 128,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/small/cards.png",
  img_backs: jrf_tarot_dir + "/small/backs.png",
  img_talon: jrf_tarot_dir + "/small/talon.png",
  img_discarded: jrf_tarot_dir + "/small/discarded.png"
//  img_token: "simplest/token.png",
};

var cards_jrf_tarot_small_dense = {
  window_width: 800,
  window_height: 600,

  card_width: 82,
  card_height: 128,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/small/cards.png",
  img_backs: jrf_tarot_dir + "/small/backs.png",
  img_talon: jrf_tarot_dir + "/small/talon.png",
  img_discarded: jrf_tarot_dir + "/small/discarded.png"
//  img_token: "simplest/token.png",
};

var cards_jrf_tarot_medium = {
  window_width: 1280,
  window_height: 1024,

  card_width: 103,
  card_height: 160,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/medium/cards.png",
  img_backs: jrf_tarot_dir + "/medium/backs.png",
  img_talon: jrf_tarot_dir + "/medium/talon.png",
  img_discarded: jrf_tarot_dir + "/medium/discarded.png"
//  img_token: "simplest/token.png",
};

var cards_jrf_tarot_medium_dense = {
  window_width: 1024,
  window_height: 768,

  card_width: 103,
  card_height: 160,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/medium/cards.png",
  img_backs: jrf_tarot_dir + "/medium/backs.png",
  img_talon: jrf_tarot_dir + "/small/talon.png",
  img_discarded: jrf_tarot_dir + "/small/discarded.png"
//  img_token: "simplest/token.png",
};

var cards_jrf_tarot_large_dense = {
  window_width: 1280,
  window_height: 1024,

  card_width: 162,
  card_height: 252,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/large/cards.png",
  img_backs: jrf_tarot_dir + "/large/backs.png",
  img_talon: jrf_tarot_dir + "/medium/talon.png",
  img_discarded: jrf_tarot_dir + "/medium/discarded.png"
//  img_token: "simplest/token.png",
};

function L(h) {
  return h[LANG] || h["en"];
}

function bind(f, o) {
  return function() {return f.apply(o, arguments)};
}

function fatal(mes) {
  alert(mes);
}

function pad_left(s, num, pad) {
  s = s.toString();
  var r = s;
  for (var i = 0; i < num - s.length; i++) {
    r = pad + r;
  }
  return r.substr(r.length - num, num);
}

function version() {
  var a = document.getElementsByTagName("meta");
  for (var i = 0; i < a.length; i++) {
    if (a[i].name == "version") {
      return a[i].content;
    }
  }
  return "0.00";
}

function shuffle_array (l) {
  var r = [];
  while (l.length > 0) {
    var i = Math.floor(Math.random() * l.length);
    r.push(l[i]);
    l.splice(i, 1);
  }
  return r;
}

var setting;

function read_setting () {
  setting = {};
  for (var n in setting_default) {
    setting[n] = setting_default[n];
  }

  if (document.cookie) {
    var a = document.cookie.split("; ");
    for (var i = 0; i < a.length; i++) {
      var p = a[i].split("=");
      var name = p[0];
      var v = unescape(p[1]);
      if (v.match(/^[01-9]+$/)) {
	v = parseInt(v, 10);
      } else if (v.match(/^-?[01-9]+\.[01-9]+$/)) {
	v = parseFloat(v);
      } else if (v.match(/^true$/)) {
	v = true;
      } else if (v.match(/^false$/)) {
	v = false;
      }
      if (name.indexOf("simple_ysc_", 0) == 0) {
	name = name.substr("simple_ysc_".length);
	setting[name] = v;
      }
    }
  }

  if (setting.load_status == 'waiting') {
    setting.cards = "simplest";
  }

  for (var n in cards_simplest) {
    setting[n] = cards_simplest[n];
  }

  if (window["cards_" + setting.cards] != null && setting.cards != 'simplest') {
    var cs = window["cards_" + setting.cards];
    for (var n in cs) {
      setting[n] = cs[n];
    }
  }
}

function set_cookie (name, value) {
  var str;
  name = "simple_ysc_" + name;
  if (value !== null) {
    str = name + "=" + escape(value);
  } else {
    str = name + "=";
  }
  var path =location.pathname;
  if (path.lastIndexOf("/") > 0) {
    path = path.substring(0, path.lastIndexOf("/") + 1);
  }
  str += "; path=" + path;
  var expires = 365;
  if (value === null) {
    expires = -1;
  }
  expires = new Date((new Date()).getTime() + expires * 60 * 60 * 24 * 1000);
  str += "; expires=" + expires.toGMTString();
  document.cookie = str;
}

var load_waiting = 0;
var load_error = null;

function _image_loaded(ev) {
  if (load_waiting > 0) {
    load_waiting--;
  }
}

function _image_error(ev) {
  if (load_waiting > 0) {
    load_waiting--;
  }
  load_error = this.src;
}

function load_image(src) {
  var img = new Image();
  load_waiting++;
  img.onload = _image_loaded;
  img.onerror = bind(_image_error, {src: src});
  img.src = src;
  return img;
}

function _wait_load() {
  if (load_error) {
    fatal(load_error + L({ja: "\n読み込みに失敗しました。リロードすると解決するかも。何度も失敗してるならカードの絵を変えてみてください。", en: "\nFailed to load.  Try reload.  Please change cards if you fail often."}));
  } else {
    if (load_waiting) {
      setTimeout(bind(_wait_load, this), 500);
    } else {
      this.func();
    }
  }
}

function wait_load(func) {
  (bind(_wait_load, {func: func}))();
}

function calc_card_score (card) {
  var num = parseInt(card.substr(1), 10);

  var rule;
  switch (setting.rule_court_card) {
  case "K14":
    rule = {K: 14, Q: 13, C: 12, J: 11};
    break;
  case "K13a":
    rule = {K: 13, Q: 12, C: 12, J: 11};
    break;
  case "K13b":
    rule = {K: 13, Q: 12, C: 11, J: 11};
    break;
  case "K10":
    rule = {K: 10, Q: 10, C: 10, J: 10};
    break;
  }
  switch (num) {
  case 14:
    return rule.K;
  case 13:
    return rule.Q;
  case 12:
    return rule.C;
  case 11:
    return rule.J;
  default:
    return num;
  }
}

function read_major_arcana(c) {
  var card = c.card;
  var upright = c.upright;
  var t = setting.number_table[parseInt(card.substr(1), 10)];
  var s = {};
  for (var n in t) {
    s[n] = Math.ceil(t[n] * setting.rule_major_influence);
  }
  if (upright) {
    return {sword_offence: s.S_O, sword_defence: s.S_D,
	    coin_pain: s.D_P, coin_gain: s.D_G,
	    cup_upper: s.H_U, cup_lower: s.H_L,
	    wand_upper: s.C_U, wand_lower: s.C_L};
  } else {
    return {sword_offence: s.S_D, sword_defence: s.S_O,
	    coin_pain: s.D_G, coin_gain: s.D_P,
	    cup_upper: s.H_L, cup_lower: s.H_U,
	    wand_upper: s.C_L, wand_lower: s.C_U};
  }
}

function read_major_arcana_string(c) {
  var card = c.card;
  var upright = c.upright;
  var t = setting.number_table[parseInt(card.substr(1), 10)];
  var s = {};
  for (var n in t) {
    s[n] = Math.ceil(t[n] * setting.rule_major_influence);
  }
  if (upright) {
    return "♠" + s.S_O + "/" + s.S_D + " ♦" + s.D_P + "|" + s.D_G + " ♥" + s.H_U + "∽" + s.H_L + " ♣" + s.C_U + "∽" + s.C_L;
  } else {
    return "♣" + s.C_L + "∽" + s.C_U + " ♥" + s.H_L + "∽" + s.H_U + " ♦" + s.D_G + "|" + s.D_P + " ♠" + s.S_D + "/" + s.S_O;

  }
}


function make_overlay_image(img) {
  var canvas = img;
  if (! img.getContext) {
    canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
  }
  var ctx = canvas.getContext('2d');
  var input;
  try {
    input = ctx.getImageData(0, 0, canvas.width, canvas.height);
  } catch (e) {
    fatal(L({ja: "エラー。ブラウザ開発者のポリシーが間借りブロガーにはキビしすぎます。彼らに robots.txt や sitemap.xml や .htaccess に似た回避策を用意していただきたいです。", en: "Error! Th policy of developers of your browser is too severe and is unavoidable for tenant bloggers.  I wish they should implement a method for avoidance like robots.txt or sitemap.xml or .htaccess ."}));
  }
  var output = ctx.createImageData(canvas.width, canvas.height);
  var tmp =output.data;
  for (var i = 0; i < input.data.length; i += 4) {
    if (input.data[i + 3] <= 255 * 0.1) {
      tmp[i + 0] = 0;
      tmp[i + 1] = 0;
      tmp[i + 2] = 0;
      tmp[i + 3] = 0;
    } else {
      tmp[i + 0] = 255 - 32 - 64;
      tmp[i + 1] = 255 - 32 - 64;
      tmp[i + 2] = 255 - 64 - 64;
      tmp[i + 3] = 64;
    }
  }
  var ocanvas = document.createElement('canvas');
  ocanvas.width = canvas.width;
  ocanvas.height = canvas.height;
  var octx = ocanvas.getContext('2d');

  // This rect shows only with failed putImageData.
  octx.beginPath();
  octx.rect(ocanvas.width - setting.card_width, 0,
	    setting.card_width, setting.card_height);
  octx.closePath();
  octx.fillStyle = "rgba(155, 187, 89, 0.7)";
  octx.fill();

  try {
    octx.putImageData(output, 0, 0);
  } catch (e) {
    fatal(L({ja: "エラー。ブラウザのバージョンを上げてみてください。", en: "Error! Try version up of your browser."}));
  }
  return ocanvas;
}

function calc_card_rect(card_name) {
  var s = card_name.substr(0, 1);
  var num = parseInt(card_name.substr(1), 10);
  var img = game_view.img_cards;
  if (s != "A" && s != "B") {
    num--;
  }
  var y = 0;
  switch (s) {
  case "A":
    y = 0;
    break;
  case "S":
    y = 1;
    break;
  case "D":
    y = 2;
    break;
  case "H":
    y = 3;
    break;
  case "C":
    y = 4;
    break;
  case "B":
    y = 0;
    img = game_view.img_backs;
    break;
  }
  return {x: num * setting.card_width, y: y * setting.card_height,
	  width: setting.card_width, height: setting.card_height,
	  img: img};
}

function calc_minor_rect (place, img) {
  var rect = {x: null, y: null, width: img.width, height: img.height};
  var anchor;

  switch (place) {
  case "swords_upper":
    anchor = game_view.anchor_swords_upper;
    rect.x = Math.floor(anchor.x - (img.width / 2));
    rect.y = Math.floor(anchor.y - (img.height / 2));
    if (rect.y < game_view.window_top) {
      rect.y = game_view.window_top;
    }
    break;
  case "coins_lower":
    anchor = game_view.anchor_coins_lower;
    rect.x = Math.floor(anchor.x - (img.width / 2));
    rect.y = Math.floor(anchor.y - (img.height / 2));
    if ((rect.y + img.height) > game_view.window_bottom) {
      rect.y = game_view.window_bottom - img.height;
    }
    break;
  case "coins_6":
    anchor = game_view.anchor_6;
    rect.x = Math.floor(anchor.x - (setting.card_width / 4) - img.width);
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- setting.card_height);
    if (rect.y < game_view.window_top) {
      rect.y = game_view.window_top;
    }
    break;
  case "coins_5":
    anchor = game_view.anchor_5;
    rect.x = Math.floor(anchor.x - (setting.card_width / 4) - img.width);
    rect.y = Math.floor(anchor.y - (setting.card_height / 4));
    break;
  case "coins_4":
    anchor = game_view.anchor_4;
    rect.x = Math.floor(anchor.x + (setting.card_width / 4));
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- setting.card_height);
    if (rect.y < game_view.window_top) {
      rect.y = game_view.window_top;
    }
    break;
  case "cups_3":
    anchor = game_view.anchor_3;
    rect.x = Math.floor(anchor.x + (setting.card_width / 4));
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- setting.card_height);
    if ((rect.y + img.height) > game_view.window_bottom) {
      rect.y = game_view.window_bottom - img.height;
    }
    break;
  case "cups_2":
    anchor = game_view.anchor_2;
    rect.x = Math.floor(anchor.x + (setting.card_width / 4));
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- img.height);
    break;
  case "cups_1":
    anchor = game_view.anchor_1;
    rect.x = Math.floor(anchor.x - (setting.card_width / 4) - img.width);
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- setting.card_height);
    if ((rect.y + img.height) > game_view.window_bottom) {
      rect.y = game_view.window_bottom - img.height;
    }
    break;
  }
  return rect;
}

function make_cards_image(cards) {
  var w = cards.length;
  if (w > 5) {
    w = 5;
  }
  w = Math.ceil(setting.card_width * (1 + (w - 1) * 1.0/5.0));
  var h = Math.ceil(cards.length / 5);
  h = Math.ceil(setting.card_height * (1 + (h - 1) * 1.0/6.0));
  var canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  var ctx = canvas.getContext('2d');
  for (var i = 0; i < cards.length; i++) {
    var c = cards[i];
    var x = i % 5;
    var y = Math.floor(i / 5);
    x = Math.floor(x * (setting.card_width / 5.0));
    y = Math.floor(y * (setting.card_height / 6.0));
    var rect = calc_card_rect(c);
    ctx.drawImage(rect.img,
		  rect.x, rect.y, setting.card_width, setting.card_height,
		  x, y, setting.card_width, setting.card_height);
  }
  return canvas;
}

function make_card_image(card, rotation) {
  var canvas = document.createElement('canvas');
  
  canvas.width = setting.card_width * Math.abs(Math.cos(rotation))
    + Math.abs(setting.card_height * Math.sin(rotation));
  canvas.height = Math.abs(setting.card_width * Math.sin(rotation))
    + Math.abs(setting.card_height * Math.cos(rotation));

//  alert(canvas.width + "x" + canvas.height);

  var d = Math.sqrt(setting.card_width * setting.card_width
		    + setting.card_height * setting.card_height);
  var dx, dy;
  if (Math.cos(rotation) >= 0 && Math.sin(rotation) <= 0) {
    dx = 0;
    dy = - setting.card_width * Math.sin(rotation);
  } else if (Math.cos(rotation) >= 0 && Math.sin(rotation) >= 0) {
    dx = canvas.width - setting.card_width * Math.cos(rotation);
    dy = 0;
  } else if (Math.cos(rotation) <= 0 && Math.sin(rotation) >= 0) {
    dx = canvas.width;
    dy = canvas.height - setting.card_width * Math.sin(rotation);
  } else {
    dx = - setting.card_width * Math.cos(rotation);
    dy = canvas.height;
  }

//  alert(dx + "x" + dy);

  var ctx = canvas.getContext('2d');
  var rect = calc_card_rect(card);
  ctx.transform(1, 0, 0, 1, dx, dy);
  ctx.rotate(rotation);
  ctx.drawImage(rect.img,
		rect.x, rect.y, setting.card_width, setting.card_height,
		0, 0,
		setting.card_width, setting.card_height);
  ctx.rotate(0);

  return canvas;
}


function determine_stay(cur, next) {
  var cur_cards_name = null;
  if (cur.token >= 3) {
    cur_cards_name = "coins_" + (cur.token + 1);
  } else {
    cur_cards_name = "cups_" + (cur.token + 1);
  }
  cur.move_or_stay = "stay";
  next[cur_cards_name] = cur[cur_cards_name].concat([cur.drawn]);
}

function determine_move(cur, next, next_token, cards_token) {
  var cards_name = null;
  if (cards_token >= 3) {
    cards_name = "coins_" + (cards_token + 1);
  } else {
    cards_name = "cups_" + (cards_token + 1);
  }
  cur.move_or_stay = "move";
  next[cards_name] = cur[cards_name].concat([cur.drawn]);
  next.token = next_token;
}

function determine_move_or_stay(cur, next, next_token, choice_ok) {
  var cur_cards_name = null;
  var next_cards_name = null;
  if (cur.token >= 3) {
    cur_cards_name = "coins_" + (cur.token + 1);
  } else {
    cur_cards_name = "cups_" + (cur.token + 1);
  }
  if (next_token >= 3) {
    next_cards_name = "coins_" + (next_token + 1);
  } else {
    next_cards_name = "cups_" + (next_token + 1);
  }

  var m_minor_from = calc_card_score(cur.drawn);
  var f_minor_from = read_major_arcana(cur.board[cur.token]).coin_pain;
  var m_major_to = read_major_arcana(cur.board[next_token]).sword_offence;
  var f_minor_to = read_major_arcana(cur.board[next_token]).coin_pain;

  var cur_cards_max = -1;
  if (cur[cur_cards_name].length > 0) {
    var max = null;
    var max_score = 0;
    for (var i = 0, l = cur[cur_cards_name]; i < l.length; i++) {
      var s = calc_card_score(l[i]);
      if (s > max_score) {
	max = i;
	max_score = s;
      }
    }
    cur_cards_max = max;
    f_minor_from = max_score;
  }
  var next_cards_max = -1;
  if (cur[next_cards_name].length > 0) {
    var max = null;
    var max_score = 0;
    for (var i = 0, l = cur[next_cards_name]; i < l.length; i++) {
      var s = calc_card_score(l[i]);
      if (s > max_score) {
	max = i;
	max_score = s;
      }
    }
    next_cards_max = max;
    f_minor_to = max_score;
  }

  var c = true;
  if (setting.rule_determinant == "greater_equal") {
    c = m_minor_from + f_minor_from >= m_major_to + f_minor_to;
  } else {
    c = m_minor_from + f_minor_from > m_major_to + f_minor_to;
  }

  if (! c) {
    cur.move_or_stay = "stay";
    next.discarded = cur.discarded.concat([cur.drawn]);

    if (next_cards_max != -1) {
      var card = cur[next_cards_name][next_cards_max];
      next[next_cards_name] = [].concat(cur[next_cards_name]);
      next[next_cards_name].splice(next_cards_max, 1);
      next.discarded.push(card);
    }
  } else {
    if (choice_ok) {
      cur.move_or_stay = "choose";
      next.state = "choose_move_or_stay";
      next.drawn = cur.drawn;
    } else {
      cur.move_or_stay = "move";
      next.discarded = cur.discarded.concat([cur.drawn]);

      if (cur_cards_max != -1) {
	var card = cur[cur_cards_name][cur_cards_max];
	next[cur_cards_name] = [].concat(cur[cur_cards_name]);
	next[cur_cards_name].splice(cur_cards_max, 1);
	next.discarded.push(card);
      }
      next.token = next_token;
    }
  }
}

function process_chose_move_or_stay(cur, next, next_token) {
  var cur_cards_name = null;
  var next_cards_name = null;
  if (cur.token >= 3) {
    cur_cards_name = "coins_" + (cur.token + 1);
  } else {
    cur_cards_name = "cups_" + (cur.token + 1);
  }

  var cur_cards_max = -1;
  if (cur[cur_cards_name].length > 0) {
    var max = null;
    var max_score = 0;
    for (var i = 0, l = cur[cur_cards_name]; i < l.length; i++) {
      var s = calc_card_score(l[i]);
      if (s > max_score) {
	max = i;
	max_score = s;
      }
    }
    cur_cards_max = max;
  }

  if (cur.move_or_stay == "stay") {
    next.discarded = cur.discarded.concat([cur.drawn]);
  } else {
    next.discarded = cur.discarded.concat([cur.drawn]);

    if (cur_cards_max != -1) {
      var card = cur[cur_cards_name][cur_cards_max];
      next[cur_cards_name] = [].concat(cur[cur_cards_name]);
      next[cur_cards_name].splice(cur_cards_max, 1);
      next.discarded.push(card);
    }
    next.token = next_token;
  }
}

function make_suit_name (card) {
  var f = {A: L({ja: "大アルカナ", en: "major arcana"}),
	   S: L({ja: "ソード", en: "sword"}),
	   D: L({ja: "コイン", en: "coin"}),
	   H: L({ja: "カップ", en: "cup"}),
	   C: L({ja: "ワンド", en: "wand"})};
  return f[card.substr(0, 1)];
}


var game_view = {
  model_cur: {state: "title"},
  model_next: null,

  animation_info: {
    id: null,
    interval: 100,
    start_time: null,
    func: null
  },

  animation_temp: {}, // Temporary images for animation.

  controller_click_array: [],
  controller_move_array: [],

  debug_inited: false,

  lf: { // local functions
    _pop_animation : function () {
      var ainfo = game_view.animation_info;
      if (ainfo.id) {
	var time = (new Date).getTime() - ainfo.start_time;
	var r = ainfo.func(time);
	if (r) {
	  ainfo.id = window.setTimeout(game_view.lf._pop_animation,
				       ainfo.interval);
	}
      }
    },
    set_animation : function (func) {
      var ainfo = game_view.animation_info;
      if (ainfo.id) {
	window.clearTimeout(ainfo.id);
	ainfo.id = null;
      }
      if (func) {
	ainfo.start_time = (new Date).getTime();
	ainfo.func = func;
	ainfo.id = window.setTimeout(game_view.lf._pop_animation,
				     ainfo.interval);
      }
    },

    reset_animation : function () {
      game_view.lf.set_animation(null);
    },


    process_event : function (type, x, y) {
      var a = game_view.controller_move_array;
      if (type == "click") {
	a = game_view.controller_click_array;
      }
      for (var i = 0; i < a.length; i++) {
	var c = a[i];
	if (x >= c.x && x < c.x + c.width && y >= c.y && y < c.y + c.height) {
	  if (! c.func(type, x, y)) {
	    return;
	  }
	}
      }
    }
  },

  redraw : function () {
    if (game_view.model_next) {
      if (game_view.model_cur.finish) {
	game_view.model_cur.finish();
      }
      game_view.model_cur = game_view.model_next;
      game_view.model_next = null;
    }
    switch (game_view.model_cur.state) {
    case "title":
      game_view.draw_title();
      break;
    case "setting":
      game_view.draw_setting();
      break;
    case "game_init":
      game_view.draw_game_init();
      break;
    case "choose_token_place":
      game_view.draw_choose_token_place();
      break;
    case "wait_draw_card":
      game_view.draw_wait_draw_card();
      break;
    case "choose_move_or_stay":
      game_view.draw_choose_move_or_stay();
      break;
    case "game_end":
      game_view.draw_game_end();
      break;
    case "game_end_0":
      game_view.draw_game_end_0();
      break;
    default:
      fatal("Illegal model state.");
    }
  },

  draw_title : function () {
    game_view.clear_all();

    game_view.debug_inited = false;

    var control_title = function (ev, x, y) {
      var rect = this.rect;
      var func = this.func;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);

      if (x && y
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	ctx.beginPath()
	ctx.rect(rect.x, rect.y, rect.width, rect.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.7)";
	ctx.fill();
	if (ev == "click") {
	  func();
	}
      }
      
      return false;
    }

    var x = Math.floor((setting.window_width - game_view.img_logo.width) / 2);
    var y = Math.floor(((setting.window_height / 2) - game_view.img_logo.height) / 2);
    if (y < 0) {
      y = 0;
    }
    var ctx = game_view.pane_board.getContext('2d');
    ctx.drawImage(game_view.img_logo, x, y);
    
    var text;
    var rect;
    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    var h = setting.dialog_window_height;
    var w;
    var func;

    x = Math.floor(setting.window_width / 2);
    y = Math.floor(setting.window_height / 2);

    y += h;
    text = L({ja: "はじめる", en: "Start"});
    w = ctx.measureText(text).width;
    rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y - h / 2),
	    width: w + 8 * 2, height: h};
    ctx.fillText(text, x, y);
    ctx.strokeText(text, x, y);
    func = function () {
      game_view.model_cur = {state: "game_init"};
      game_view.redraw();
    };
    game_view.controller_move_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});
    game_view.controller_click_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});

    y += h;
    var lang = [["日本語", "ja"], ["English", "en"]];
    w = 8;
    for (var i = 0; i < lang.length; i++) {
      if (i != 0) {
	w += 8 + ctx.measureText("/").width + 8;
      }
      w += ctx.measureText(lang[i][0]).width;
    }
    w += 8;
    
    x = Math.floor(x - w / 2) + 8;
    for (var i = 0; i < lang.length; i++) {
      if (i != 0) {
	x += 8;
	var sw = ctx.measureText("/").width;
	var sx = Math.floor(x + sw / 2);
	ctx.fillText("/", sx, y);
	ctx.strokeText("/", sx, y);
	x += sw + 8;
      }
      var lw = ctx.measureText(lang[i][0]).width;
      var l = lang[i][1];
      var lx = Math.floor(x + lw / 2);
      ctx.fillText(lang[i][0], lx, y);
      ctx.strokeText(lang[i][0], lx, y);
      rect = {x: Math.floor(lx - lw / 2) - 8, y: Math.floor(y - h / 2),
	      width: lw + 8 * 2, height: h};
      func = bind(function () {
	LANG = this.lang;
	game_view.draw_title();
      }, {lang: l});
      game_view.controller_move_array
	.push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	       func: bind(control_title, {rect: rect, func: func})});
      game_view.controller_click_array
	.push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	       func: bind(control_title, {rect: rect, func: func})});
      x += lw;
    }

    x = Math.floor(setting.window_width / 2);
    y += h;

    text = L({ja: "説明", en: "Help"});
    w = ctx.measureText(text).width;
    rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y - h / 2),
	    width: w + 8 * 2, height: h};
    ctx.fillText(text, x, y);
    ctx.strokeText(text, x, y);
    func = function () {
      location.href = setting.page_help;
    };
    game_view.controller_move_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});
    game_view.controller_click_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});

    y += h;
    text = L({ja: "設定", en: "Options"});
    w = ctx.measureText(text).width;
    rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y - h / 2),
	    width: w + 8 * 2, height: h};
    ctx.fillText(text, x, y);
    ctx.strokeText(text, x, y);
    func = function () {
      game_view.model_cur = {state: "setting"};
      game_view.redraw();
    };
    game_view.controller_move_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});
    game_view.controller_click_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});

    y += h;
    text = L({ja: "Version " + version(), en: "Version " + version()});
    w = ctx.measureText(text).width;
    rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y - h / 2),
	    width: w + 8 * 2, height: h};
    ctx.fillText(text, x, y);
    ctx.strokeText(text, x, y);

    // Clearing controller.
    rect = {x: 0, y: 0, width: setting.window_width,
	    height: setting.window_height};
    func = function () {
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      return true;
    }
    game_view.controller_move_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: func});
  },

  draw_setting : function () {
    game_view.clear_all();
    game_view.setting_window.style.display = "block";
    
    var html_ja = '\
<form>\
<table>\
<tr><td>カード:</td><td><select id="cards">\
<option value="simplest">超シンプルなカード (1024x768)</option>\
<option value="jrf_tarot_small">JRF タロット (小, 1024x768)</option>\
<option value="jrf_tarot_medium">JRF タロット (中, 1280x1024)</option>\
<option value="jrf_tarot_small_dense">JRF タロット (小・密, 800x600)</option>\
<option value="jrf_tarot_medium_dense">JRF タロット (中・密, 1024x768)</option>\
<option value="jrf_tarot_large_dense">JRF タロット (大・密, 1280x1024)</option>\
</select></td></tr>\
<tr><td>終了カードの繰り返し:</td><td><input id="rule_terminals" type="text" /></td></tr>\
<tr><td>コートカード:</td><td><select id="rule_court_card">\
<option value="K14">K = 14, Q = 13, C = 12, J = 11</option>\
<option value="K13a">K = 13, Q = 12, C = 12, J = 11</option>\
<option value="K13b">K = 13, Q = 12, C = 11, J = 11</option>\
<option value="K10">K = 10, Q = 10, C = 10, J = 10</option>\
</select></td></tr>\
<tr><td>大アルカナの影響:</td><td><select id="rule_major_influence">\
<option value="3">3</option>\
<option value="2.5">2.5</option>\
<option value="2">2</option>\
<option value="1.5">1.5</option>\
<option value="1">1</option>\
</select></td></tr>\
<tr><td>(8)と(11)の置換:</td><td><select id="rule_swap_8_11">\
<option value="memorial">記念式 (簡略)</option>\
<option value="expansive">開式</option>\
<option value="solid">固式</option>\
</select></td></tr>\
<tr><td>判定式:</td><td><select id="rule_determinant">\
<option value="greater">大なり</option>\
<option value="greater_equal">大なりイコール</option>\
</select></td></tr>\
<tr><td>計算時の暗転:</td><td><select id="calc_screen">\
<option value="true">する</option>\
<option value="false">しない</option>\
</select></td></tr>\
<tr><td>言語(Language):</td><td><select id="lang">\
<option value="ja">日本語</option>\
<option value="en">English</option>\
</select></td></tr>\
</table>\
\
<div id="set_button_container">\
<input id="set_button" type="button" value="設定" /> \
<input id="default_button" type="button" value="デフォルト" /> \
<input id="cancel_button" type="button" value="キャンセル" /> \
</div>\
</form>\
';

    var html_en = '\
<form>\
<table>\
<tr><td>Cards:</td><td><select id="cards">\
<option value="simplest">The simplest cards (1024x768)</option>\
<option value="jrf_tarot_small">The JRF Tarot (small, 1024x768)</option>\
<option value="jrf_tarot_medium">The JRF Tarot (medium, 1280x1024)</option>\
<option value="jrf_tarot_small_dense">The JRF Tarot (small dense, 800x600)</option>\
<option value="jrf_tarot_medium_dense">The JRF Tarot (medium dense, 1024x768)</option>\
<option value="jrf_tarot_large_dense">The JRF Tarot (large dense, 1280x1024)</option>\
</select></td></tr>\
<tr><td>Terminal Card Appears:</td><td><input id="rule_terminals" type="text" /></td></tr>\
<tr><td>Values of Court Cards:</td><td><select id="rule_court_card">\
<option value="K14">K = 14, Q = 13, C = 12, J = 11</option>\
<option value="K13a">K = 13, Q = 12, C = 12, J = 11</option>\
<option value="K13b">K = 13, Q = 12, C = 11, J = 11</option>\
<option value="K10">K = 10, Q = 10, C = 10, J = 10</option>\
</select></td></tr>\
<tr><td>Influence of the Major Arcana:</td><td><select id="rule_major_influence">\
<option value="3">3</option>\
<option value="2.5">2.5</option>\
<option value="2">2</option>\
<option value="1.5">1.5</option>\
<option value="1">1</option>\
</select></td></tr>\
<tr><td>Exchange of (VIII) and (XI):</td><td><select id="rule_swap_8_11">\
<option value="memorial">The Memorial Method (easy)</option>\
<option value="expansive">The Expansive Method</option>\
<option value="solid">The Solid Method</option>\
</select></td></tr>\
<tr><td>Determinant:</td><td><select id="rule_determinant">\
<option value="greater">Greater than</option>\
<option value="greater_equal">Greater than or equal to</option>\
</select></td></tr>\
<tr><td>Darkening on calculation:</td><td><select id="calc_screen">\
<option value="true">Do it</option>\
<option value="false">Don\'t do it</option>\
</select></td></tr>\
<tr><td>Language:</td><td><select id="lang">\
<option value="ja">日本語 (Japanese)</option>\
<option value="en">English</option>\
</select></td></tr>\
</table>\
\
<div id="set_button_container">\
<input id="set_button" type="button" value="Set" /> \
<input id="default_button" type="button" value="Default" /> \
<input id="cancel_button" type="button" value="Cancel" /> \
</div>\
</form>\
';
    
    game_view.setting_window.innerHTML = L({ja: html_ja, en: html_en});

    var names = ["rule_terminals", 
		 "rule_court_card",
		 "rule_major_influence",
		 "rule_swap_8_11",
		 "rule_determinant",
		 "calc_screen",
		 "cards",
		 "lang"];

    for (var i = 0; i < names.length; i++) {
      var n = names[i];
      var elt = document.getElementById(n);
      elt.value = setting[n];
    }

    var set_cookies = function () {
      for (var i = 0; i < names.length; i++) {
	var n = names[i];
	var elt = document.getElementById(n);
	var v = elt.value;
	if (v.match(/^[01-9]+$/)) {
	  v = parseInt(v, 10);
	} else if (v.match(/^-?[01-9]+\.[01-9]+$/)) {
	  v = parseFloat(v);
	} else if (v.match(/^true$/)) {
	  v = true;
	} else if (v.match(/^false$/)) {
	  v = false;
	}
	setting[n] = v;
	if (setting_default[n] == v) {
	  v = null;
	}
	set_cookie(n, v);
      }
      LANG = setting.lang;

      if (setting.cards != current_cards) {
	for (var n in cards_simplest) {
	  setting[n] = cards_simplest[n];
	}

	if (window["cards_" + setting.cards] != null
	    && setting.cards != 'simplest') {
	  var cs = window["cards_" + setting.cards];
	  for (var n in cs) {
	    setting[n] = cs[n];
	  }
	}
      }

      game_view.model_cur = {state: "title"};
      
      reload_images(bind(game_view.redraw, game_view));
    };

    var reset_to_default = function () {
      for (var i = 0; i < names.length; i++) {
	var n = names[i];
	var elt = document.getElementById(n);
	elt.value = setting_default[n];
      }
    };

    var cancel = function () {
      game_view.model_cur = {state: "title"};
      game_view.redraw();
    };

    document.getElementById("set_button")
      .addEventListener("click", set_cookies, false);
    document.getElementById("default_button")
      .addEventListener("click", reset_to_default, false);
    document.getElementById("cancel_button")
      .addEventListener("click", cancel, false);
  },

  draw_game_init : function () {
    game_view.clear_all();
    game_view.status_window.style.display = "block";
    game_view.status_window.innerHTML = "";
    
    var cur = {
      state: "game_init",
      purpose: null,
      purpose_degree: null,
      board: [],
      talon: [],
      discarded: [],
      token: null,
      swords_upper: [],
      coins_lower: [],
      coins_6: [],
      coins_5: [],
      coins_4: [],
      cups_3: [],
      cups_2: [],
      cups_1: [],
      drawn_terminals: 0,

      chosen_card: null,
      chosen_place: null,

      finish: null
    };
    game_view.model_cur = cur;

    var major = [];
    for (var i = 0; i < 22; i++) {
      if (i != 0 && i != 13) {
	major.push("A" + pad_left(i, 2, "0"));
      }
    }
    major = shuffle_array(major);
    for (var i = 0; i < 6; i++) {
      var x = Math.floor(Math.random() * major.length);
      var upright = Math.floor(Math.random() * 2);
      cur.board.push({card: major[x], upright: (upright == 0)});
      major.splice(x, 1);
    }

    for (var i = 0, l = ["S", "D", "H", "C"]; i < l.length; i++) {
      for (var j = 1; j < 15; j++) {
	cur.talon.push(l[i] + pad_left(j, 2, "0"));
      }
    }

    //for debug
    if (false) {
      cur.board =
	[
	  {card: "A01", upright: false},
	  {card: "A02", upright: false},
	  {card: "A03", upright: false},
	  {card: "A04", upright: false},
	  {card: "A07", upright: false},
	  {card: "A11", upright: false}
	];
    }

    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "choose_token_place";

    var bits = 0;
    var simul = 0;
    for (var i = 0; i< cur.board.length; i++) {
      var num = parseInt(cur.board[i].card.substr(1), 10);
      if (num % 2 == 1) {
	bits++;
      }
      if (num == 8 || num == 11) {
	simul++;
      }
    }

    next.board = [];
    for (var i = 0; i < cur.board.length; i++) {
      next.board[i] = cur.board[i];
      if ((setting.rule_swap_8_11 == "memorial")
	  || (setting.rule_swap_8_11 == "expansive"
	      && (bits > 3 || simul == 2
		  || (bits == 3 && cur.board[i].upright)))
	  || (setting.rule_swap_8_11 == "solid"
	      && bits >= 2 && bits <= 4)) {
	if (cur.board[i].card == "A08") {
	  next.board[i] = {card: "A11", upright: cur.board[i].upright};
	}
      }
      if ((setting.rule_swap_8_11 == "memorial")
	  || (setting.rule_swap_8_11 == "expansive"
	      && (bits < 3 || simul == 2
		  || (bits == 3 && cur.board[i].upright)))
	  || (setting.rule_swap_8_11 == "solid"
	      && bits >= 2 && bits <= 4)) {
	if (cur.board[i].card == "A11") {
	  next.board[i] = {card: "A08", upright: cur.board[i].upright};
	}
      }
    }

    var nbits = 0;
    var whirl = 0;
    var eclipse = 0;
    for (var i = 0; i< next.board.length; i++) {
      var num = parseInt(next.board[i].card.substr(1), 10);
      var upright = next.board[i].upright;
      if (num % 2 == 1) {
	nbits++;
      }
      if (num % 2 == 1) {
	if (upright) {
	  eclipse++;
	}
      } else {
	if (! upright) {
	  eclipse++;
	}
      }
      if (upright) {
	whirl++;
      }
    }

    if (setting.rule_swap_8_11 == "solid" && nbits == 3) {
      if (whirl == 0) {
	next.purpose = "A13";
	next.purpose_degree = "whirl";
      }
      if (whirl == 6) {
	next.purpose = "A00";
	next.purpose_degree = "whirl";
      }
      if (eclipse == 0) {
	next.purpose = "A13";
	next.purpose_degree = "eclipse";
      }
      if (eclipse == 6) {
	next.purpose = "A00";
	next.purpose_degree = "eclipse";
      }
    }

    var c = {x: 0, y: 0,
	     width: setting.window_width, height: setting.window_height,
	     func: function () {
	       game_view.lf.reset_animation();
	       game_view.redraw();
	     }
	    };
    game_view.controller_click_array.push(c);

    game_view.animation_temp = {prev_past: 0};
    game_view.lf.set_animation(game_view.animate_game_init);
  },

  animate_game_init :function (time) {
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var cur = game_view.model_cur;
    var next = game_view.model_next;
    var past = 0;
    var scene;
    
    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja:"大アルカナから " + L(setting.card_name[0]) + " と " + L(setting.card_name[13]) + " を抜きます。", en: "Sort out " + L(setting.card_name[0]) + " and " + L(setting.card_name[13]) + " from major arcana."});
      var img = make_cards_image(["A13", "A00"]);
      var anchor = game_view.anchor_purpose;
      var end = {x: anchor.x, y: anchor.y};
      var begin = {x: game_view.anchor_5.x, y: 0};
      if (Math.floor(end.x - img.width / 2) < game_view.window_left) {
	end.x = Math.floor(game_view.window_left + img.width / 2);
      }

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }

    past += scene;
    if (temp.prev_past <= past) {
      var img = make_cards_image(["A13", "A00"]);
      var anchor = game_view.anchor_purpose;
      var end = {x: anchor.x, y: anchor.y};
      end.x = Math.floor(end.x - img.width / 2);
      end.y = Math.floor(end.y - img.height / 2);
      if (end.x < game_view.window_left) {
	end.x = game_view.window_left;
      }
      var ctx2 = game_view.pane_board.getContext('2d');
      ctx2.drawImage(img, end.x, end.y);
    }

    scene = 500 * 6;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja:"大アルカナで盤を作ります。", en:"Make a game board from major arcana."});
      var num = Math.floor((time - past) / 500);
      var img = make_card_image("B0", 0);
      for (var i = 0; i < num; i++) {
	var anchor = game_view["anchor_" + (i + 1)];
	ctx.drawImage(img,
		      Math.floor(anchor.x - img.width / 2),
		      Math.floor(anchor.y - img.height / 2));
      }
      if (num < 6) {
	var end = game_view["anchor_" + (num + 1)];
	var begin = {x: 0, y: game_view.anchor_purpose.y};
	var r = (time - past - num * 500) / 500;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
      }

      temp.prev_past = time;
      return true;
    }

    past += scene;
    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_board.getContext('2d');
      for (var i = 0; i < 6; i++) {
	var anchor = game_view["anchor_" + (i + 1)];
	var c = cur.board[i];
	var rotation = 0;
	if (! c.upright) {
	  rotation = Math.PI;
	}
	var img = make_card_image(c.card, rotation);
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx2.drawImage(img, x, y);
      }
    }

    scene = 500 * 6;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja:"大アルカナで盤を作ります。", en:"Make a game board by major arcana."});
      var num = Math.floor((time - past) / 500);
      var img = make_card_image("B0", 0);
      for (var i = num + 1; i < 6; i++) {
	var anchor = game_view["anchor_" + (i + 1)];
	ctx.drawImage(img,
		      Math.floor(anchor.x - img.width / 2),
		      Math.floor(anchor.y - img.height / 2));
      }
      if (num < 6) {
	var r = Math.floor(((time - past - 500 * num) / 500) * 5);
	var img2 = make_card_image("B" + r, 0);
	var anchor2 = game_view["anchor_" + (num + 1)];
	var x = Math.floor(anchor2.x - img2.width / 2);
	var y = Math.floor(anchor2.y - img2.height / 2);
	ctx.drawImage(img2, x, y);
      }
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    var change = false;
    var a08;
    var a08rot = 0;
    var a11;
    var a11rot = 0;
    for (var i = 0; i < 6; i++) {
      var c = cur.board[i].card;
      var upright = cur.board[i].upright;
      if (c == "A08") {
	a08 = i;
	if (! upright) {
	  a08rot = Math.PI;
	}
	if (next.board[i].card != "A08") {
	  change = true;
	}
      }
      if (c == "A11") {
	a11 = i;
	if (! upright) {
	  a11rot = Math.PI;
	}
	if (next.board[i].card != "A11") {
	  change = true;
	}
      }
    }

    var bits = 0;
    var odds = "";
    var simul = 0;
    for (var i = 0; i< cur.board.length; i++) {
      var num = parseInt(cur.board[i].card.substr(1), 10);
      if (num % 2 == 1) {
	bits++;
	if (odds != "") {
	  odds += ", ";
	}
	odds += "(" + num + ")";
      }
      if (num == 8 || num == 11) {
	simul++;
      }
    }
    var nbits = 0;
    var nodds = "";
    var whirl = 0;
    var eclipse = 0;
    for (var i = 0; i< next.board.length; i++) {
      var num = parseInt(next.board[i].card.substr(1), 10);
      var upright = next.board[i].upright;
      if (num % 2 == 1) {
	nbits++;
	if (nodds != "") {
	  nodds += ", ";
	}
	nodds += "(" + num + ")";
      }
      if (num % 2 == 1) {
	if (upright) {
	  eclipse++;
	}
      } else {
	if (! upright) {
	  eclipse++;
	}
      }
      if (upright) {
	whirl++;
      }
    }

    var com;
    if (setting.rule_swap_8_11 == "expansive") {
      if (simul == 2) {
	com = L({ja: L(setting.card_name[8]) + " と " + L(setting.card_name[11]) + " が同時に出たので入れ替える必要があります。", en:"You need to swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + ", because they appeared together."});
      } else if (bits > 3) {
	com = L({ja:"奇数カードが " + bits + " (&gt;3) 枚出ています。" + L(setting.card_name[8]) + " が出ていれば入れ替える必要があります。", en:"Odd number cards are " + bits + " (&gt;3) cards.  You need to swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + " if " + L(setting.card_name[8]) + " appeared."});
      } else if (bits < 3) {
	com = L({ja:"奇数カードが " + bits + " (&lt;3) 枚出ています。" + L(setting.card_name[11]) + " が出ていれば入れ替える必要があります。", en:"Odd number cards are " + bits + " (&lt;3) cards.  You need to swap " + L(setting.card_name[11]) + " and " + L(setting.card_name[8]) + " if " + L(setting.card_name[11]) + " appeared."});
      } else if (bits == 3) {
	com = L({ja:"奇数カードが 3 枚出ています。" + L(setting.card_name[8]) + " か " + L(setting.card_name[11]) + " が正位置ならば入れ替える必要があります。", en:"Odd number cards are 3 cards.  You need to swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + " if one of them is upright."});
      }
    } else if (setting.rule_swap_8_11 == "solid") {
      if (bits >= 2 && bits <= 4) {
	com = L({ja:"奇数カードが " + bits + " (&gt;=2,&lt;=4)枚出ています。" + L(setting.card_name[8]) + " と " + L(setting.card_name[11]) + " を入れ替える必要があります。", en:"Odd number cards are " + bits + " (&gt;=2,&lt;=4) cards.  You need to swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + "."});
      }
    }
    if (com) {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = com;
	temp.prev_past = time;
	return true;
      }
      past += scene;
    }

    if (change) {
      scene = 3000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja:"タロットの歴史を記念し、" + L(setting.card_name[8]) + " と " + L(setting.card_name[11]) + " を入れ替えます。", en:"Swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + " after memory of the history of tarot."});
	var ctx2 = game_view.pane_board.getContext('2d');

	var anchor;
	var begin;
	var end;
	var r = (time - past) / scene;

	if (a08 != null) {
	  anchor = game_view["anchor_" + (a08 + 1)];
	  ctx2.clearRect(Math.floor(anchor.x - setting.card_width / 2),
			 Math.floor(anchor.y - setting.card_height / 2),
			 setting.card_width,
			 setting.card_height);
	  begin = {x: anchor.x, y: anchor.y, rot: a08rot};
	} else {
	  begin = {x: 0, y: game_view.anchor_purpose.y, rot: 0};
	}
	if (a11 != null) {
	  anchor = game_view["anchor_" + (a11 + 1)];
	  end = {x: anchor.x, y: anchor.y, rot:a11rot};
	} else {
	  end = {x: 0, y: game_view.anchor_purpose.y, rot: 0};
	}
	if (1) {
	  var img = make_card_image("A08",
				    begin.rot + (end.rot - begin.rot) * r);
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	if (a11 != null) {
	  anchor = game_view["anchor_" + (a11 + 1)];
	  ctx2.clearRect(Math.floor(anchor.x - setting.card_width / 2),
			 Math.floor(anchor.y - setting.card_height / 2),
			 setting.card_width,
			 setting.card_height);
	  begin = {x: anchor.x, y: anchor.y, rot: a11rot};
	} else {
	  begin = {x: 0, y: game_view.anchor_purpose.y, rot: 0};
	}
	if (a08 != null) {
	  anchor = game_view["anchor_" + (a08 + 1)];
	  end = {x: anchor.x, y: anchor.y, rot:a08rot};
	} else {
	  end = {x: 0, y: game_view.anchor_purpose.y, rot: 0};
	}
	if (1) {
	  var img = make_card_image("A11",
				    begin.rot + (end.rot - begin.rot) * r);
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    }

    if (setting.rule_swap_8_11 == "solid" && nbits == 3) {
      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_board.getContext('2d');
	for (var i = 0; i < 6; i++) {
	  var anchor = game_view["anchor_" + (i + 1)];
	  var c = next.board[i];
	  var rotation = 0;
	  if (! c.upright) {
	  rotation = Math.PI;
	  }
	  var img = make_card_image(c.card, rotation);
	  var x = Math.floor(anchor.x - img.width / 2);
	  var y = Math.floor(anchor.y - img.height / 2);
	  ctx2.clearRect(x, y, img.width, img.height);
	  ctx2.drawImage(img, x, y);
	}
      }
	
      scene = 1000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja:"奇数カードが 3 枚なので、スピンを調べます。", en:"Odd number cards are 3 cards.  Investigate spins."});
	temp.prev_past = time;
	return true;
      }
      past += scene;

      var com;
      if (whirl == 0) {
	com = L({ja:"「<em>旋坤</em>」。すべてのカードが逆位置です。", en:"<em>\"Field Whirl\"</em>.  All cards are reversal."});
      } else if (whirl == 6) {
	com = L({ja:"「<em>旋乾</em>」。すべてのカードが正位置です。", en:"<em>\"Force Whirl\"</em>.  All cards are upright."});
      } else if (eclipse == 0) {
	com = L({ja:"「<em>重坤</em>」。すべてのカードの偶奇とスピンが逆になっています。", en:"<em>\"Field Eclipse\"</em>.  The parity of all cards reversally meets their spin."});
      } else if (eclipse == 6) {
	com = L({ja:"「<em>重乾</em>」。すべてのカードの偶奇とスピンが合っています。", en:"<em>\"Force Eclipse\"</em>.  The parity of all cards meets their spin."});
      } else {
	com = L({ja:"奇数カードが 3 枚なので、スピンを調べます。<br/>→ 特に何もありません。", en:"Odd number cards are 3 cards.  Investigate spins.<br/>→ Nothing special."});
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = com;
	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
	
    game_view.redraw();
    return false;
  },

  draw_choose_token_place : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    var cur = game_view.model_cur;
    game_view.model_next = null;

    game_view.draw_board();

    if (cur.purpose == null) {
      cur.token = Math.floor(Math.random() * 6);
    } else if (cur.purpose == "A00") {
      cur.token = Math.floor(Math.random() * 3);
    } else if (cur.purpose == "A13") {
      cur.token = 3 + Math.floor(Math.random() * 3);
    }

    var restriction = "";
    var hexagram;
    if (cur.purpose_degree) {
      var r;
      if (cur.purpose_degree == "whirl" && cur.purpose == "A00") {
	hexagram = L({ja: "旋乾", en: "旋乾 Force Whirl"});
	r = L({ja: "下卦", en: "lower trigram"});
      } else if (cur.purpose_degree == "whirl" && cur.purpose == "A13") {
	hexagram = L({ja: "旋坤", en: "旋坤 Field Whirl"});
	r = L({ja: "上卦", en: "upper trigram"});
      } else if (cur.purpose_degree == "eclipse" && cur.purpose == "A00") {
	hexagram = L({ja: "重乾", en: "重乾 Force Eclipse"});
	r = L({ja: "下卦", en: "lower trigram"});
      } else if (cur.purpose_degree == "eclipse" && cur.purpose == "A13") {
	hexagram = L({ja: "重坤", en: "重坤 Field Eclipse"});
	r = L({ja: "上卦", en: "upper trigram"});
      }
      restriction = L({ja: "<br/>ただし、「" + hexagram + "」のため" + r + "にしか置けません。", en: "<br/>But \"" + hexagram + "\" restricts you onto " + r + "."});
    }

    if (hexagram == null) {
      var n = 0;
      for (var i = 0; i < 6; i++) {
	if (parseInt(cur.board[i].card.substr(1), 10) % 2) {
	  n += (1 << i);
	}
      }
      hexagram = L(HEXAGRAM[n]);
    }

    if (1) {
      var ctx = game_view.pane_control.getContext('2d');
      var img = game_view.img_token;
      var anchor = game_view["anchor_" + (game_view.model_cur.token + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
    }
    
    var control_token = function (ev, x, y) {
      var rect = this.rect;
      var place = this.place;
      var status = this.status;

      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	if (place != null) {
	  var ctx = game_view.pane_control.getContext('2d');
	  ctx.clearRect(0, 0, setting.window_width, setting.window_height);

	  game_view.model_cur.token = place;

	  var img = game_view.img_token;
	  var anchor = game_view["anchor_" + (game_view.model_cur.token + 1)];
	  var x1 = Math.floor(anchor.x - img.width / 2);
	  var y1 = Math.floor(anchor.y - img.height / 2);
	  ctx.drawImage(img, x1, y1);
	}
      }
      game_view.status_window.innerHTML = status;

      if (ev == "click") {
	if (typeof(setting.rule_terminals) != "number"
	    || setting.rule_terminals == 0) {
	  game_view.draw_game_end_0();
	} else {
	  game_view.chose_token_place();
	}
      }
    }

    if (true) {
      var anchor = game_view.anchor_purpose;
      var w = setting.card_height;
      var h = setting.card_height;
      var s;
      if (cur.purpose_degree) {
	h = setting.card_width;
	var s = L({ja: L(setting.card_name[parseInt(cur.purpose.substr(1), 10)]) + "。<br/>偶奇とスピンによる易の卦は「" + hexagram + "」です。", en:  L(setting.card_name[parseInt(cur.purpose.substr(1), 10)]) + ".<br/>Hexagram by parities and spins is \"" + hexagram + "\"."});
      } else {
	var s = L({ja: L(setting.card_name[13]) + " と " + L(setting.card_name[0]) + "。<br/>偶奇による易の卦は「" + hexagram + "」です。", en:  L(setting.card_name[13]) + " and " + L(setting.card_name[0]) + ".<br/>Hexagram by parities is \"" + hexagram + "\"."});

      }

      var x = Math.floor(anchor.x - w / 2);
      if (x < game_view.window_left) {
	x = game_view.window_left;
      }
      var y = Math.floor(anchor.y - h / 2);
      var c = {x: x, y: y, width: w, height: h,
	       func: bind(control_token,
			  {rect: {x: x, y: y, width: w, height: h},
			   status: s,
			   place: null})};
      game_view.controller_move_array.push(c);
    }

    for (var i = 0; i < 6; i++) {
      var anchor = game_view["anchor_" + (i + 1)];
      var card_num = parseInt(cur.board[i].card.substr(1), 10);
      var card_reversed = "";
      if (! cur.board[i].upright) {
	card_reversed = L({ja: " (逆)", en: " (reversed)"});
      }

      var x = Math.floor(anchor.x - setting.card_width / 2);
      var y = Math.floor(anchor.y - setting.card_height / 2);
      var s =L(setting.card_name[card_num]) + card_reversed + "<br/>" + read_major_arcana_string(cur.board[i]);
      var p = i;
      if (cur.purpose) {
	if ((cur.purpose == "A00" && i >= 3)
	    || (cur.purpose == "A13" && i < 3)) {
	  p = null;
	}
      }

      var c = {x: x, y: y, width: setting.card_width,
	       height: setting.card_height,
	       func: bind(control_token,
			  {rect: {x: x, y: y, width: setting.card_width,
				  height: setting.card_height},
			   status: s,
			   place: p})};

      if (p != null) {
	game_view.controller_click_array.push(c);
      }
      game_view.controller_move_array.push(c);
    }

    if (true) {
      var w = setting.window_width;
      var h = setting.window_height;
      var s = L({ja: "はじめに好きなところにトークンを置いてください。", en: "Please place the token, at first."}) + restriction;
      var c = {x: 0, y: 0, width: w, height: h,
	       func: bind(control_token,
			  {rect: {x: 0, y: 0, width: w, height: h},
			   status: s,
			   place: null})};
      game_view.controller_move_array.push(c);

      game_view.status_window.innerHTML = s;
    }
  },

  chose_token_place : function () {
    game_view.clear_animation();
    var cur = game_view.model_cur;
    if (cur.token < 3) {
      cur.purpose = "A00";
      cur.talon.push("A13");
    } else {
      cur.purpose = "A13";
      cur.talon.push("A00");
    }
    cur.talon = shuffle_array(cur.talon);

    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "wait_draw_card";
    cur.finish = function () {
      game_view.draw_board();
    }
    
    var c = {x: 0, y: 0,
	     width: setting.window_width, height: setting.window_height,
	     func: function () {
	       game_view.lf.reset_animation();
	       game_view.redraw();
	     }
	    };
    game_view.controller_click_array = [c];
    game_view.controller_move_array = [];

    game_view.animation_temp = {prev_past: 0};
    game_view.lf.set_animation(game_view.animate_chose_token_place);
  },

  animate_chose_token_place : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      game_view.draw_screen();
      game_view.draw_board();
    }

    var terminal;
    if (cur.purpose == "A13") {
      terminal = "A00";
    } else {
      terminal = "A13";
    }

    scene = 5000;
    if (time <= past + scene) {
      var c;
      if (terminal == "A00") {
	game_view.status_window.innerHTML = L({ja: "上卦にトークンが置かれたので、「終了カード」として " + L(setting.card_name[0]) + " を小アルカナの山に挿し入れ、シャッフルします。<br/>これが " + setting.rule_terminals + " 度目に引かれたときがゲーム終了です。", en: "Insert " + L(setting.card_name[0]) + " into the talon of minor arcana and shuffle, because you placed the token on upper trigram.<br/>The game is over if this \"terminal card\" appears " + setting.rule_terminals + " times."});
      } else {
	game_view.status_window.innerHTML = L({ja: "下卦にトークンが置かれたので、終了カードとして " + L(setting.card_name[13]) + " を小アルカナの山に挿し入れ、シャッフルします。<br/>これが " + setting.rule_terminals + " 度目に引かれたときがゲーム終了です。", en: "Insert " + L(setting.card_name[13]) + " into the talon of minor arcana and shuffle, because you placed the token on lower trigram.<br/>The game is over if this \"terminal card\" appears " + setting.rule_terminals + " times."});
      }
      var img = make_card_image(terminal, 0);
      var begin = game_view.anchor_purpose;
      var end = game_view.anchor_talon;

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;
    
    scene = 3000;
    if (time <= past + scene) {
      var img1, img2;
      var anchor1, anchor2;
      if (terminal== "A00") {
	game_view.status_window.innerHTML = L({ja: "終了時、上爻か五爻にトークンがあれば、あなたの勝ちです。", en: "You win at the end if the token places in the top or in the fifth."});
	img1 = make_card_image(cur.board[5].card, 
			       (cur.board[5].upright)? 0 : Math.PI);
	img2 = make_card_image(cur.board[4].card, 
			       (cur.board[4].upright)? 0 : Math.PI);
	anchor1 = game_view.anchor_6;
	anchor2 = game_view.anchor_5;
      } else {
	game_view.status_window.innerHTML = L({ja: "終了時、二爻か五爻にトークンがあれば、あなたの勝ちです。", en: "You win at the end if the token places in the second or in the fifth."});
	img1 = make_card_image(cur.board[1].card, 
			       (cur.board[1].upright)? 0 : Math.PI);
	img2 = make_card_image(cur.board[4].card, 
			       (cur.board[4].upright)? 0 : Math.PI);
	anchor1 = game_view.anchor_2;
	anchor2 = game_view.anchor_5;
      }
      var img3 = game_view.img_token;
      var anchor3 = game_view["anchor_" + (cur.token + 1)];
      ctx.drawImage(img1, Math.floor(anchor1.x - img1.width / 2),
		    Math.floor(anchor1.y - img1.height / 2));
      ctx.drawImage(img2, Math.floor(anchor2.x - img2.width / 2),
		    Math.floor(anchor2.y - img2.height / 2));
      ctx.drawImage(img3, Math.floor(anchor3.x - img3.width / 2),
		    Math.floor(anchor3.y - img3.height / 2));
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    game_view.redraw();
    return false;
  },

  draw_wait_draw_card : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (false) {
      if (! game_view.debug_inited) {
	cur.talon = ["S14", "A13"];
	cur.swords_upper = ["S01", "S02", "S03"];
	cur.coins_lower = ["D01", "D02", "D03", "D14", "D13", "D12"];
	cur.coins_6 = ["D04", "D05", "D06"];
	cur.coins_5 = ["D07", "D08", "D09"];
	cur.coins_4 = ["D10", "D11"];
	cur.cups_3 = ["H14", "H13", "H12", "H11", "H10"];
	cur.cups_2 = ["H09", "H08", "H07", "H06", "H05"];
	cur.cups_1 = ["H04", "H03", "H02", "H01"];

	game_view.debug_inited = true;
      }
    }

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();


    var control_draw_card = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	var img = game_view.img_hilit_talon;
	var anchor = game_view.anchor_talon;
	var x1 = Math.floor(anchor.x - img.width / 2);
	var y1 = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x1, y1);
      }
      if (ev == "click") {
	game_view.drew_card();
      }
    }

    if (1) {
      var img = game_view.img_hilit_talon;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      var c = {x: x, y: y, width: img.width, height: img.height,
	       func: bind(control_draw_card,
			  {rect: {x: x, y: y, width: img.width,
				  height: img.height}})};
      game_view.controller_click_array.push(c);
      game_view.controller_move_array.push(c);
    }
    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }

    game_view.status_window.innerHTML = L({ja: "カードを引いてください。", en: "Please draw a card."});
  },

  drew_card : function () {
    game_view.clear_animation();

    var cur = game_view.model_cur;
    cur.drawn = cur.talon.shift();
//    cur.drawn = "C05"; // for debug.
//    cur.cups_1 = ["H01", "H08"];

    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "wait_draw_card";
    next.drawn = null;

    var suit = cur.drawn.substr(0, 1);
    var score = calc_card_score(cur.drawn);
    var animate;

    if (suit == "A") {
      next.drawn_terminals++;
      if (next.drawn_terminals < setting.rule_terminals) {
	next.talon = shuffle_array(cur.talon.concat([cur.drawn], cur.discarded));
	next.discarded = [];
	animate = game_view.animate_shuffle;
	cur.finish = function () {
	  game_view.draw_board();
	};
      } else {
	next.state = "game_end";
	if ((cur.purpose == "A13" && (cur.token == 5 || cur.token == 4))
	    || (cur.purpose == "A00" && (cur.token == 1 || cur.token == 4))) {
	  next.win_or_lose = "win";
	} else {
	  next.win_or_lose = "lose";
	}
	animate = game_view.animate_game_end;
      }
      game_view.animation_temp = {prev_past: 0};
    } else if (cur.token >= 3) {
      switch (suit) {
	case "S":
	  var right = cur.token - 1;
	  determine_move_or_stay(cur, next, right, false);
	  game_view.animation_temp = {prev_past: 0,
				      dir: "right",
				      next_token: right, choice_ok: false};
	  animate = game_view.animate_determine_move_or_stay;
	  break;

	case "D":
	  determine_stay(cur, next);
	  game_view.animation_temp = {prev_past: 0};
	  animate = game_view.animate_determine_stay;
	  break;

	case "H":
	  var left = (cur.token + 1) % 6;
	  var lower = cur.token - 3;
	  game_view.animation_temp = {prev_past: 0,
				      next_token: left, cards_token: lower};
	  determine_move(cur, next, left, lower);
	  animate = game_view.animate_determine_move;
	  break;

	case "C":
	  var lower = cur.token - 3;
	  determine_move_or_stay(cur, next, lower, false);
	  game_view.animation_temp = {prev_past: 0,
				      dir: "lower",
				      next_token: lower, choice_ok: false};
	  animate = game_view.animate_determine_move_or_stay;
	  break;
      }
    } else {
      switch (suit) {
	case "S":
	  var upper = cur.token + 3;
	  determine_move_or_stay(cur, next, upper, true);
	  game_view.animation_temp = {prev_past: 0,
				      dir: "upper",
				      next_token: upper, choice_ok: true};
	  animate = game_view.animate_determine_move_or_stay;
	  break;

	case "D":
	  var left = cur.token + 1;
	  var upper = cur.token + 3;
	  game_view.animation_temp = {prev_past: 0,
				      next_token: left, cards_token: upper};
	  determine_move(cur, next, left, upper);
	  animate = game_view.animate_determine_move;
	  break;

	case "H":
	  determine_stay(cur, next);
	  game_view.animation_temp = {prev_past: 0};
	  animate = game_view.animate_determine_stay;
	  break;

	case "C":
	  var right = (cur.token -1 + 6) % 6;
	  determine_move_or_stay(cur, next, right, false);
	  game_view.animation_temp = {prev_past: 0,
				      dir: "right",
				      next_token: right, choice_ok: false};
	  animate = game_view.animate_determine_move_or_stay;
	  break;
      }
    }
    
    var c = {x: 0, y: 0,
	     width: setting.window_width, height: setting.window_height,
	     func: function () {
	       game_view.lf.reset_animation();
	       game_view.redraw();
	     }
	    };
    game_view.controller_click_array = [c];
    game_view.controller_move_array = [];

    game_view.lf.set_animation(animate);
  },

  animate_game_end : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    if (temp.prev_past <= past) {
      game_view.draw_screen();
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "終了カードを引きました。<br />" + setting.rule_terminals + " 度目なのでゲーム終了です。", en: "You drew the terminal card.<br/>The game is over, because it appeared " + setting.rule_terminals + "times."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 3000;
    if (time <= past + scene) {
      var win_or_lose;
      if (game_view.model_next.win_or_lose == "win") {
	win_or_lose = L({ja: "あなたの勝ちのようです。", en: "The board shows that you win."});
      } else {
	win_or_lose = L({ja: "あなたの負けのようです。", en: "The board shows that you lose."});
      }
	
      var img1, img2;
      var anchor1, anchor2;
      if (cur.purpose== "A13") {
	game_view.status_window.innerHTML = L({ja: "終了時、上爻か五爻にトークンがあれば、あなたの勝ちでした。<br/><em>" + win_or_lose + "</em>", en: "You must win at the end if the token places in the top or in the fifth.<br/><em>" + win_or_lose + "</em>"});
	img1 = make_card_image(cur.board[5].card, 
			       (cur.board[5].upright)? 0 : Math.PI);
	img2 = make_card_image(cur.board[4].card, 
			       (cur.board[4].upright)? 0 : Math.PI);
	anchor1 = game_view.anchor_6;
	anchor2 = game_view.anchor_5;
      } else {
	game_view.status_window.innerHTML = L({ja: "終了時、二爻か五爻にトークンがあれば、あなたの勝ちでした。<br/><em>" + win_or_lose + "</em>", en: "You must win at the end if the token places in the second or in the fifth.<br/><em>" + win_or_lose + "</em>"});
	img1 = make_card_image(cur.board[1].card, 
			       (cur.board[1].upright)? 0 : Math.PI);
	img2 = make_card_image(cur.board[4].card, 
			       (cur.board[4].upright)? 0 : Math.PI);
	anchor1 = game_view.anchor_2;
	anchor2 = game_view.anchor_5;
      }
      var img3 = game_view.img_token;
      var anchor3 = game_view["anchor_" + (cur.token + 1)];
      ctx.drawImage(img1, Math.floor(anchor1.x - img1.width / 2),
		    Math.floor(anchor1.y - img1.height / 2));
      ctx.drawImage(img2, Math.floor(anchor2.x - img2.width / 2),
		    Math.floor(anchor2.y - img2.height / 2));
      ctx.drawImage(img3, Math.floor(anchor3.x - img3.width / 2),
		    Math.floor(anchor3.y - img3.height / 2));
      temp.prev_past = time;
      return true;
    }
    past += scene;

    game_view.redraw();
    return false;
  },

  animate_shuffle : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_board.getContext('2d');
      var img = game_view.img_discarded;
      var anchor = game_view.anchor_discarded;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.clearRect(x, y, img.width, img.height);
    }

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_rest_talon.getContext('2d');
      ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
    }

    scene = 3000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "終了カードを引きました。<br />まだ、" + game_view.model_next.drawn_terminals + " (/" + setting.rule_terminals + ") 度目なので、捨て札を山に戻し、シャッフルします。", en: "You drew the terminal card.<br/>Shuffle the talon with the discarded cards, because it appeared "  + game_view.model_next.drawn_terminals + " (/" + setting.rule_terminals + ") times so far."});

      var img = game_view.img_discarded
      var begin = game_view.anchor_discarded;
      var end = game_view.anchor_talon;

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    game_view.redraw();
    return false;
  },

  animate_determine_stay : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    var trigram_name = (cur.token >= 3)?
	L({ja: "上卦", en: "upper trigram"}) :
	L({ja: "下卦", en: "lower trigram"});
    var suit_name = make_suit_name(cur.drawn);

    var cur_cards_name = null;
    if (cur.token >= 3) {
      cur_cards_name = "coins_" + (cur.token + 1);
    } else {
      cur_cards_name = "cups_" + (cur.token + 1);
    }

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: trigram_name + "で" + suit_name + "のカードを引きました。<br/>トークンは留まります。", en: "You drew a " + suit_name + " card on " + trigram_name + ".<br/>The token must stay."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (! temp.minor_rect) {
      var l = cur[cur_cards_name];
      var img;
      if (l && l.length > 0) {
	img = make_cards_image(l);
      } else {
	img = temp.img_drawn;
      }
      temp.minor_rect = calc_minor_rect(cur_cards_name, img);
    }

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "引いたカードは現在爻の" + suit_name + "とします。", en: "Place the drawn " + suit_name + " card onto the current place."});
      var img = temp.img_drawn;
      var begin = game_view.anchor_talon;
      var end = {x: temp.minor_rect.x + temp.minor_rect.width / 2,
		 y: temp.minor_rect.y + temp.minor_rect.height / 2};

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }
    past+= scene;
    
    game_view.redraw();
    return false;
  },

  animate_determine_move : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    var next_token = temp.next_token;
    var cards_token = temp.cards_token;

    var trigram_name = (cur.token >= 3)?
	L({ja: "上卦", en: "upper trigram"}) :
	L({ja: "下卦", en: "lower trigram"});
    var suit_name = make_suit_name(cur.drawn);
    var cards_place_name = (cards_token >= 3)?
	L({ja: "応爻", en: "upper trigram"}) :
	L({ja: "応爻", en: "lower trigram"});

    var cards_name = null;
    if (cards_token >= 3) {
      cards_name = "coins_" + (cards_token + 1);
    } else {
      cards_name = "cups_" + (cards_token + 1);
    }

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: trigram_name + "で" + suit_name + "のカードを引きました。<br/>順方向の比爻に動きます。", en: "You drew a " + suit_name + " card on " + trigram_name + ".<br/>Move left."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      if (cur[cards_name].length > 0) {
	temp.img_cards = make_cards_image(cur[cards_name]);
	temp.rect_cards
	  = calc_minor_rect(cards_name, temp.img_cards);
      } else {
	temp.rect_cards
	  = calc_minor_rect(cards_name, temp.img_drawn);
      }
    }

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    if (1) {
      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (next_token + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (next_token + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードは" + cards_place_name + "の" + suit_name + "とします。", en: "Place the drawn " + suit_name + " card onto the " + cards_place_name + "."});
	var img = temp.img_drawn;
	var begin = game_view.anchor_talon;
	var end = {x: temp.rect_cards.x + temp.rect_cards.width / 2,
		   y: temp.rect_cards.y + temp.rect_cards.height / 2};
	var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);

	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
    
    game_view.redraw();
    return false;
  },

  animate_determine_move_or_stay : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    var next_token = temp.next_token;
    var direction = temp.dir;
    var choice_ok = temp.choice_ok;
    
    var trigram_name = (cur.token >= 3)?
	L({ja: "上卦", en: "upper trigram"}) :
	L({ja: "下卦", en: "lower trigram"});
    var suit_name = make_suit_name(cur.drawn);
    var f = {right: L({ja: "右", en: "right"}),
	     upper: L({ja: "上", en: "upper"}),
	     lower: L({ja: "下", en: "lower"})};
    var dir_name = f[direction];
    var greater_name = "&gt;";
    if (setting.rule_determinant == "greater_equal") {
      greater_name = "&gt;=";
    }

    var cur_cards_name = null;
    var next_cards_name = null;
    if (cur.token >= 3) {
      cur_cards_name = "coins_" + (cur.token + 1);
    } else {
      cur_cards_name = "cups_" + (cur.token + 1);
    }
    if (next_token >= 3) {
      next_cards_name = "coins_" + (next_token + 1);
    } else {
      next_cards_name = "cups_" + (next_token + 1);
    }

    var m_minor_from = calc_card_score(cur.drawn);
    var f_minor_from = read_major_arcana(cur.board[cur.token]).coin_pain;
    var m_major_to = read_major_arcana(cur.board[next_token]).sword_offence;
    var f_minor_to = read_major_arcana(cur.board[next_token]).coin_pain;

    var cur_cards_max = -1;
    if (cur[cur_cards_name].length > 0) {
      var max = null;
      var max_score = 0;
      for (var i = 0, l = cur[cur_cards_name]; i < l.length; i++) {
	var s = calc_card_score(l[i]);
	if (s > max_score) {
	  max = i;
	  max_score = s;
	}
      }
      cur_cards_max = max;
      f_minor_from = max_score;
    }
    var next_cards_max = -1;
    if (cur[next_cards_name].length > 0) {
      var max = null;
      var max_score = 0;
      for (var i = 0, l = cur[next_cards_name]; i < l.length; i++) {
	var s = calc_card_score(l[i]);
	if (s > max_score) {
	  max = i;
	  max_score = s;
	}
      }
      next_cards_max = max;
      f_minor_to = max_score;
    }

    var ma = cur.board[cur.token];
    var ma_n = cur.board[next_token];

    
    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: trigram_name + "で" + suit_name + "のカードを引きました。<br/>" + dir_name + "に動くか否かを計算します。", en: "You drew a " + suit_name + " card on " + trigram_name +".<br/>Calculate whether the token can move " + dir_name + " or not."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past && setting.calc_screen) {
      game_view.draw_screen();
    }

    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = "M Minor From + F Minor From " + greater_name + " M Major To + F Minor To ?";
      temp.prev_past = time;
      return true;
    }
    past += scene;

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (temp.prev_past <= past) {
      if (cur[cur_cards_name].length > 0) {
	temp.img_cur_cards = make_cards_image(cur[cur_cards_name]);
	temp.rect_cur_cards
	  = calc_minor_rect(cur_cards_name, temp.img_cur_cards);
      } else {
	temp.rect_cur_cards
	  = calc_minor_rect(cur_cards_name, temp.img_drawn);
      }
      if (cur[next_cards_name].length > 0) {
	temp.img_next_cards = make_cards_image(cur[next_cards_name]);
	temp.rect_next_cards
	  = calc_minor_rect(next_cards_name, temp.img_next_cards);
      } else {
	temp.rect_next_cards
	  = calc_minor_rect(next_cards_name, temp.img_drawn);
      }
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = "<em>" + m_minor_from + "(= M Minor From)</em> + F Minor From " + greater_name + " M Major To + F Minor To ?";
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText(m_minor_from, anchor.x, anchor.y);
      ctx.strokeText(m_minor_from, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = m_minor_from + "(= M Minor From) + <em>" + f_minor_from + "(= F Minor From)</em> " + greater_name + " M Major To + F Minor To ?";
      if (cur_cards_max != -1) {
	var anchor = {x: Math.floor((temp.rect_cur_cards.x
				     + temp.rect_cur_cards.width / 2)),
		      y: Math.floor((temp.rect_cur_cards.y
				     + temp.rect_cur_cards.height / 2))};
	var img = make_card_image(cur[cur_cards_name][cur_cards_max], 0);
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
	ctx.fillStyle = 'white';
	var text = f_minor_from;
	ctx.fillText(text, anchor.x, anchor.y);
	ctx.strokeText(text, anchor.x, anchor.y);
      } else {
	var img = make_card_image(ma.card,
				  (ma.upright)? 0 : Math.PI);
	var anchor = game_view["anchor_" + (cur.token + 1)];
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
	ctx.fillStyle = 'white';
	var text = CHAR_COIN + f_minor_from;
	ctx.fillText(text, anchor.x, anchor.y);
	ctx.strokeText(text, anchor.x, anchor.y);
      }
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = m_minor_from + "(= M Minor From) + " + f_minor_from + "(= F Minor From) " + greater_name + " <em>" + m_major_to + "(= M Major To)</em> + F Minor To ?";
      if (1) {
	var img = make_card_image(ma_n.card,
				  (ma_n.upright)? 0 : Math.PI);
	var anchor = game_view["anchor_" + (next_token + 1)];
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
	ctx.fillStyle = 'white';
	var text = CHAR_SWORD + m_major_to;
	ctx.fillText(text, anchor.x, anchor.y);
	ctx.strokeText(text, anchor.x, anchor.y);
      }
      
      temp.prev_past = time;
      return true;
    }
    past += scene;
    
    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = m_minor_from + "(= M Minor From) + " + f_minor_from + "(= F Minor From) " + greater_name + " " + m_major_to + "(= M Major To) + <em>" + f_minor_to + "(= F Minor To)</em> ?";

      if (next_cards_max != -1) {
	var anchor = {x: Math.floor((temp.rect_next_cards.x
				     + temp.rect_next_cards.width / 2)),
		      y: Math.floor((temp.rect_next_cards.y
				     + temp.rect_next_cards.height / 2))};
	var img = make_card_image(cur[next_cards_name][next_cards_max], 0);
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
	ctx.fillStyle = 'white';
	var text = f_minor_to;
	ctx.fillText(text, anchor.x, anchor.y);
	ctx.strokeText(text, anchor.x, anchor.y);
      } else {
	var img = make_card_image(ma_n.card,
				  (ma_n.upright)? 0 : Math.PI);
	var anchor = game_view["anchor_" + (next_token + 1)];
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
	ctx.fillStyle = 'white';
	var text = CHAR_COIN + f_minor_to;
	ctx.fillText(text, anchor.x, anchor.y);
	ctx.strokeText(text, anchor.x, anchor.y);
      }
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    if (cur.move_or_stay == "move") {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja:  (m_minor_from + f_minor_from) + "(= M Minor From + F Minor From) " + greater_name + " " + (m_major_to + f_minor_to) + "(= M Major To + F Minor To) ?<br/>→ <em>然り。動く。</em>", en: (m_minor_from + f_minor_from) + "(= M Minor From + F Minor From) " + greater_name + " " + (m_major_to + f_minor_to) + "(= M Major To + F Minor To) ?<br/>→ <em>Yes, MOVE.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (next_token + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (next_token + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
	temp.img_max = null;
	if (cur_cards_max != -1) {
	  temp.img_max = make_card_image(cur[cur_cards_name][cur_cards_max], 0);
	}
	cur[cur_cards_name] = game_view.model_next[cur_cards_name];

	game_view.draw_minor();
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードと元の場所の最大のカードを捨てます。", en: "Discard the drawn card and the max card of the previous place."});
	if (temp.img_max) {
	  var img = temp.img_max;
	  var begin = {x: temp.rect_cur_cards.x + temp.rect_cur_cards.width / 2,
		       y: temp.rect_cur_cards.y + temp.rect_cur_cards.height / 2};
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    } else if (cur.move_or_stay == "stay") {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: (m_minor_from + f_minor_from) + "(= M Minor From + F Minor From) " + greater_name + " " + (m_major_to + f_minor_to) + "(= M Major To + F Minor To) ?<br/>→ <em>否。留まる。</em>", en: (m_minor_from + f_minor_from) + "(= M Minor From + F Minor From) " + greater_name + " " + (m_major_to + f_minor_to) + "(= M Major To + F Minor To) ?<br/>→ <em>No, STAY.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
	temp.img_max = null;
	if (next_cards_max != -1) {
	  temp.img_max = make_card_image(cur[next_cards_name][next_cards_max], 0);
	}
	cur[next_cards_name] = game_view.model_next[next_cards_name];

	game_view.draw_minor();
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードと" + dir_name + "の場所の最大のカードを捨てます。", en: "Discard the drawn card and the max card of the " + dir_name + " place."});
	if (temp.img_max) {
	  var img = temp.img_max;
	  var begin = {x: temp.rect_next_cards.x + temp.rect_next_cards.width / 2,
		       y: temp.rect_next_cards.y + temp.rect_next_cards.height / 2};
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    } else /* if (cur.move_or_stay == "choose") */ {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: (m_minor_from + f_minor_from) + "(= M Minor From + F Minor From) " + greater_name + " " + (m_major_to + f_minor_to) + "(= M Major To + F Minor To) ?<br/>→ <em>然り。選ぶ。</em>", en: (m_minor_from + f_minor_from) + "(= M Minor From + F Minor From) " + greater_name + " " + (m_major_to + f_minor_to) + "(= M Major To + F Minor To) ?<br/>→ <em>Yes, CHOOSE.</em>"});
	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
    
    game_view.redraw();
    return false;
  },

  animate_determine_move_or_stay2 : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    var next_token = temp.next_token;
    var direction = temp.dir;
    var choice_ok = temp.choice_ok;
    
    var trigram_name = (cur.token >= 3)?
	L({ja: "上卦", en: "upper trigram"}) :
	L({ja: "下卦", en: "lower trigram"});
    var suit_name = make_suit_name(cur.drawn);
    var f = {right: L({ja: "右", en: "right"}),
	     upper: L({ja: "上", en: "upper"}),
	     lower: L({ja: "下", en: "lower"})};
    var dir_name = f[direction];
    var greater_name = "&gt;";
    if (setting.rule_determinant == "greater_equal") {
      greater_name = "&gt;=";
    }

    var cur_cards_name = null;
    var next_cards_name = null;
    if (cur.token >= 3) {
      cur_cards_name = "coins_" + (cur.token + 1);
    } else {
      cur_cards_name = "cups_" + (cur.token + 1);
    }
    if (next_token >= 3) {
      next_cards_name = "coins_" + (next_token + 1);
    } else {
      next_cards_name = "cups_" + (next_token + 1);
    }

    var m_minor_from = calc_card_score(cur.drawn);
    var f_minor_from = read_major_arcana(cur.board[cur.token]).coin_pain;
    var m_major_to = read_major_arcana(cur.board[next_token]).sword_offence;
    var f_minor_to = read_major_arcana(cur.board[next_token]).coin_pain;

    var cur_cards_max = -1;
    if (cur[cur_cards_name].length > 0) {
      var max = null;
      var max_score = 0;
      for (var i = 0, l = cur[cur_cards_name]; i < l.length; i++) {
	var s = calc_card_score(l[i]);
	if (s > max_score) {
	  max = i;
	  max_score = s;
	}
      }
      cur_cards_max = max;
      f_minor_from = max_score;
    }
    var next_cards_max = -1;
    if (cur[next_cards_name].length > 0) {
      var max = null;
      var max_score = 0;
      for (var i = 0, l = cur[next_cards_name]; i < l.length; i++) {
	var s = calc_card_score(l[i]);
	if (s > max_score) {
	  max = i;
	  max_score = s;
	}
      }
      next_cards_max = max;
      f_minor_to = max_score;
    }

    var ma = cur.board[cur.token];
    var ma_n = cur.board[next_token];

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (temp.prev_past <= past) {
      if (cur[cur_cards_name].length > 0) {
	temp.img_cur_cards = make_cards_image(cur[cur_cards_name]);
	temp.rect_cur_cards
	  = calc_minor_rect(cur_cards_name, temp.img_cur_cards);
      } else {
	temp.rect_cur_cards
	  = calc_minor_rect(cur_cards_name, temp.img_drawn);
      }
      if (cur[next_cards_name].length > 0) {
	temp.img_next_cards = make_cards_image(cur[next_cards_name]);
	temp.rect_next_cards
	  = calc_minor_rect(next_cards_name, temp.img_next_cards);
      } else {
	temp.rect_next_cards
	  = calc_minor_rect(next_cards_name, temp.img_drawn);
      }
    }

    if (cur.move_or_stay == "move") {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "動きます。", en: "Now, move the token."});
	temp.prev_past = time;
	return true;
      }
      past += scene;
      
      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (next_token + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (next_token + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
	temp.img_max = null;
	if (cur_cards_max != -1) {
	  temp.img_max = make_card_image(cur[cur_cards_name][cur_cards_max], 0);
	}
	cur[cur_cards_name] = game_view.model_next[cur_cards_name];

	game_view.draw_minor();
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードと元の場所の最大のカードを捨てます。", en: "Discard the drawn card and the max card of the previous place."});
	if (temp.img_max) {
	  var img = temp.img_max;
	  var begin = {x: temp.rect_cur_cards.x + temp.rect_cur_cards.width / 2,
		       y: temp.rect_cur_cards.y + temp.rect_cur_cards.height / 2};
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    } else /* if (cur.move_or_stay == "stay") */ {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "留まります。", en: "You chose the token to stay."});
	temp.prev_past = time;
	return true;
      }
      past += scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }
      
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードを捨てます。", en: "Discard the drawn card."});
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
    
    game_view.redraw();
    return false;
  },

  draw_choose_move_or_stay : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (1) {
      var ctx = game_view.pane_drawn.getContext('2d');
      var img = make_card_image(cur.drawn, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
    }

    var ctx = game_view.pane_status.getContext('2d');
    ctx.font = setting.dialog_window_font;

    var x = game_view.anchor_5.x;
    var y = game_view.anchor_purpose.y;
    var text_move = L({ja: "動く", en: "MOVE"});
    var text_stay = L({ja: "留まる", en: "STAY"});
    var w_move = ctx.measureText(text_move).width;
    var w_stay = ctx.measureText(text_stay).width;
    var h = setting.dialog_window_height;
    var rect_move = {x: x - 8 - 8 - 8 - w_move,
		     y: Math.floor(y - h/2),
		     width: 16 + w_move,
		     height: h};
    var rect_stay = {x: x + 8,
		     y: Math.floor(y - h/2),
		     width: 16 + w_stay,
		     height: h};
    ctx.beginPath();
    ctx.rect(rect_move.x, rect_move.y,
	     rect_stay.x + rect_stay.width - rect_move.x,
	     rect_stay.y + rect_stay.height - rect_move.y);
    ctx.closePath();
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fill();

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    ctx.fillText(text_move, Math.floor(rect_move.x + 8 + w_move / 2), y);
    ctx.strokeText(text_move, Math.floor(rect_move.x + 8 + w_move / 2), y);
    ctx.fillText(text_stay, Math.floor(rect_stay.x + 8 + w_stay / 2), y);
    ctx.strokeText(text_stay, Math.floor(rect_stay.x + 8 + w_stay / 2), y);

    var control_choose = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	ctx.beginPath()
	ctx.rect(rect.x, rect.y, rect.width, rect.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.7)";
	ctx.fill();
      }
      if (ev == "click") {
	cur.move_or_stay = this.choice;
	game_view.chose_move_or_stay();
      }
    }

    var cm = {x: rect_move.x, y: rect_move.y,
	      width: rect_move.width, height: rect_move.height,
	      func: bind(control_choose, {rect: rect_move, choice: "move"})};
    game_view.controller_click_array.push(cm);
    game_view.controller_move_array.push(cm);

    var cs = {x: rect_stay.x, y: rect_stay.y,
	      width: rect_stay.width, height: rect_stay.height,
	      func: bind(control_choose, {rect: rect_stay, choice: "stay"})};
    game_view.controller_click_array.push(cs);
    game_view.controller_move_array.push(cs);

    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }

    game_view.status_window.innerHTML = L({ja: "動くか留まるか決めてください。", en: "Decide whether the token should move or stay."});
  },

  chose_move_or_stay : function () {
    game_view.clear_animation();
    if (1) {
      var ctx = game_view.pane_status.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    }
    var cur = game_view.model_cur;

    if (1) {
      var ctx = game_view.pane_drawn.getContext('2d');
      var img = make_card_image(cur.drawn, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
    }

    var upper = cur.token + 3;
    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "wait_draw_card";
    next.drawn = null;

    process_chose_move_or_stay(cur, next, upper);

    var c = {x: 0, y: 0,
	     width: setting.window_width, height: setting.window_height,
	     func: function () {
	       game_view.lf.reset_animation();
	       game_view.redraw();
	     }
	    };
    game_view.controller_click_array = [c];
    game_view.controller_move_array = [];

    game_view.animation_temp = {prev_past: 0,
				dir: "upper",
				next_token: upper, choice_ok: false};
    game_view.lf.set_animation(game_view.animate_determine_move_or_stay2);
  },

  draw_game_end : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (1) {
      game_view.draw_screen();
    }

    var x = Math.floor(setting.window_width / 2);
    var y1 = Math.floor(setting.window_height / 2) - setting.dialog_window_height;
    var y2 = Math.floor(setting.window_height / 2) + setting.dialog_window_height;

    var text1;
    if (cur.win_or_lose == "win") {
      text1 = L({ja: "勝ち", en: "YOU WIN"});
      game_view.status_window.innerHTML = L({ja: "あなたの勝ちです。", en: "You win the game."});
    } else {
      text1 = L({ja: "負け", en: "YOU LOSE"});
      game_view.status_window.innerHTML = L({ja: "あなたの負けです。", en: "You lose the game."});
    }
    var text2 = L({ja: "タイトルに戻ります。", en: "Go back to the title."});

    var ctx = game_view.pane_status.getContext('2d');

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    ctx.fillText(text1, x, y1);
    ctx.strokeText(text1, x, y1);

    var w = ctx.measureText(text2).width;
    var h = setting.dialog_window_height;
    var rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y2 - h / 2),
		width: w + 8 * 2, height: h};
    ctx.fillText(text2, x, y2);
    ctx.strokeText(text2, x, y2);

    var control_goto_title = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	ctx.beginPath()
	ctx.rect(rect.x, rect.y, rect.width, rect.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.7)";
	ctx.fill();
      }
      if (ev == "click") {
	game_view.model_cur = {state: "title"};
	game_view.redraw();
      }
    }

    var c = {x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_goto_title, {rect: rect})};
    game_view.controller_click_array.push(c);
    game_view.controller_move_array.push(c);

    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }
  },

  draw_game_end_0 : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (1) {
      game_view.draw_screen();
    }

    game_view.status_window.innerHTML = L({ja: "設定の「終了カードの繰り返し」が 0 または数値でないため、ここで終了します。", en: "Go back to the title, because the option \"Terminal Card Appears\" is 0 or not a number."});

    var x = Math.floor(setting.window_width / 2);
    var y1 = Math.floor(setting.window_height / 2) - setting.dialog_window_height;
    var y2 = Math.floor(setting.window_height / 2) + setting.dialog_window_height;

    var text2 = L({ja: "タイトルに戻ります。", en: "Go back to the title."});

    var ctx = game_view.pane_status.getContext('2d');

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    var w = ctx.measureText(text2).width;
    var h = setting.dialog_window_height;
    var rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y2 - h / 2),
		width: w + 8 * 2, height: h};
    ctx.fillText(text2, x, y2);
    ctx.strokeText(text2, x, y2);

    var control_goto_title = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	ctx.beginPath()
	ctx.rect(rect.x, rect.y, rect.width, rect.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.7)";
	ctx.fill();
      }
      if (ev == "click") {
	game_view.model_cur = {state: "title"};
	game_view.redraw();
      }
    }

    var c = {x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_goto_title, {rect: rect})};
    game_view.controller_click_array.push(c);
    game_view.controller_move_array.push(c);

    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }
  },

  draw_board : function () {
    var purpose = game_view.model_cur.purpose;
    var purpose_degree = game_view.model_cur.purpose_degree;
    var board = game_view.model_cur.board;
    var ctx = game_view.pane_board.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    
    for (var i = 0; i < 6; i++) {
      var anchor = game_view["anchor_" + (i + 1)];
      var card = board[i].card;
      var rotation = 0;
      if (! board[i].upright) {
	rotation = Math.PI;
      }
			
      var img = make_card_image(card, rotation);
      ctx.drawImage(img,
		    Math.floor(anchor.x - (img.width / 2)),
		    Math.floor(anchor.y - (img.height / 2)));
    }

    if (purpose) {
      var rot;
      if (purpose_degree == null) {
	rot = 0;
      } else if (purpose_degree == "whirl") {
	rot = Math.PI / 2;
      } else if (purpose_degree == "eclipse") {
	rot = 3 * Math.PI / 2;
      }
      var anchor = game_view.anchor_purpose;
      var img = make_card_image(purpose, rot);
      var x = Math.floor(anchor.x - (img.width / 2));
      var y = Math.floor(anchor.y - (img.height / 2));
      if (x < game_view.window_left) {
	x = game_view.window_left;
      }
      ctx.drawImage(img, x, y);
    } else {
      var anchor = game_view.anchor_purpose;
      var img = make_cards_image(["A13", "A00"]);
      ctx.drawImage(img,
		    Math.floor(anchor.x - (img.width / 2)),
		    Math.floor(anchor.y - (img.height / 2)));
    }
    
    if (1) {
      var anchor = game_view.anchor_talon;
      var img = game_view.img_talon;
      ctx.drawImage(img,
		    Math.floor(anchor.x - (img.width / 2)),
		    Math.floor(anchor.y - (img.height / 2)));
    }

    if (1) {
      var anchor = game_view.anchor_discarded;
      var img = game_view.img_discarded;
      var y = Math.floor(anchor.y - (img.height / 2));
      if ((y + img.height) > game_view.window_bottom) {
	y = game_view.window_bottom - img.height;
      }
      ctx.drawImage(img,
		    Math.floor(anchor.x - (img.width / 2)),
		    y);
    }
  },

  draw_minor : function () {
    var ctx = game_view.pane_minor.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    for (var i = 0, l = ["swords_upper", "coins_lower",
			 "coins_6", "coins_5", "coins_4",
			 "cups_3", "cups_2", "cups_1"];
	 i < l.length; i++) {
      var cards = game_view.model_cur[l[i]];
      if (cards && cards.length > 0) {
	var img = make_cards_image(cards);
	var rect = calc_minor_rect(l[i], img);
	ctx.drawImage(img, rect.x, rect.y);
      }
    }
  },

  draw_rest_talon : function () {
    var ctx = game_view.pane_rest_talon.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    var num = game_view.model_cur.talon.length;
    var x = game_view.anchor_talon.x;
    var y = game_view.anchor_talon.y;
    if (game_view.img_talon.height > setting.card_height) {
      y = Math.floor(y - game_view.img_talon.height / 2
		     - setting.dialog_window_height / 2);
    } else {
      y = Math.floor(y - setting.card_height / 2
		     - setting.dialog_window_height / 2);
    }
    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    ctx.fillText(num, x, y);
    ctx.strokeText(num, x, y);
  },

  draw_token : function () {
    var ctx = game_view.pane_token.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    var img = game_view.img_token;
    var anchor = game_view["anchor_" + (game_view.model_cur.token + 1)];
    var x = Math.floor(anchor.x - img.width / 2);
    var y = Math.floor(anchor.y - img.height / 2);
    ctx.drawImage(img, x, y);
  },

  draw_screen : function () {
    game_view.pane_screen.style.display = "block";
  },

  clear_screen : function () {
    game_view.pane_screen.style.display = "none";
  },

  clear_animation : function () {
    game_view.animation_temp = {};
    for (var i = 0, l = ["pane_control", "pane_animation", "pane_drawn"];
	 i < l.length; i++) {
      var pane = game_view[l[i]];
      var ctx = pane.getContext('2d');
      ctx.clearRect(0, 0, pane.width, pane.height);
    }
    game_view.clear_screen();
  },

  clear_all : function () {
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];
    game_view.status_window.style.display = "none";
    game_view.setting_window.style.display = "none";
    game_view.animation_temp = {};
    for (var i = 0; i < game_view.panes.length; i++) {
      var pane = game_view[game_view.panes[i]];
      var ctx = pane.getContext('2d');
      ctx.clearRect(0, 0, pane.width, pane.height);
    }
    game_view.pane_screen.style.display = "none";
    if (1) {
      var ctx2 = game_view.pane_screen.getContext('2d');
      ctx2.beginPath();
      ctx2.rect(0, 0, setting.window_width, setting.window_height);
      ctx2.closePath()
      ctx2.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx2.fill();
    }
  }
};

function reload_images (callback) {
  if (current_cards && current_cards == setting.cards) {
    callback();
    return;
  }

  var div = game_view.main_window;
  var ad = game_view.ad_area;

  div.innerHTML = "";

  document.body.style.background = setting.page_background;

  div.style.position = "absolute";
  div.style.width = "" + setting.window_width + "px";
  div.style.height = "" + setting.window_height + "px";
//  div.style.border = "solid 2px black";
  div.style.background = setting.window_background;
  if (ad) {
    ad.style.position = "absolute";
    ad.style.width = "100%";
    ad.style.left = "0px";
  }

  window.onresize = function () {
    var div = game_view.main_window;
    var ad = game_view.ad_area;
    var iw = window.innerWidth || document.body.clientWidth;
    var ih = window.innerHeight || document.body.clientHeight;
    if (iw > setting.window_width) {
      div.style.left = "" + Math.floor((iw - setting.window_width) / 2) + "px";
    } else {
      div.style.left = "0px";
    }
    if (ad) {
      if (iw > setting.window_width) {
	ad.style.width = "100%";
      } else {
	ad.style.width = "" + setting.window_width + "px";
      }
    }
    if (ad) {
      var ah = (ad.innerHeight || ad.clientHeight) + 10;
      if (ih > setting.window_height + ah) {
	div.style.top = "" + Math.floor((ih - setting.window_height - ah) / 2) + "px";
	ad.style.top = "" + (Math.floor((ih - setting.window_height - ah) / 2)
			     + setting.window_height + 10) + "px";
	ad.style.display = "block";
      } else {
	div.style.top = "0px";
	ad.style.top = "" + (setting.window_height + 10) + "px";
      }
    } else {
      if (ih > setting.window_height) {
	div.style.top = "" + Math.floor((ih - setting.window_height) / 2) + "px";
      } else {
	div.style.top = "0px";
      }
    }
  }
  window.onresize();

  game_view.panes = [];
  for (var i = 0, l = [["pane_control", 100],
		       ["pane_temp", 99],
		       ["pane_dialog", 60],
		       ["pane_animation", 50],
		       ["pane_status", 20],
		       ["pane_screen", 15],
		       ["pane_rest_talon", 14],
		       ["pane_drawn", 11],
		       ["pane_token", 10],
		       ["pane_minor", 2],
		       ["pane_board", 1]];
       i < l.length; i++) {
    var n = l[i][0];
    var z = l[i][1];
    
    var w = document.createElement('canvas');
    w.style.position = "absolute";
    w.style.top = "0px";
    w.style.left = "0px";
    w.width = setting.window_width;
    w.height = setting.window_height;
    div.appendChild(w);
    w.style.zIndex = z;

    game_view[n] = w;
    game_view.panes.push(n);
  }
  game_view.pane_temp.style.display = "none";

  game_view.window_top = 4;
  game_view.window_bottom = setting.window_height - setting.status_window_height - 4;
  game_view.window_left = 4;
  game_view.window_right = setting.window_width - 4;
  
  for (var i = 0, l = ["logo", "cards", "backs", "talon", "discarded", "token"];
       i < l.length; i++) {
    game_view["img_" + l[i]] = load_image(setting["img_" + l[i]]);
  }

  current_cards  = setting.cards;
  setting.load_status = 'waiting';
  set_cookie("load_status", 'waiting');
  wait_load(bind(reload_images_2, {callback: callback}));
  return;
}

function reload_images_2 () {
  game_view.img_hilit_talon
    = make_overlay_image(game_view.img_talon);

  if (1) {
    var x1 = game_view.window_left;
    var y1 = game_view.window_top;
    var x2 = game_view.window_right;
    var y2 = game_view.window_bottom;
    var yc;
    var xc;
    var xtmp;
    var ytmp;

    if (game_view.img_talon.width > setting.card_width) { 
      x2 = x2 - game_view.img_talon.width;
      xtmp = x2 + Math.floor(game_view.img_talon.width / 2);
    } else {
      x2 = x2 - setting.card_width;
      xtmp = x2 + Math.floor(setting.card_width / 2);
    }
    if (game_view.img_talon.height > setting.card_height) {
      ytmp = y2 - Math.ceil(game_view.img_talon.height / 2);
    } else {
      ytmp = y2 - Math.ceil(setting.card_height / 2);
    }
    game_view.anchor_talon = {x: xtmp, y: ytmp};
    x2 = x2 - game_view.img_discarded.width;
    xtmp = x2 + Math.floor(game_view.img_discarded.width / 2);
    game_view.anchor_discarded = {x: xtmp, y: null};
    xtmp = x1 + Math.floor((setting.card_width + (setting.card_width / 2))/2);
    x1 = x1 + setting.card_width + Math.floor(setting.card_width / 2);
    game_view.anchor_purpose = {x: xtmp, y: null};
    xc = Math.floor((x1 + x2) / 2);
    yc = Math.floor((y1 + y2) / 2);
    game_view.anchor_discarded.y = yc;
    game_view.anchor_purpose.y = yc;
    ytmp = y1 + Math.ceil(setting.card_height / 2);
    game_view.anchor_swords_upper = {x: xc, y: ytmp};
    ytmp = y2 - Math.ceil(setting.card_height / 2);
    game_view.anchor_coins_lower = {x: xc, y: ytmp};
    ytmp = Math.floor(y2 - (y2 - yc) / 3);
    xtmp = Math.floor(x2 - (setting.card_width / 2));
    game_view.anchor_1 = {x: xtmp, y: ytmp};
    xtmp = Math.floor(x1 + (setting.card_width / 2));
    game_view.anchor_3 = {x: xtmp, y: ytmp};
    xtmp = Math.floor((x2 + xc) / 2);
    ytmp = Math.floor(y1 + (yc - y1) / 3);
    game_view.anchor_4 = {x: xtmp, y: ytmp};
    xtmp = Math.floor((x1 + xc) / 2);
    game_view.anchor_6 = {x: xtmp, y: ytmp};
    ytmp = Math.floor(yc + (y2 - yc) / 3);
    game_view.anchor_2 = {x: xc, y: ytmp};
    ytmp = Math.floor(yc - (yc - y1) / 3);
    game_view.anchor_5 = {x: xc, y: ytmp};
  }

  var pc = game_view.pane_control;
  pc.addEventListener("mousemove", function (ev) {
    var x = ev.offsetX || ev.layerX || (window.event && window.event.offsetX);
    var y = ev.offsetY || ev.layerY || (window.event && window.event.offsetY);

    game_view.lf.process_event("move", x, y);
  }, false);
  pc.addEventListener("mouseout", function (ev) {
    var x = ev.offsetX || ev.layerX || (window.event && window.event.offsetX);
    var y = ev.offsetY || ev.layerY || (window.event && window.event.offsetY);

    game_view.lf.process_event("move", x, y);
  }, false);
  pc.addEventListener("click", function (ev) {
    var x = ev.offsetX || ev.layerX || (window.event && window.event.offsetX);
    var y = ev.offsetY || ev.layerY || (window.event && window.event.offsetY);
    game_view.lf.process_event("click", x, y);
  }, false);

  var status_window = document.createElement('div');
  status_window.id = "status_window";
  status_window.style.position = "absolute";
  status_window.style.top = "" + (setting.window_height
			       - setting.status_window_height) + "px";
  status_window.style.left = "0px";
  status_window.style.width = "" + (setting.window_width - 20) + "px";
  status_window.style.height = "" + (setting.status_window_height - 30) + "px";
  status_window.style.display = "none";
  game_view.main_window.appendChild(status_window);
  game_view.status_window = status_window;

  var setting_window = document.createElement('div');
  setting_window.id = "setting_window";
  setting_window.style.position = "absolute";
  setting_window.style.width = "" + Math.floor(setting.window_width * 0.8) + "px";
  setting_window.style.left = "" + Math.floor(setting.window_width * 0.1) + "px";
  setting_window.style.height = "" + Math.floor(setting.window_height * 0.8) + "px";
  setting_window.style.top = "" + Math.floor(setting.window_height * 0.1) + "px";
  setting_window.style.display = "none";
  game_view.main_window.appendChild(setting_window);
  game_view.setting_window = setting_window;

  set_cookie("load_status", 'done');
  setting.load_status = 'done';

  this.callback();
  return;
}

function init () {
  var div = document.getElementById('main');
  game_view.main_window = div;
  var ad = document.getElementById('ad_area');
  game_view.ad_area = ad;
			     

  var c1 = document.createElement('canvas');

  if (! c1 || ! c1.getContext) {
    game_view.main_window.innerHTML = '<h2>略式易双六 ～ Simplified Youscout Tarot Solitaire</h2>'
      + '<p>This page needs Canvas on JavaScript. The author tested this program on Firefox 8, InternetExplorer 9 and Google Chrome 15.</p>';
    return;
  }

  read_setting();
  LANG = setting.lang;

  reload_images(bind(game_view.draw_title, game_view));
//  alert("OK");
}

window.onload = init;
</script>

</head>

<body>
<div id="main"></div>
<noscript>
<h2>略式易双六 ～ Simplified Youscout Tarot Solitaire</h2>
<p>This page needs JavaScript. Sorry.</p>
</noscript>

<!-- XREA Banner -->
<!--nobanner-->
<!--
<div id="ad_area">
<script type="text/javascript" src="https://cache1.value-domain.com/xa.j?site=jrockford.s1010.xrea.com"></script>
</div>
-->

<!-- Google AdSense - Cocolog Youscout -->
<!--
<div id="ad_area">
<div id="ad_google">
<script type="text/javascript">
    google_ad_client = "ca-pub-0065765675450647";
    google_ad_slot = "6210687822";
    google_ad_width = 728;
    google_ad_height = 90;
</script>
<script type="text/javascript"
src="//pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
-->

</body>
</html>
