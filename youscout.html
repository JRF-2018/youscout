<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Time-stamp: "2020-04-24T02:29:20Z" -->

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Language" content="ja,en" />

<title>易双六 Youscout ～ Tarot Solitaire</title>

<meta name="author" content="JRF" />
<meta name="version" content="0.31" />
<meta name="home" content="http://jrf.cocolog-nifty.com/archive/youscout/index.html" />
<meta name="archive" content="http://jrf.cocolog-nifty.com/archive/youscout/youscout.zip" />
<meta name="keywords" content="tarot,タロット,solitaire,ソリティア,易,yi-king,yi-ching,iching" />
<meta name="description" lang="en" content="A sort of solitaire games playing with tarot cards, inspired by arguments about Yi-Ching divination." />
<meta name="description" lang="ja" content="タロットカードを使ったソリティアの一種。易経の理論からヒントを得ている。" />

<!-- <link rel="shortcut icon" href="simplest/youscout.ico" type="image/x-icon" /> -->
<link rel="shortcut icon" href="simplest/token.png" type="image/png" />


<style type="text/css">
  #setting_window {
    padding: 10px;
    font: 18px 'MS PGothic',sans-serif;
    color: white;
    background: rgba(0, 0, 0, 0.4);
    z-index: 110;
    overflow: auto;
  }

  #status_window {
    padding: 5px 5px 10px 10px;
    font: 18px 'MS PGothic',sans-serif;
    color: white;
    border: double 3px white;
    background: rgba(0, 0, 0, 0.4);
    z-index: 20;
  }

  #status_window p {
    margin: 0;
  }

  #status_window em {
    font-style: normal;
    font-weight: bold;
    text-decoration: underline;
    color: yellow;
    margin: 0;
  }

  #ad_area {
/*    display: none;*/
    text-align: center;
    padding: 0;
    margin: 0;
    padding-bottom: 10px;
  }

  #ad_google {
    display: inline-block;
    margin-left: auto;
    margin-right: auto;
  }
</style>

<script type="text/javascript">

var FORCE_DEFAULT_JRF_TAROT = false;
//var FORCE_DEFAULT_JRF_TAROT = 'local';

if (location.href.match(/[?&]jrf_tarot=local/i)) {
  FORCE_DEFAULT_JRF_TAROT = 'local';
}

var LANG = "ja";
if (location.href.match(/[?&]default_lang=(en|ja)/)) {
  LANG = RegExp.$1;
}

var TABLE_OF_MAJOR_ARCANA = [
  // (0) 愚者 The Fool (使わない Not Use)
  {S_O: 0, S_D: 5, D_P: 5, D_G: 5, H_U: 5, H_L: 5, C_U: 3, C_L: 5},
  // (1) 魔術師 The Magician
  {S_O: 3, S_D: 3, D_P: 5, D_G: 7, H_U: 0, H_L: 3, C_U: 7, C_L: 5},
  // (2) 女教皇 The High Priestess
  {S_O: 0, S_D: 5, D_P: 7, D_G: 3, H_U: 7, H_L: 5, C_U: 3, C_L: 3},
  // (3) 女帝 The Empress
  {S_O: 3, S_D: 3, D_P: 0, D_G: 3, H_U: 7, H_L: 5, C_U: 5, C_L: 7},
  // (4) 皇帝 The Emperor
  {S_O: 3, S_D: 3, D_P: 0, D_G: 3, H_U: 5, H_L: 7, C_U: 7, C_L: 5},
  // (5) 法王 The Hierophant
  {S_O: 5, S_D: 0, D_P: 7, D_G: 3, H_U: 3, H_L: 3, C_U: 7, C_L: 5},
  // (6) 恋人 The Lovers
  {S_O: 3, S_D: 3, D_P: 5, D_G: 3, H_U: 5, H_L: 7, C_U: 7, C_L: 0},
  // (7) 戦車 The Chariot
  {S_O: 7, S_D: 7, D_P: 3, D_G: 3, H_U: 0, H_L: 3, C_U: 5, C_L: 5},
  // (8) 力 Strength
  {S_O: 5, S_D: 5, D_P: 0, D_G: 3, H_U: 7, H_L: 7, C_U: 3, C_L: 3},
  // (9) 隠者 The Hermit
  {S_O: 0, S_D: 7, D_P: 7, D_G: 3, H_U: 3, H_L: 3, C_U: 5, C_L: 5},
  // (10) 運命の輪 Wheel of Fortune
  {S_O: 5, S_D: 5, D_P: 5, D_G: 5, H_U: 5, H_L: 5, C_U: 3, C_L: 0},
  // (11) 正義 Justice
  {S_O: 5, S_D: 5, D_P: 5, D_G: 5, H_U: 0, H_L: 3, C_U: 5, C_L: 5},
  // (12) 吊るされた男 The Hanged Man
  {S_O: 3, S_D: 5, D_P: 3, D_G: 7, H_U: 3, H_L: 5, C_U: 0, C_L: 7},
  // (13) 死神 Death (使わない Not Use)
  {S_O: 5, S_D: 0, D_P: 5, D_G: 5, H_U: 5, H_L: 3, C_U: 5, C_L: 5},
  // (14) 節制 Temperance
  {S_O: 5, S_D: 5, D_P: 7, D_G: 3, H_U: 3, H_L: 7, C_U: 0, C_L: 3},
  // (15) 悪魔 The Devil
  {S_O: 5, S_D: 3, D_P: 3, D_G: 7, H_U: 5, H_L: 0, C_U: 3, C_L: 7},
  // (16) 塔 The Tower
  {S_O: 5, S_D: 7, D_P: 5, D_G: 3, H_U: 7, H_L: 0, C_U: 3, C_L: 3},
  // (17) 星 The Star
  {S_O: 5, S_D: 3, D_P: 5, D_G: 7, H_U: 3, H_L: 3, C_U: 7, C_L: 0},
  // (18) 月 The Moon
  {S_O: 3, S_D: 7, D_P: 0, D_G: 7, H_U: 5, H_L: 5, C_U: 3, C_L: 3},
  // (19) 太陽 The Sun
  {S_O: 7, S_D: 3, D_P: 0, D_G: 7, H_U: 3, H_L: 3, C_U: 5, C_L: 5},
  // (20) 審判 Judgement
  {S_O: 5, S_D: 0, D_P: 7, D_G: 3, H_U: 3, H_L: 5, C_U: 3, C_L: 7},
  // (21) 世界 The World
  {S_O: 0, S_D: 5, D_P: 3, D_G: 7, H_U: 7, H_L: 3, C_U: 3, C_L: 5}
];

var CARD_NAME_RIDER_WAITE = [
  {ja: "(0) 愚者", en: "(0) The Fool"},
  {ja: "(1) 魔術師", en: "(I) The Magician"},
  {ja: "(2) 女教皇", en: "(II) The High Priestess"},
  {ja: "(3) 女帝", en: "(III) The Empress"},
  {ja: "(4) 皇帝", en: "(IV) The Emperor"},
  {ja: "(5) 法王", en: "(V) The Hierophant"},
  {ja: "(6) 恋人", en: "(VI) The Lovers"},
  {ja: "(7) 戦車", en: "(VII) The Chariot"},
  {ja: "(8) 力", en: "(VIII) Strength"},
  {ja: "(9) 隠者", en: "(IX) The Hermit"},
  {ja: "(10) 運命の輪", en: "(X) Wheel of Fortune"},
  {ja: "(11) 正義", en: "(XI) Justice"},
  {ja: "(12) 吊るされた男", en: "(XII) The Hanged Man"},
  {ja: "(13) 死神", en: "(XIII) Death"},
  {ja: "(14) 節制 ", en: "(XIV) Temperance"},
  {ja: "(15) 悪魔", en: "(XV) The Devil"},
  {ja: "(16) 塔", en: "(XVI) The Tower"},
  {ja: "(17) 星", en: "(XVII) The Star"},
  {ja: "(18) 月", en: "(XVIII) The Moon"},
  {ja: "(19) 太陽", en: "(XIX) The Sun"},
  {ja: "(20) 審判", en: "(XX) Judgement"},
  {ja: "(21) 世界", en: "(XXI) The World"}
];

var HEXAGRAM = [ // Comments from wikipedia:"I Ching".
  //02. ¦¦¦¦¦¦ Field (坤 kūn) 	The Receptive 	Needing Knowledge & Skill; Do not force matters and go with the flow
  /* 0b000000 */ {ja: "坤", en: "坤 Field"},
  //23. ¦¦¦¦¦| Stripping (剝 bō) 	Splitting Apart 	Stripping, Flaying
  /* 0b000001 */ {ja: "剝", en: "剝 Stripping"},
  //08. ¦¦¦¦|¦ Grouping (比 bǐ) 	Holding Together 	Union
  /* 0b000010 */ {ja: "比", en: "比 Grouping"},
  //20. ¦¦¦¦|| Viewing (觀 guān) 	Contemplation 	The Withholding
  /* 0b000011 */ {ja: "觀", en: "觀 Viewing"},
  //16. ¦¦¦|¦¦ Providing-For (豫 yù) 	Enthusiasm 	Inducement, New Stimulus
  /* 0b000100 */ {ja: "豫", en: "豫 Providing-For"},
  //35. ¦¦¦|¦| Prospering (晉 jìn) 	Progress 	Expansion, Promotion
  /* 0b000101 */ {ja: "晉", en: "晉 Prospering"},
  //45. ¦¦¦||¦ Clustering (萃 cuì) 	Gathering Together 	Association, Companionship
  /* 0b000110 */ {ja: "萃", en: "萃 Clustering"},
  //12. ¦¦¦||| Obstruction (否 pǐ) 	Standstill 	Stagnation
  /* 0b000111 */ {ja: "否", en: "否 Obstruction"},
  //15. ¦¦|¦¦¦ Humbling (謙 qiān) 	Modesty 	Being Reserved, Refraining
  /* 0b001000 */ {ja: "謙", en: "謙 Humbling"},
  //52. ¦¦|¦¦| Bound (艮 gèn) 	The Keeping Still 	Immobility
  /* 0b001001 */ {ja: "艮", en: "艮 Bound"},
  //39. ¦¦|¦|¦ Limping (蹇 jiǎn) 	Obstruction 	Halting, Hardship
  /* 0b001010 */ {ja: "蹇", en: "蹇 Limping"},
  //53. ¦¦|¦|| Infiltrating (漸 jiàn) 	Development 	Auspicious Outlook, Infiltration
  /* 0b001011 */ {ja: "漸", en: "漸 Infiltrating"},
  //62. ¦¦||¦¦ Small Exceeding (小過 xiǎo guò) 	Small Preponderance 	Small Surpassing
  /* 0b001100 */ {ja: "小過", en: "小過 Small Exceeding"},
  //56. ¦¦||¦| Sojourning (旅 lǚ) 	The Wanderer 	Travel
  /* 0b001101 */ {ja: "旅", en: "旅 Sojourning"},
  //31. ¦¦|||¦ Conjoining (咸 xián) 	Influence 	Attraction
  /* 0b001110 */ {ja: "咸", en: "咸 Conjoining"},
  //33. ¦¦|||| Retiring (遯 dùn) 	Retreat 	Withdrawing
  /* 0b001111 */ {ja: "遯", en: "遯 Retiring"},
  //07. ¦|¦¦¦¦ Leading (師 shī) 	The Army 	Bringing Together, Teamwork
  /* 0b010000 */ {ja: "師", en: "師 Leading"},
  //04. ¦|¦¦¦| Enveloping (蒙 méng) 	Youthful Folly 	Detained, Enveloped and Inexperienced
  /* 0b010001 */ {ja: "蒙", en: "蒙 Enveloping"},
  //29. ¦|¦¦|¦ Gorge (坎 kǎn) 	The Abysmal Water 	Darkness, Gorge
  /* 0b010010 */ {ja: "坎", en: "坎 Gorge"},
  //59. ¦|¦¦|| Dispersing (渙 huàn) 	Dispersion 	Dispersal
  /* 0b010011 */ {ja: "渙", en: "渙 Dispersing"},
  //40. ¦|¦|¦¦ Taking-Apart (解 xiè) 	Deliverance 	Liberation, Solution
  /* 0b010100 */ {ja: "解", en: "解 Taking-Apart"},
  //64. ¦|¦|¦| Not-Yet Fording (未濟 wèi jì)
  /* 0b010101 */ {ja: "未濟", en: "未濟 Not-Yet Fording"},
  //47. ¦|¦||¦ Confining (困 kùn) 	Oppression 	Exhaustion
  /* 0b010110 */ {ja: "困", en: "困 Confining"},
  //06. ¦|¦||| Arguing (訟 sòng) 	Conflict 	Engagement in Conflict
  /* 0b010111 */ {ja: "訟", en: "訟 Arguing"},
  //46. ¦||¦¦¦ Ascending (升 shēng) 	Pushing Upward 	Growing Upward
  /* 0b011000 */ {ja: "升", en: "升 Ascending"},
  //18. ¦||¦¦| Corrupting (蠱 gǔ) 	Work on the Decayed 	Repairing
  /* 0b011001 */ {ja: "蠱", en: "蠱 Corrupting"},
  //48. ¦||¦|¦ Welling (井 jǐng) 	The Well 	Replenishing, Renewal
  /* 0b011010 */ {ja: "井", en: "井 Welling"},
  //57. ¦||¦|| Ground (巽 xùn) 	The Gentle 	Subtle Influence
  /* 0b011011 */ {ja: "巽", en: "巽 Ground"},
  //32. ¦|||¦¦ Persevering (恆 héng) 	Duration 	Perseverance
  /* 0b011100 */ {ja: "恆", en: "恆 Persevering"},
  //50. ¦|||¦| Holding (鼎 dǐng) 	The Cauldron 	Establishing the New
  /* 0b011101 */ {ja: "鼎", en: "鼎 Holding"},
  //28. ¦||||¦ Great Exceeding (大過 dà guò) 	Great Preponderance 	Great Surpassing
  /* 0b011110 */ {ja: "大過", en: "大過 Great Exceeding"},
  //44. ¦||||| Coupling (姤 gòu) 	Coming to Meet 	Encountering
  /* 0b011111 */ {ja: "姤", en: "姤 Coupling"},
  //24. |¦¦¦¦¦ Returning (復 fù) 	Return 	Returning
  /* 0b100000 */ {ja: "復", en: "復 Returning"},
  //27. |¦¦¦¦| Swallowing (頤 yí) 	Mouth Corners 	Seeking Nourishment
  /* 0b100001 */ {ja: "頤", en: "頤 Swallowing"},
  //03. |¦¦¦|¦ Sprouting (屯 zhūn) 	Difficulty at the Beginning 	Sprouting
  /* 0b100010 */ {ja: "屯", en: "屯 Sprouting"},
  //42. |¦¦¦|| Augmenting (益 yì) 	Increase 	Increase
  /* 0b100011 */ {ja: "益", en: "益 Augmenting"},
  //51. |¦¦|¦¦ Shake (震 zhèn) 	Arousing 	Mobilizing
  /* 0b100100 */ {ja: "震", en: "震 Shake"},
  //21. |¦¦|¦| Gnawing Bite (噬嗑 shì kè) 	Biting Through 	Deciding
  /* 0b100101 */ {ja: "噬嗑", en: "噬嗑 Gnawing Bite"},
  //17. |¦¦||¦ Following (隨 suí) 	Following 	Following
  /* 0b100110 */ {ja: "隨", en: "隨 Following"},
  //25. |¦¦||| Without Embroiling (無妄 wú wàng) 	Innocence 	Without Rashness
  /* 0b100111 */ {ja: "無妄", en: "無妄 Without Embroiling"},
  //36. |¦|¦¦¦ Brightness Hiding (明夷 míng yí) 	Darkening of the Light 	Brilliance Injured
  /* 0b101000 */ {ja: "明夷", en: "明夷 Brightness Hiding"},
  //22. |¦|¦¦| Adorning (賁 bì) 	Grace 	Embellishing
  /* 0b101001 */ {ja: "賁", en: "賁 Adorning"},
  //63. |¦|¦|¦ Already Fording (既濟 jì jì) 	After Completion 	Completion
  /* 0b101010 */ {ja: "既濟", en: "既濟 Already Fording"},
  //37. |¦|¦|| Dwelling People (家人 jiā rén) 	The Family 	Family
  /* 0b101011 */ {ja: "家人", en: "家人 Dwelling People"},
  //55. |¦||¦¦ Abounding (豐 fēng) 	Abundance 	Goal Reached, Ambition Achieved
  /* 0b101100 */ {ja: "豐", en: "豐 Abounding"},
  //30. |¦||¦| Radiance (離 lí) 	The Clinging 	Clinging, Attachment
  /* 0b101101 */ {ja: "離", en: "離 Radiance"},
  //49. |¦|||¦ Skinning (革 gé) 	Revolution 	Abolishing the Old
  /* 0b101110 */ {ja: "革", en: "革 Skinning"},
  //13. |¦|||| Concording People (同人 tóng rén) 	Fellowship 	Fellowship, Partnership
  /* 0b101111 */ {ja: "同人", en: "同人 Concording People"},
  //19. ||¦¦¦¦ Nearing (臨 lín) 	Approach 	Approaching Goal, Arriving
  /* 0b110000 */ {ja: "臨", en: "臨 Nearing"},
  //41. ||¦¦¦| Diminishing (損 sǔn) 	Decrease 	Decrease
  /* 0b110001 */ {ja: "損", en: "損 Diminishing"},
  //60. ||¦¦|¦ Articulating (節 jié) 	Limitation 	Discipline
  /* 0b110010 */ {ja: "節", en: "節 Articulating"},
  //61. ||¦¦|| Centre Confirming (中孚 zhōng fú) 	Inner Truth 	Staying Focused, Avoid Misrepresentation
  /* 0b110011 */ {ja: "中孚", en: "中孚 Centre Confirming"},
  //54. ||¦|¦¦ Converting The Maiden (歸妹 guī mèi) 	The Marrying Maiden 	Marrying
  /* 0b110100 */ {ja: "歸妹", en: "歸妹 Converting The Maiden"},
  //38. ||¦|¦| Polarising (睽 kuí) 	Opposition 	Division, Divergence
  /* 0b110101 */ {ja: "睽", en: "睽 Polarising"},
  //58. ||¦||¦ Open (兌 duì) 	The Joyous 	Overt Influence
  /* 0b110110 */ {ja: "兌", en: "兌 Open"},
  //10. ||¦||| Treading (履 lǚ) 	Treading (Conduct) 	Continuing with Alertness
  /* 0b110111 */ {ja: "履", en: "履 Treading"},
  //11. |||¦¦¦ Pervading (泰 tài) 	Peace 	Pervading
  /* 0b111000 */ {ja: "泰", en: "泰 Pervading"},
  //26. |||¦¦| Great Accumulating (大畜 dà chù) 	Great Taming 	Accumulating Wisdom
  /* 0b111001 */ {ja: "大畜", en: "大畜 Great Accumulating"},
  //05. |||¦|¦ Attending (需 xū) 	Waiting 	Uninvolvement (Wait for now), Nourishment
  /* 0b111010 */ {ja: "需", en: "需 Attending"},
  //09. |||¦|| Small Accumulating (小畜 xiǎo chù) 	Small Taming 	Accumulating Resources
  /* 0b111011 */ {ja: "小畜", en: "小畜 Small Accumulating"},
  //34. ||||¦¦ Great Invigorating (大壯 dà zhuàng) 	Great Power 	Great Boldness
  /* 0b111100 */ {ja: "大壯", en: "大壯 Great Invigorating"},
  //14. ||||¦| Great Possessing (大有 dà yǒu) 	Great Possession 	Independence, Freedom
  /* 0b111101 */ {ja: "大有", en: "大有 Great Possessing"},
  //43. |||||¦ Parting (夬 guài) 	Breakthrough 	Separation
  /* 0b111110 */ {ja: "夬", en: "夬 Parting"},
  //01. |||||| Force (乾 qián) 	The Creative 	Possessing Creative Power & Skill
  /* 0b111111 */ {ja: "乾", en: "乾 Force"}
];

var CHAR_SWORD = "\u2660"; // ♠
var CHAR_COIN = "\u2666";  // ♦
var CHAR_CUP = "\u2665";   // ♥
var CHAR_WAND = "\u2663";  // ♣
var CHAR_SLASH = "/";
var CHAR_UPDOWN = "\u223D"; // ∽
var CHAR_DIVISION = "|";


var setting_default = {
  lang: LANG,
  page_help: "index.html",
    cards: ((FORCE_DEFAULT_JRF_TAROT || location.hostname == 'jrf.cocolog-nifty.com')? ((window.innerHeight && window.innerHeight > 768)? 'jrf_tarot_medium' : 'jrf_tarot_small_dense') : 'simplest'),

  rule_terminals: 3,
  rule_court_card: "K14",
  // K14 == { K: 14, Q: 13, C: 12, J: 11 },
  // K13a == { K: 13, Q: 12, C: 12, J: 11 },
  // K13b == { K: 13, Q: 12, C: 11, J: 11 },
  // K10 == { K: 10, Q: 10, C: 10, J: 10 },
  rule_major_influence: 2,
  rule_swap_8_11: "memorial",

  rule_replacement: 3,
  rule_cross_border: "cups_and_coins",
  rule_replacement_coins_lower: 2,

  calc_screen: true,

  // for system.
  load_status: 'done'
};

var current_cards;

var cards_simplest = {
  window_width: 1024,
  window_height: 768,
//  window_background: '#223776',
  window_background: '#10431f',
  page_background: '#10431f',
  status_window_height: 128,
  dialog_window_font: "32px 'MS PGothic',sans-serif",
  dialog_window_height: 48,
  
  card_width: 80,
  card_height: 128,

  img_logo: "simplest/logo.png",
  img_cards: "simplest/cards.png",
  img_backs: "simplest/backs.png",
  img_talon: "simplest/talon.png",
  img_discarded: "simplest/discarded.png",
  img_token: "simplest/token.png",

  card_name: CARD_NAME_RIDER_WAITE,
  number_table: TABLE_OF_MAJOR_ARCANA
};

var jrf_tarot_dir = 'http://jrf.cocolog-nifty.com/archive/youscout/jrf_tarot';

if (FORCE_DEFAULT_JRF_TAROT && FORCE_DEFAULT_JRF_TAROT == 'local') {
  jrf_tarot_dir = 'jrf_tarot';
}

var cards_jrf_tarot_small = {
  window_width: 1024,
  window_height: 768,

  card_width: 82,
  card_height: 128,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/small/cards.png",
  img_backs: jrf_tarot_dir + "/small/backs.png",
  img_talon: jrf_tarot_dir + "/small/talon.png",
  img_discarded: jrf_tarot_dir + "/small/discarded.png"
//  img_token: "simplest/token.png",
};

var cards_jrf_tarot_small_dense = {
  window_width: 800,
  window_height: 600,

  card_width: 82,
  card_height: 128,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/small/cards.png",
  img_backs: jrf_tarot_dir + "/small/backs.png",
  img_talon: jrf_tarot_dir + "/small/talon.png",
  img_discarded: jrf_tarot_dir + "/small/discarded.png"
//  img_token: "simplest/token.png",
};

var cards_jrf_tarot_medium = {
  window_width: 1280,
  window_height: 1024,

  card_width: 103,
  card_height: 160,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/medium/cards.png",
  img_backs: jrf_tarot_dir + "/medium/backs.png",
  img_talon: jrf_tarot_dir + "/medium/talon.png",
  img_discarded: jrf_tarot_dir + "/medium/discarded.png"
//  img_token: "simplest/token.png",
};

var cards_jrf_tarot_medium_dense = {
  window_width: 1024,
  window_height: 768,

  card_width: 103,
  card_height: 160,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/medium/cards.png",
  img_backs: jrf_tarot_dir + "/medium/backs.png",
  img_talon: jrf_tarot_dir + "/small/talon.png",
  img_discarded: jrf_tarot_dir + "/small/discarded.png"
//  img_token: "simplest/token.png",
};

var cards_jrf_tarot_large_dense = {
  window_width: 1280,
  window_height: 1024,

  card_width: 162,
  card_height: 252,

//  img_logo: "simplest/logo.png",
  img_cards: jrf_tarot_dir + "/large/cards.png",
  img_backs: jrf_tarot_dir + "/large/backs.png",
  img_talon: jrf_tarot_dir + "/medium/talon.png",
  img_discarded: jrf_tarot_dir + "/medium/discarded.png"
//  img_token: "simplest/token.png",
};

function L(h) {
  return h[LANG] || h["en"];
}

function bind(f, o) {
  return function() {return f.apply(o, arguments)};
}

function fatal(mes) {
  alert(mes);
}

function pad_left(s, num, pad) {
  s = s.toString();
  var r = s;
  for (var i = 0; i < num - s.length; i++) {
    r = pad + r;
  }
  return r.substr(r.length - num, num);
}

function version() {
  var a = document.getElementsByTagName("meta");
  for (var i = 0; i < a.length; i++) {
    if (a[i].name == "version") {
      return a[i].content;
    }
  }
  return "0.00";
}

function shuffle_array (l) {
  var r = [];
  while (l.length > 0) {
    var i = Math.floor(Math.random() * l.length);
    r.push(l[i]);
    l.splice(i, 1);
  }
  return r;
}

var setting;

function read_setting () {
  setting = {};
  for (var n in setting_default) {
    setting[n] = setting_default[n];
  }

  if (document.cookie) {
    var a = document.cookie.split("; ");
    for (var i = 0; i < a.length; i++) {
      var p = a[i].split("=");
      var name = p[0];
      var v = unescape(p[1]);
      if (v.match(/^[01-9]+$/)) {
	v = parseInt(v, 10);
      } else if (v.match(/^-?[01-9]+\.[01-9]+$/)) {
	v = parseFloat(v);
      } else if (v.match(/^true$/)) {
	v = true;
      } else if (v.match(/^false$/)) {
	v = false;
      }
      if (name.indexOf("youscout_", 0) == 0) {
	name = name.substr("youscout_".length);
	setting[name] = v;
      }
    }
  }

  if (setting.load_status == 'waiting') {
    setting.cards = "simplest";
  }

  for (var n in cards_simplest) {
    setting[n] = cards_simplest[n];
  }

  if (window["cards_" + setting.cards] != null && setting.cards != 'simplest') {
    var cs = window["cards_" + setting.cards];
    for (var n in cs) {
      setting[n] = cs[n];
    }
  }
}

function set_cookie (name, value) {
  var str;
  name = "youscout_" + name;
  if (value !== null) {
    str = name + "=" + escape(value);
  } else {
    str = name + "=";
  }
  var path =location.pathname;
  if (path.lastIndexOf("/") > 0) {
    path = path.substring(0, path.lastIndexOf("/") + 1);
  }
  str += "; path=" + path;
  var expires = 365;
  if (value === null) {
    expires = -1;
  }
  expires = new Date((new Date()).getTime() + expires * 60 * 60 * 24 * 1000);
  str += "; expires=" + expires.toGMTString();
  document.cookie = str;
}

var load_waiting = 0;
var load_error = null;

function _image_loaded(ev) {
  if (load_waiting > 0) {
    load_waiting--;
  }
}

function _image_error(ev) {
  if (load_waiting > 0) {
    load_waiting--;
  }
  load_error = this.src;
}

function load_image(src) {
  var img = new Image();
  load_waiting++;
  img.onload = _image_loaded;
  img.onerror = bind(_image_error, {src: src});
  img.src = src;
  return img;
}

function _wait_load() {
  if (load_error) {
    fatal(load_error + L({ja: "\n読み込みに失敗しました。リロードすると解決するかも。何度も失敗してるならカードの絵を変えてみてください。", en: "\nFailed to load.  Try reload.  Please change cards if you fail often."}));
  } else {
    if (load_waiting) {
      setTimeout(bind(_wait_load, this), 500);
    } else {
      this.func();
    }
  }
}

function wait_load(func) {
  (bind(_wait_load, {func: func}))();
}

function calc_card_score (card) {
  var num = parseInt(card.substr(1), 10);

  var rule;
  switch (setting.rule_court_card) {
  case "K14":
    rule = {K: 14, Q: 13, C: 12, J: 11};
    break;
  case "K13a":
    rule = {K: 13, Q: 12, C: 12, J: 11};
    break;
  case "K13b":
    rule = {K: 13, Q: 12, C: 11, J: 11};
    break;
  case "K10":
    rule = {K: 10, Q: 10, C: 10, J: 10};
    break;
  }
  switch (num) {
  case 14:
    return rule.K;
  case 13:
    return rule.Q;
  case 12:
    return rule.C;
  case 11:
    return rule.J;
  default:
    return num;
  }
}

function read_major_arcana(c) {
  var card = c.card;
  var upright = c.upright;
  var t = setting.number_table[parseInt(card.substr(1), 10)];
  var s = {};
  for (var n in t) {
    s[n] = Math.ceil(t[n] * setting.rule_major_influence);
  }
  if (upright) {
    return {sword_offence: s.S_O, sword_defence: s.S_D,
	    coin_pain: s.D_P, coin_gain: s.D_G,
	    cup_upper: s.H_U, cup_lower: s.H_L,
	    wand_upper: s.C_U, wand_lower: s.C_L};
  } else {
    return {sword_offence: s.S_D, sword_defence: s.S_O,
	    coin_pain: s.D_G, coin_gain: s.D_P,
	    cup_upper: s.H_L, cup_lower: s.H_U,
	    wand_upper: s.C_L, wand_lower: s.C_U};
  }
}

function read_major_arcana_string(c) {
  var card = c.card;
  var upright = c.upright;
  var t = setting.number_table[parseInt(card.substr(1), 10)];
  var s = {};
  for (var n in t) {
    s[n] = Math.ceil(t[n] * setting.rule_major_influence);
  }
  if (upright) {
    return "♠" + s.S_O + "/" + s.S_D + " ♦" + s.D_P + "|" + s.D_G + " ♥" + s.H_U + "∽" + s.H_L + " ♣" + s.C_U + "∽" + s.C_L;
  } else {
    return "♣" + s.C_L + "∽" + s.C_U + " ♥" + s.H_L + "∽" + s.H_U + " ♦" + s.D_G + "|" + s.D_P + " ♠" + s.S_D + "/" + s.S_O;

  }
}


function make_overlay_image(img) {
  var canvas = img;
  if (! img.getContext) {
    canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
  }
  var ctx = canvas.getContext('2d');
  var input;
  try {
    input = ctx.getImageData(0, 0, canvas.width, canvas.height);
  } catch (e) {
    fatal(L({ja: "エラー。ブラウザ開発者のポリシーが間借りブロガーにはキビしすぎます。彼らに robots.txt や sitemap.xml や .htaccess に似た回避策を用意していただきたいです。", en: "Error! Th policy of developers of your browser is too severe and is unavoidable for tenant bloggers.  I wish they should implement a method for avoidance like robots.txt or sitemap.xml or .htaccess ."}));
  }
  var output = ctx.createImageData(canvas.width, canvas.height);
  var tmp =output.data;
  for (var i = 0; i < input.data.length; i += 4) {
    if (input.data[i + 3] <= 255 * 0.1) {
      tmp[i + 0] = 0;
      tmp[i + 1] = 0;
      tmp[i + 2] = 0;
      tmp[i + 3] = 0;
    } else {
      tmp[i + 0] = 255 - 32 - 64;
      tmp[i + 1] = 255 - 32 - 64;
      tmp[i + 2] = 255 - 64 - 64;
      tmp[i + 3] = 64;
    }
  }
  var ocanvas = document.createElement('canvas');
  ocanvas.width = canvas.width;
  ocanvas.height = canvas.height;
  var octx = ocanvas.getContext('2d');

  // This rect shows only with failed putImageData.
  octx.beginPath();
  octx.rect(ocanvas.width - setting.card_width, 0,
	    setting.card_width, setting.card_height);
  octx.closePath();
  octx.fillStyle = "rgba(155, 187, 89, 0.7)";
  octx.fill();

  try {
    octx.putImageData(output, 0, 0);
  } catch (e) {
    fatal(L({ja: "エラー。ブラウザのバージョンを上げてみてください。", en: "Error! Try version up of your browser."}));
  }
  return ocanvas;
}

function calc_card_rect(card_name) {
  var s = card_name.substr(0, 1);
  var num = parseInt(card_name.substr(1), 10);
  var img = game_view.img_cards;
  if (s != "A" && s != "B") {
    num--;
  }
  var y = 0;
  switch (s) {
  case "A":
    y = 0;
    break;
  case "S":
    y = 1;
    break;
  case "D":
    y = 2;
    break;
  case "H":
    y = 3;
    break;
  case "C":
    y = 4;
    break;
  case "B":
    y = 0;
    img = game_view.img_backs;
    break;
  }
  return {x: num * setting.card_width, y: y * setting.card_height,
	  width: setting.card_width, height: setting.card_height,
	  img: img};
}

function calc_minor_rect (place, img) {
  var rect = {x: null, y: null, width: img.width, height: img.height};
  var anchor;

  switch (place) {
  case "swords_upper":
    anchor = game_view.anchor_swords_upper;
    rect.x = Math.floor(anchor.x - (img.width / 2));
    rect.y = Math.floor(anchor.y - (img.height / 2));
    if (rect.y < game_view.window_top) {
      rect.y = game_view.window_top;
    }
    break;
  case "coins_lower":
    anchor = game_view.anchor_coins_lower;
    rect.x = Math.floor(anchor.x - (img.width / 2));
    rect.y = Math.floor(anchor.y - (img.height / 2));
    if ((rect.y + img.height) > game_view.window_bottom) {
      rect.y = game_view.window_bottom - img.height;
    }
    break;
  case "coins_6":
    anchor = game_view.anchor_6;
    rect.x = Math.floor(anchor.x - (setting.card_width / 4) - img.width);
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- setting.card_height);
    if (rect.y < game_view.window_top) {
      rect.y = game_view.window_top;
    }
    break;
  case "coins_5":
    anchor = game_view.anchor_5;
    rect.x = Math.floor(anchor.x - (setting.card_width / 4) - img.width);
    rect.y = Math.floor(anchor.y - (setting.card_height / 4));
    break;
  case "coins_4":
    anchor = game_view.anchor_4;
    rect.x = Math.floor(anchor.x + (setting.card_width / 4));
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- setting.card_height);
    if (rect.y < game_view.window_top) {
      rect.y = game_view.window_top;
    }
    break;
  case "cups_3":
    anchor = game_view.anchor_3;
    rect.x = Math.floor(anchor.x + (setting.card_width / 4));
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- setting.card_height);
    if ((rect.y + img.height) > game_view.window_bottom) {
      rect.y = game_view.window_bottom - img.height;
    }
    break;
  case "cups_2":
    anchor = game_view.anchor_2;
    rect.x = Math.floor(anchor.x + (setting.card_width / 4));
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- img.height);
    break;
  case "cups_1":
    anchor = game_view.anchor_1;
    rect.x = Math.floor(anchor.x - (setting.card_width / 4) - img.width);
    rect.y = Math.floor(anchor.y + (setting.card_height / 4)
			- setting.card_height);
    if ((rect.y + img.height) > game_view.window_bottom) {
      rect.y = game_view.window_bottom - img.height;
    }
    break;
  }
  return rect;
}

function make_cards_image(cards) {
  var w = cards.length;
  if (w > 5) {
    w = 5;
  }
  w = Math.ceil(setting.card_width * (1 + (w - 1) * 1.0/5.0));
  var h = Math.ceil(cards.length / 5);
  h = Math.ceil(setting.card_height * (1 + (h - 1) * 1.0/6.0));
  var canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  var ctx = canvas.getContext('2d');
  for (var i = 0; i < cards.length; i++) {
    var c = cards[i];
    var x = i % 5;
    var y = Math.floor(i / 5);
    x = Math.floor(x * (setting.card_width / 5.0));
    y = Math.floor(y * (setting.card_height / 6.0));
    var rect = calc_card_rect(c);
    ctx.drawImage(rect.img,
		  rect.x, rect.y, setting.card_width, setting.card_height,
		  x, y, setting.card_width, setting.card_height);
  }
  return canvas;
}

function make_card_image(card, rotation) {
  var canvas = document.createElement('canvas');
  
  canvas.width = setting.card_width * Math.abs(Math.cos(rotation))
    + Math.abs(setting.card_height * Math.sin(rotation));
  canvas.height = Math.abs(setting.card_width * Math.sin(rotation))
    + Math.abs(setting.card_height * Math.cos(rotation));

//  alert(canvas.width + "x" + canvas.height);

  var d = Math.sqrt(setting.card_width * setting.card_width
		    + setting.card_height * setting.card_height);
  var dx, dy;
  if (Math.cos(rotation) >= 0 && Math.sin(rotation) <= 0) {
    dx = 0;
    dy = - setting.card_width * Math.sin(rotation);
  } else if (Math.cos(rotation) >= 0 && Math.sin(rotation) >= 0) {
    dx = canvas.width - setting.card_width * Math.cos(rotation);
    dy = 0;
  } else if (Math.cos(rotation) <= 0 && Math.sin(rotation) >= 0) {
    dx = canvas.width;
    dy = canvas.height - setting.card_width * Math.sin(rotation);
  } else {
    dx = - setting.card_width * Math.cos(rotation);
    dy = canvas.height;
  }

//  alert(dx + "x" + dy);

  var ctx = canvas.getContext('2d');
  var rect = calc_card_rect(card);
  ctx.transform(1, 0, 0, 1, dx, dy);
  ctx.rotate(rotation);
  ctx.drawImage(rect.img,
		rect.x, rect.y, setting.card_width, setting.card_height,
		0, 0,
		setting.card_width, setting.card_height);
  ctx.rotate(0);

  return canvas;
}

var game_view = {
  model_cur: {state: "title"},
  model_next: null,

  animation_info: {
    id: null,
    interval: 100,
    start_time: null,
    func: null
  },

  animation_temp: {}, // Temporary images for animation.

  controller_click_array: [],
  controller_move_array: [],

  debug_inited: false,

  lf: { // local functions
    _pop_animation : function () {
      var ainfo = game_view.animation_info;
      if (ainfo.id) {
	var time = (new Date).getTime() - ainfo.start_time;
	var r = ainfo.func(time);
	if (r) {
	  ainfo.id = window.setTimeout(game_view.lf._pop_animation,
				       ainfo.interval);
	}
      }
    },
    set_animation : function (func) {
      var ainfo = game_view.animation_info;
      if (ainfo.id) {
	window.clearTimeout(ainfo.id);
	ainfo.id = null;
      }
      if (func) {
	ainfo.start_time = (new Date).getTime();
	ainfo.func = func;
	ainfo.id = window.setTimeout(game_view.lf._pop_animation,
				     ainfo.interval);
      }
    },

    reset_animation : function () {
      game_view.lf.set_animation(null);
    },


    process_event : function (type, x, y) {
      var a = game_view.controller_move_array;
      if (type == "click") {
	a = game_view.controller_click_array;
      }
      for (var i = 0; i < a.length; i++) {
	var c = a[i];
	if (x >= c.x && x < c.x + c.width && y >= c.y && y < c.y + c.height) {
	  if (! c.func(type, x, y)) {
	    return;
	  }
	}
      }
    }
  },

  redraw : function () {
    if (game_view.model_next) {
      if (game_view.model_cur.finish) {
	game_view.model_cur.finish();
      }
      game_view.model_cur = game_view.model_next;
      game_view.model_next = null;
    }
    switch (game_view.model_cur.state) {
    case "title":
      game_view.draw_title();
      break;
    case "setting":
      game_view.draw_setting();
      break;
    case "game_init":
      game_view.draw_game_init();
      break;
    case "choose_token_place":
      game_view.draw_choose_token_place();
      break;
    case "wait_draw_card":
      game_view.draw_wait_draw_card();
      break;
    case "choose_move_or_stay":
      game_view.draw_choose_move_or_stay();
      break;
    case "choose_replacement":
      game_view.draw_choose_replacement();
      break;
    case "choose_replacement_card":
      game_view.draw_choose_replacement_card();
      break;
    case "choose_replacement_place":
      game_view.draw_choose_replacement_place();
      break;
    case "game_end":
      game_view.draw_game_end();
      break;
    case "game_end_0":
      game_view.draw_game_end_0();
      break;
    default:
      fatal("Illegal model state.");
    }
  },

  draw_title : function () {
    game_view.clear_all();

    game_view.debug_inited = false;

    var control_title = function (ev, x, y) {
      var rect = this.rect;
      var func = this.func;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);

      if (x && y
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	ctx.beginPath()
	ctx.rect(rect.x, rect.y, rect.width, rect.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.7)";
	ctx.fill();
	if (ev == "click") {
	  func();
	}
      }
      
      return false;
    }

    var x = Math.floor((setting.window_width - game_view.img_logo.width) / 2);
    var y = Math.floor(((setting.window_height / 2) - game_view.img_logo.height) / 2);
    if (y < 0) {
      y = 0;
    }
    var ctx = game_view.pane_board.getContext('2d');
    ctx.drawImage(game_view.img_logo, x, y);
    
    var text;
    var rect;
    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    var h = setting.dialog_window_height;
    var w;
    var func;

    x = Math.floor(setting.window_width / 2);
    y = Math.floor(setting.window_height / 2);

    y += h;
    text = L({ja: "はじめる", en: "Start"});
    w = ctx.measureText(text).width;
    rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y - h / 2),
	    width: w + 8 * 2, height: h};
    ctx.fillText(text, x, y);
    ctx.strokeText(text, x, y);
    func = function () {
      game_view.model_cur = {state: "game_init"};
      game_view.redraw();
    };
    game_view.controller_move_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});
    game_view.controller_click_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});

    y += h;
    var lang = [["日本語", "ja"], ["English", "en"]];
    w = 8;
    for (var i = 0; i < lang.length; i++) {
      if (i != 0) {
	w += 8 + ctx.measureText("/").width + 8;
      }
      w += ctx.measureText(lang[i][0]).width;
    }
    w += 8;
    
    x = Math.floor(x - w / 2) + 8;
    for (var i = 0; i < lang.length; i++) {
      if (i != 0) {
	x += 8;
	var sw = ctx.measureText("/").width;
	var sx = Math.floor(x + sw / 2);
	ctx.fillText("/", sx, y);
	ctx.strokeText("/", sx, y);
	x += sw + 8;
      }
      var lw = ctx.measureText(lang[i][0]).width;
      var l = lang[i][1];
      var lx = Math.floor(x + lw / 2);
      ctx.fillText(lang[i][0], lx, y);
      ctx.strokeText(lang[i][0], lx, y);
      rect = {x: Math.floor(lx - lw / 2) - 8, y: Math.floor(y - h / 2),
	      width: lw + 8 * 2, height: h};
      func = bind(function () {
	LANG = this.lang;
	game_view.draw_title();
      }, {lang: l});
      game_view.controller_move_array
	.push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	       func: bind(control_title, {rect: rect, func: func})});
      game_view.controller_click_array
	.push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	       func: bind(control_title, {rect: rect, func: func})});
      x += lw;
    }

    x = Math.floor(setting.window_width / 2);
    y += h;

    text = L({ja: "説明", en: "Help"});
    w = ctx.measureText(text).width;
    rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y - h / 2),
	    width: w + 8 * 2, height: h};
    ctx.fillText(text, x, y);
    ctx.strokeText(text, x, y);
    func = function () {
      location.href = setting.page_help;
    };
    game_view.controller_move_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});
    game_view.controller_click_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});

    y += h;
    text = L({ja: "設定", en: "Options"});
    w = ctx.measureText(text).width;
    rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y - h / 2),
	    width: w + 8 * 2, height: h};
    ctx.fillText(text, x, y);
    ctx.strokeText(text, x, y);
    func = function () {
      game_view.model_cur = {state: "setting"};
      game_view.redraw();
    };
    game_view.controller_move_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});
    game_view.controller_click_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_title, {rect: rect, func: func})});

    y += h;
    text = L({ja: "Version " + version(), en: "Version " + version()});
    w = ctx.measureText(text).width;
    rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y - h / 2),
	    width: w + 8 * 2, height: h};
    ctx.fillText(text, x, y);
    ctx.strokeText(text, x, y);

    // Clearing controller.
    rect = {x: 0, y: 0, width: setting.window_width,
	    height: setting.window_height};
    func = function () {
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      return true;
    }
    game_view.controller_move_array
      .push({x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: func});
  },

  draw_setting : function () {
    game_view.clear_all();
    game_view.setting_window.style.display = "block";
    
    var html_ja = '\
<form>\
<table>\
<tr><td>カード:</td><td><select id="cards">\
<option value="simplest">超シンプルなカード (1024x768)</option>\
<option value="jrf_tarot_small">JRF タロット (小, 1024x768)</option>\
<option value="jrf_tarot_medium">JRF タロット (中, 1280x1024)</option>\
<option value="jrf_tarot_small_dense">JRF タロット (小・密, 800x600)</option>\
<option value="jrf_tarot_medium_dense">JRF タロット (中・密, 1024x768)</option>\
<option value="jrf_tarot_large_dense">JRF タロット (大・密, 1280x1024)</option>\
</select></td></tr>\
<tr><td>終了カードの繰り返し:</td><td><input id="rule_terminals" type="text" /></td></tr>\
<tr><td>コートカード:</td><td><select id="rule_court_card">\
<option value="K14">K = 14, Q = 13, C = 12, J = 11</option>\
<option value="K13a">K = 13, Q = 12, C = 12, J = 11</option>\
<option value="K13b">K = 13, Q = 12, C = 11, J = 11</option>\
<option value="K10">K = 10, Q = 10, C = 10, J = 10</option>\
</select></td></tr>\
<tr><td>大アルカナの影響:</td><td><select id="rule_major_influence">\
<option value="3">3</option>\
<option value="2.5">2.5</option>\
<option value="2">2</option>\
<option value="1.5">1.5</option>\
<option value="1">1</option>\
</select></td></tr>\
<tr><td>(8)と(11)の置換:</td><td><select id="rule_swap_8_11">\
<option value="memorial">記念式 (簡略)</option>\
<option value="expansive">開式</option>\
<option value="solid">固式</option>\
</select></td></tr>\
<tr><td>戦乱置換:</td><td><select id="rule_replacement">\
<option value="0">しない</option>\
<option value="1">1</option>\
<option value="2">2</option>\
<option value="3">3</option>\
<option value="4">4</option>\
<option value="5">5</option>\
<option value="infinity">∞</option>\
</select></td></tr>\
<tr><td>戦乱置換の越境:</td><td><select id="rule_cross_border">\
<option value="none">なし</option>\
<option value="cups_and_coins">カップとコイン</option>\
<option value="all">すべて</option>\
</select></td></tr>\
<tr><td>↓♦への戦乱置換:</td><td><select id="rule_replacement_coins_lower">\
<option value="0">0</option>\
<option value="1">1</option>\
<option value="2">2</option>\
<option value="3">3</option>\
<option value="4">4</option>\
<option value="5">5</option>\
<option value="infinity">∞</option>\
</select></td></tr>\
<tr><td>計算時の暗転:</td><td><select id="calc_screen">\
<option value="true">する</option>\
<option value="false">しない</option>\
</select></td></tr>\
<tr><td>言語(Language):</td><td><select id="lang">\
<option value="ja">日本語</option>\
<option value="en">English</option>\
</select></td></tr>\
</table>\
\
<div id="set_button_container">\
<input id="set_button" type="button" value="設定" /> \
<input id="default_button" type="button" value="デフォルト" /> \
<input id="cancel_button" type="button" value="キャンセル" /> \
</div>\
</form>\
';

    var html_en = '\
<form>\
<table>\
<tr><td>Cards:</td><td><select id="cards">\
<option value="simplest">The simplest cards (1024x768)</option>\
<option value="jrf_tarot_small">The JRF Tarot (small, 1024x768)</option>\
<option value="jrf_tarot_medium">The JRF Tarot (medium, 1280x1024)</option>\
<option value="jrf_tarot_small_dense">The JRF Tarot (small dense, 800x600)</option>\
<option value="jrf_tarot_medium_dense">The JRF Tarot (medium dense, 1024x768)</option>\
<option value="jrf_tarot_large_dense">The JRF Tarot (large dense, 1280x1024)</option>\
</select></td></tr>\
<tr><td>Terminal Card Appears:</td><td><input id="rule_terminals" type="text" /></td></tr>\
<tr><td>Values of Court Cards:</td><td><select id="rule_court_card">\
<option value="K14">K = 14, Q = 13, C = 12, J = 11</option>\
<option value="K13a">K = 13, Q = 12, C = 12, J = 11</option>\
<option value="K13b">K = 13, Q = 12, C = 11, J = 11</option>\
<option value="K10">K = 10, Q = 10, C = 10, J = 10</option>\
</select></td></tr>\
<tr><td>Influence of the Major Arcana:</td><td><select id="rule_major_influence">\
<option value="3">3</option>\
<option value="2.5">2.5</option>\
<option value="2">2</option>\
<option value="1.5">1.5</option>\
<option value="1">1</option>\
</select></td></tr>\
<tr><td>Exchange of (VIII) and (XI):</td><td><select id="rule_swap_8_11">\
<option value="memorial">The Memorial Method (easy)</option>\
<option value="expansive">The Expansive Method</option>\
<option value="solid">The Solid Method</option>\
</select></td></tr>\
<tr><td>War Replacement:</td><td><select id="rule_replacement">\
<option value="0">None</option>\
<option value="1">1</option>\
<option value="2">2</option>\
<option value="3">3</option>\
<option value="5">5</option>\
<option value="infinity">∞</option>\
</select></td></tr>\
<tr><td>Cross-Boder in War Replacement:</td><td><select id="rule_cross_border">\
<option value="none">None</option>\
<option value="cups_and_coins">Cups and Coins</option>\
<option value="all">All</option>\
</select></td></tr>\
<tr><td>War Replacement to ↓♦:</td><td><select id="rule_replacement_coins_lower">\
<option value="0">0</option>\
<option value="1">1</option>\
<option value="2">2</option>\
<option value="3">3</option>\
<option value="5">5</option>\
<option value="infinity">∞</option>\
</select></td></tr>\
<tr><td>Darkening on calculation:</td><td><select id="calc_screen">\
<option value="true">Do it</option>\
<option value="false">Don\'t do it</option>\
</select></td></tr>\
<tr><td>Language:</td><td><select id="lang">\
<option value="ja">日本語 (Japanese)</option>\
<option value="en">English</option>\
</select></td></tr>\
</table>\
\
<div id="set_button_container">\
<input id="set_button" type="button" value="Set" /> \
<input id="default_button" type="button" value="Default" /> \
<input id="cancel_button" type="button" value="Cancel" /> \
</div>\
</form>\
';
    
    game_view.setting_window.innerHTML = L({ja: html_ja, en: html_en});

    var names = ["rule_terminals", 
		 "rule_court_card",
		 "rule_major_influence",
		 "rule_swap_8_11",
		 "rule_replacement",
		 "rule_cross_border",
		 "rule_replacement_coins_lower",
		 "calc_screen",
		 "cards",
		 "lang"];

    for (var i = 0; i < names.length; i++) {
      var n = names[i];
      var elt = document.getElementById(n);
      elt.value = setting[n];
    }

    var set_cookies = function () {
      for (var i = 0; i < names.length; i++) {
	var n = names[i];
	var elt = document.getElementById(n);
	var v = elt.value;
	if (v.match(/^[01-9]+$/)) {
	  v = parseInt(v, 10);
	} else if (v.match(/^-?[01-9]+\.[01-9]+$/)) {
	  v = parseFloat(v);
	} else if (v.match(/^true$/)) {
	  v = true;
	} else if (v.match(/^false$/)) {
	  v = false;
	}
	setting[n] = v;
	if (setting_default[n] == v) {
	  v = null;
	}
	set_cookie(n, v);
      }
      LANG = setting.lang;

      if (setting.cards != current_cards) {
	for (var n in cards_simplest) {
	  setting[n] = cards_simplest[n];
	}

	if (window["cards_" + setting.cards] != null
	    && setting.cards != 'simplest') {
	  var cs = window["cards_" + setting.cards];
	  for (var n in cs) {
	    setting[n] = cs[n];
	  }
	}
      }

      game_view.model_cur = {state: "title"};
      
      reload_images(bind(game_view.redraw, game_view));
    };

    var reset_to_default = function () {
      for (var i = 0; i < names.length; i++) {
	var n = names[i];
	var elt = document.getElementById(n);
	elt.value = setting_default[n];
      }
    };

    var cancel = function () {
      game_view.model_cur = {state: "title"};
      game_view.redraw();
    };

    document.getElementById("set_button")
      .addEventListener("click", set_cookies, false);
    document.getElementById("default_button")
      .addEventListener("click", reset_to_default, false);
    document.getElementById("cancel_button")
      .addEventListener("click", cancel, false);
  },

  draw_game_init : function () {
    game_view.clear_all();
    game_view.status_window.style.display = "block";
    game_view.status_window.innerHTML = "";
    
    var cur = {
      state: "game_init",
      purpose: null,
      purpose_degree: null,
      board: [],
      talon: [],
      discarded: [],
      token: null,
      swords_upper: [],
      coins_lower: [],
      coins_6: [],
      coins_5: [],
      coins_4: [],
      cups_3: [],
      cups_2: [],
      cups_1: [],
      drawn_terminals: 0,

      replacements: 0,
      replacements_coins_lower: 0,
      chosen_card: null,
      chosen_place: null,

      finish: null
    };
    game_view.model_cur = cur;

    var major = [];
    for (var i = 0; i < 22; i++) {
      if (i != 0 && i != 13) {
	major.push("A" + pad_left(i, 2, "0"));
      }
    }
    major = shuffle_array(major);
    for (var i = 0; i < 6; i++) {
      var x = Math.floor(Math.random() * major.length);
      var upright = Math.floor(Math.random() * 2);
      cur.board.push({card: major[x], upright: (upright == 0)});
      major.splice(x, 1);
    }

    for (var i = 0, l = ["S", "D", "H", "C"]; i < l.length; i++) {
      for (var j = 1; j < 15; j++) {
	cur.talon.push(l[i] + pad_left(j, 2, "0"));
      }
    }

    //for debug
    if (false) {
      cur.board =
	[
	  {card: "A01", upright: false},
	  {card: "A02", upright: false},
	  {card: "A03", upright: false},
	  {card: "A04", upright: false},
	  {card: "A07", upright: false},
	  {card: "A11", upright: false}
	];
    }

    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "choose_token_place";

    var bits = 0;
    var simul = 0;
    for (var i = 0; i< cur.board.length; i++) {
      var num = parseInt(cur.board[i].card.substr(1), 10);
      if (num % 2 == 1) {
	bits++;
      }
      if (num == 8 || num == 11) {
	simul++;
      }
    }

    next.board = [];
    for (var i = 0; i < cur.board.length; i++) {
      next.board[i] = cur.board[i];
      if ((setting.rule_swap_8_11 == "memorial")
	  || (setting.rule_swap_8_11 == "expansive"
	      && (bits > 3 || simul == 2
		  || (bits == 3 && cur.board[i].upright)))
	  || (setting.rule_swap_8_11 == "solid"
	      && bits >= 2 && bits <= 4)) {
	if (cur.board[i].card == "A08") {
	  next.board[i] = {card: "A11", upright: cur.board[i].upright};
	}
      }
      if ((setting.rule_swap_8_11 == "memorial")
	  || (setting.rule_swap_8_11 == "expansive"
	      && (bits < 3 || simul == 2
		  || (bits == 3 && cur.board[i].upright)))
	  || (setting.rule_swap_8_11 == "solid"
	      && bits >= 2 && bits <= 4)) {
	if (cur.board[i].card == "A11") {
	  next.board[i] = {card: "A08", upright: cur.board[i].upright};
	}
      }
    }

    var nbits = 0;
    var whirl = 0;
    var eclipse = 0;
    for (var i = 0; i< next.board.length; i++) {
      var num = parseInt(next.board[i].card.substr(1), 10);
      var upright = next.board[i].upright;
      if (num % 2 == 1) {
	nbits++;
      }
      if (num % 2 == 1) {
	if (upright) {
	  eclipse++;
	}
      } else {
	if (! upright) {
	  eclipse++;
	}
      }
      if (upright) {
	whirl++;
      }
    }

    if (setting.rule_swap_8_11 == "solid" && nbits == 3) {
      if (whirl == 0) {
	next.purpose = "A13";
	next.purpose_degree = "whirl";
      }
      if (whirl == 6) {
	next.purpose = "A00";
	next.purpose_degree = "whirl";
      }
      if (eclipse == 0) {
	next.purpose = "A13";
	next.purpose_degree = "eclipse";
      }
      if (eclipse == 6) {
	next.purpose = "A00";
	next.purpose_degree = "eclipse";
      }
    }

    var c = {x: 0, y: 0,
	     width: setting.window_width, height: setting.window_height,
	     func: function () {
	       game_view.lf.reset_animation();
	       game_view.redraw();
	     }
	    };
    game_view.controller_click_array.push(c);

    game_view.animation_temp = {prev_past: 0};
    game_view.lf.set_animation(game_view.animate_game_init);
  },

  animate_game_init :function (time) {
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var cur = game_view.model_cur;
    var next = game_view.model_next;
    var past = 0;
    var scene;
    
    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja:"大アルカナから " + L(setting.card_name[0]) + " と " + L(setting.card_name[13]) + " を抜きます。", en: "Sort out " + L(setting.card_name[0]) + " and " + L(setting.card_name[13]) + " from major arcana."});
      var img = make_cards_image(["A13", "A00"]);
      var anchor = game_view.anchor_purpose;
      var end = {x: anchor.x, y: anchor.y};
      var begin = {x: game_view.anchor_5.x, y: 0};
      if (Math.floor(end.x - img.width / 2) < game_view.window_left) {
	end.x = Math.floor(game_view.window_left + img.width / 2);
      }

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }

    past += scene;
    if (temp.prev_past <= past) {
      var img = make_cards_image(["A13", "A00"]);
      var anchor = game_view.anchor_purpose;
      var end = {x: anchor.x, y: anchor.y};
      end.x = Math.floor(end.x - img.width / 2);
      end.y = Math.floor(end.y - img.height / 2);
      if (end.x < game_view.window_left) {
	end.x = game_view.window_left;
      }
      var ctx2 = game_view.pane_board.getContext('2d');
      ctx2.drawImage(img, end.x, end.y);
    }

    scene = 500 * 6;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja:"大アルカナで盤を作ります。", en:"Make a game board from major arcana."});
      var num = Math.floor((time - past) / 500);
      var img = make_card_image("B0", 0);
      for (var i = 0; i < num; i++) {
	var anchor = game_view["anchor_" + (i + 1)];
	ctx.drawImage(img,
		      Math.floor(anchor.x - img.width / 2),
		      Math.floor(anchor.y - img.height / 2));
      }
      if (num < 6) {
	var end = game_view["anchor_" + (num + 1)];
	var begin = {x: 0, y: game_view.anchor_purpose.y};
	var r = (time - past - num * 500) / 500;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
      }

      temp.prev_past = time;
      return true;
    }

    past += scene;
    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_board.getContext('2d');
      for (var i = 0; i < 6; i++) {
	var anchor = game_view["anchor_" + (i + 1)];
	var c = cur.board[i];
	var rotation = 0;
	if (! c.upright) {
	  rotation = Math.PI;
	}
	var img = make_card_image(c.card, rotation);
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx2.drawImage(img, x, y);
      }
    }

    scene = 500 * 6;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja:"大アルカナで盤を作ります。", en:"Make a game board by major arcana."});
      var num = Math.floor((time - past) / 500);
      var img = make_card_image("B0", 0);
      for (var i = num + 1; i < 6; i++) {
	var anchor = game_view["anchor_" + (i + 1)];
	ctx.drawImage(img,
		      Math.floor(anchor.x - img.width / 2),
		      Math.floor(anchor.y - img.height / 2));
      }
      if (num < 6) {
	var r = Math.floor(((time - past - 500 * num) / 500) * 5);
	var img2 = make_card_image("B" + r, 0);
	var anchor2 = game_view["anchor_" + (num + 1)];
	var x = Math.floor(anchor2.x - img2.width / 2);
	var y = Math.floor(anchor2.y - img2.height / 2);
	ctx.drawImage(img2, x, y);
      }
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    var change = false;
    var a08;
    var a08rot = 0;
    var a11;
    var a11rot = 0;
    for (var i = 0; i < 6; i++) {
      var c = cur.board[i].card;
      var upright = cur.board[i].upright;
      if (c == "A08") {
	a08 = i;
	if (! upright) {
	  a08rot = Math.PI;
	}
	if (next.board[i].card != "A08") {
	  change = true;
	}
      }
      if (c == "A11") {
	a11 = i;
	if (! upright) {
	  a11rot = Math.PI;
	}
	if (next.board[i].card != "A11") {
	  change = true;
	}
      }
    }

    var bits = 0;
    var odds = "";
    var simul = 0;
    for (var i = 0; i< cur.board.length; i++) {
      var num = parseInt(cur.board[i].card.substr(1), 10);
      if (num % 2 == 1) {
	bits++;
	if (odds != "") {
	  odds += ", ";
	}
	odds += "(" + num + ")";
      }
      if (num == 8 || num == 11) {
	simul++;
      }
    }
    var nbits = 0;
    var nodds = "";
    var whirl = 0;
    var eclipse = 0;
    for (var i = 0; i< next.board.length; i++) {
      var num = parseInt(next.board[i].card.substr(1), 10);
      var upright = next.board[i].upright;
      if (num % 2 == 1) {
	nbits++;
	if (nodds != "") {
	  nodds += ", ";
	}
	nodds += "(" + num + ")";
      }
      if (num % 2 == 1) {
	if (upright) {
	  eclipse++;
	}
      } else {
	if (! upright) {
	  eclipse++;
	}
      }
      if (upright) {
	whirl++;
      }
    }

    var com;
    if (setting.rule_swap_8_11 == "expansive") {
      if (simul == 2) {
	com = L({ja: L(setting.card_name[8]) + " と " + L(setting.card_name[11]) + " が同時に出たので入れ替える必要があります。", en:"You need to swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + ", because they appeared together."});
      } else if (bits > 3) {
	com = L({ja:"奇数カードが " + bits + " (&gt;3) 枚出ています。" + L(setting.card_name[8]) + " が出ていれば入れ替える必要があります。", en:"Odd number cards are " + bits + " (&gt;3) cards.  You need to swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + " if " + L(setting.card_name[8]) + " appeared."});
      } else if (bits < 3) {
	com = L({ja:"奇数カードが " + bits + " (&lt;3) 枚出ています。" + L(setting.card_name[11]) + " が出ていれば入れ替える必要があります。", en:"Odd number cards are " + bits + " (&lt;3) cards.  You need to swap " + L(setting.card_name[11]) + " and " + L(setting.card_name[8]) + " if " + L(setting.card_name[11]) + " appeared."});
      } else if (bits == 3) {
	com = L({ja:"奇数カードが 3 枚出ています。" + L(setting.card_name[8]) + " か " + L(setting.card_name[11]) + " が正位置ならば入れ替える必要があります。", en:"Odd number cards are 3 cards.  You need to swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + " if one of them is upright."});
      }
    } else if (setting.rule_swap_8_11 == "solid") {
      if (bits >= 2 && bits <= 4) {
	com = L({ja:"奇数カードが " + bits + " (&gt;=2,&lt;=4)枚出ています。" + L(setting.card_name[8]) + " と " + L(setting.card_name[11]) + " を入れ替える必要があります。", en:"Odd number cards are " + bits + " (&gt;=2,&lt;=4) cards.  You need to swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + "."});
      }
    }
    if (com) {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = com;
	temp.prev_past = time;
	return true;
      }
      past += scene;
    }

    if (change) {
      scene = 3000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja:"タロットの歴史を記念し、" + L(setting.card_name[8]) + " と " + L(setting.card_name[11]) + " を入れ替えます。", en:"Swap " + L(setting.card_name[8]) + " and " + L(setting.card_name[11]) + " after memory of the history of tarot."});
	var ctx2 = game_view.pane_board.getContext('2d');

	var anchor;
	var begin;
	var end;
	var r = (time - past) / scene;

	if (a08 != null) {
	  anchor = game_view["anchor_" + (a08 + 1)];
	  ctx2.clearRect(Math.floor(anchor.x - setting.card_width / 2),
			 Math.floor(anchor.y - setting.card_height / 2),
			 setting.card_width,
			 setting.card_height);
	  begin = {x: anchor.x, y: anchor.y, rot: a08rot};
	} else {
	  begin = {x: 0, y: game_view.anchor_purpose.y, rot: 0};
	}
	if (a11 != null) {
	  anchor = game_view["anchor_" + (a11 + 1)];
	  end = {x: anchor.x, y: anchor.y, rot:a11rot};
	} else {
	  end = {x: 0, y: game_view.anchor_purpose.y, rot: 0};
	}
	if (1) {
	  var img = make_card_image("A08",
				    begin.rot + (end.rot - begin.rot) * r);
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	if (a11 != null) {
	  anchor = game_view["anchor_" + (a11 + 1)];
	  ctx2.clearRect(Math.floor(anchor.x - setting.card_width / 2),
			 Math.floor(anchor.y - setting.card_height / 2),
			 setting.card_width,
			 setting.card_height);
	  begin = {x: anchor.x, y: anchor.y, rot: a11rot};
	} else {
	  begin = {x: 0, y: game_view.anchor_purpose.y, rot: 0};
	}
	if (a08 != null) {
	  anchor = game_view["anchor_" + (a08 + 1)];
	  end = {x: anchor.x, y: anchor.y, rot:a08rot};
	} else {
	  end = {x: 0, y: game_view.anchor_purpose.y, rot: 0};
	}
	if (1) {
	  var img = make_card_image("A11",
				    begin.rot + (end.rot - begin.rot) * r);
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    }

    if (setting.rule_swap_8_11 == "solid" && nbits == 3) {
      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_board.getContext('2d');
	for (var i = 0; i < 6; i++) {
	  var anchor = game_view["anchor_" + (i + 1)];
	  var c = next.board[i];
	  var rotation = 0;
	  if (! c.upright) {
	  rotation = Math.PI;
	  }
	  var img = make_card_image(c.card, rotation);
	  var x = Math.floor(anchor.x - img.width / 2);
	  var y = Math.floor(anchor.y - img.height / 2);
	  ctx2.clearRect(x, y, img.width, img.height);
	  ctx2.drawImage(img, x, y);
	}
      }
	
      scene = 1000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja:"奇数カードが 3 枚なので、スピンを調べます。", en:"Odd number cards are 3 cards.  Investigate spins."});
	temp.prev_past = time;
	return true;
      }
      past += scene;

      var com;
      if (whirl == 0) {
	com = L({ja:"「<em>旋坤</em>」。すべてのカードが逆位置です。", en:"<em>\"Field Whirl\"</em>.  All cards are reversal."});
      } else if (whirl == 6) {
	com = L({ja:"「<em>旋乾</em>」。すべてのカードが正位置です。", en:"<em>\"Force Whirl\"</em>.  All cards are upright."});
      } else if (eclipse == 0) {
	com = L({ja:"「<em>重坤</em>」。すべてのカードの偶奇とスピンが逆になっています。", en:"<em>\"Field Eclipse\"</em>.  The parity of all cards reversally meets their spin."});
      } else if (eclipse == 6) {
	com = L({ja:"「<em>重乾</em>」。すべてのカードの偶奇とスピンが合っています。", en:"<em>\"Force Eclipse\"</em>.  The parity of all cards meets their spin."});
      } else {
	com = L({ja:"奇数カードが 3 枚なので、スピンを調べます。<br/>→ 特に何もありません。", en:"Odd number cards are 3 cards.  Investigate spins.<br/>→ Nothing special."});
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = com;
	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
	
    game_view.redraw();
    return false;
  },

  draw_choose_token_place : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    var cur = game_view.model_cur;
    game_view.model_next = null;

    game_view.draw_board();

    if (cur.purpose == null) {
      cur.token = Math.floor(Math.random() * 6);
    } else if (cur.purpose == "A00") {
      cur.token = Math.floor(Math.random() * 3);
    } else if (cur.purpose == "A13") {
      cur.token = 3 + Math.floor(Math.random() * 3);
    }

    var restriction = "";
    var hexagram;
    if (cur.purpose_degree) {
      var r;
      if (cur.purpose_degree == "whirl" && cur.purpose == "A00") {
	hexagram = L({ja: "旋乾", en: "旋乾 Force Whirl"});
	r = L({ja: "下卦", en: "lower trigram"});
      } else if (cur.purpose_degree == "whirl" && cur.purpose == "A13") {
	hexagram = L({ja: "旋坤", en: "旋坤 Field Whirl"});
	r = L({ja: "上卦", en: "upper trigram"});
      } else if (cur.purpose_degree == "eclipse" && cur.purpose == "A00") {
	hexagram = L({ja: "重乾", en: "重乾 Force Eclipse"});
	r = L({ja: "下卦", en: "lower trigram"});
      } else if (cur.purpose_degree == "eclipse" && cur.purpose == "A13") {
	hexagram = L({ja: "重坤", en: "重坤 Field Eclipse"});
	r = L({ja: "上卦", en: "upper trigram"});
      }
      restriction = L({ja: "<br/>ただし、「" + hexagram + "」のため" + r + "にしか置けません。", en: "<br/>But \"" + hexagram + "\" restricts you onto " + r + "."});
    }

    if (hexagram == null) {
      var n = 0;
      for (var i = 0; i < 6; i++) {
	if (parseInt(cur.board[i].card.substr(1), 10) % 2) {
	  n += (1 << i);
	}
      }
      hexagram = L(HEXAGRAM[n]);
    }

    if (1) {
      var ctx = game_view.pane_control.getContext('2d');
      var img = game_view.img_token;
      var anchor = game_view["anchor_" + (game_view.model_cur.token + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
    }
    
    var control_token = function (ev, x, y) {
      var rect = this.rect;
      var place = this.place;
      var status = this.status;

      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	if (place != null) {
	  var ctx = game_view.pane_control.getContext('2d');
	  ctx.clearRect(0, 0, setting.window_width, setting.window_height);

	  game_view.model_cur.token = place;

	  var img = game_view.img_token;
	  var anchor = game_view["anchor_" + (game_view.model_cur.token + 1)];
	  var x1 = Math.floor(anchor.x - img.width / 2);
	  var y1 = Math.floor(anchor.y - img.height / 2);
	  ctx.drawImage(img, x1, y1);
	}
      }
      game_view.status_window.innerHTML = status;

      if (ev == "click") {
	if (typeof(setting.rule_terminals) != "number"
	    || setting.rule_terminals == 0) {
	  game_view.draw_game_end_0();
	} else {
	  game_view.chose_token_place();
	}
      }
    }

    if (true) {
      var anchor = game_view.anchor_purpose;
      var w = setting.card_height;
      var h = setting.card_height;
      var s;
      if (cur.purpose_degree) {
	h = setting.card_width;
	var s = L({ja: L(setting.card_name[parseInt(cur.purpose.substr(1), 10)]) + "。<br/>偶奇とスピンによる易の卦は「" + hexagram + "」です。", en:  L(setting.card_name[parseInt(cur.purpose.substr(1), 10)]) + ".<br/>Hexagram by parities and spins is \"" + hexagram + "\"."});
      } else {
	var s = L({ja: L(setting.card_name[13]) + " と " + L(setting.card_name[0]) + "。<br/>偶奇による易の卦は「" + hexagram + "」です。", en:  L(setting.card_name[13]) + " and " + L(setting.card_name[0]) + ".<br/>Hexagram by parities is \"" + hexagram + "\"."});

      }

      var x = Math.floor(anchor.x - w / 2);
      if (x < game_view.window_left) {
	x = game_view.window_left;
      }
      var y = Math.floor(anchor.y - h / 2);
      var c = {x: x, y: y, width: w, height: h,
	       func: bind(control_token,
			  {rect: {x: x, y: y, width: w, height: h},
			   status: s,
			   place: null})};
      game_view.controller_move_array.push(c);
    }

    for (var i = 0; i < 6; i++) {
      var anchor = game_view["anchor_" + (i + 1)];
      var card_num = parseInt(cur.board[i].card.substr(1), 10);
      var card_reversed = "";
      if (! cur.board[i].upright) {
	card_reversed = L({ja: " (逆)", en: " (reversed)"});
      }

      var x = Math.floor(anchor.x - setting.card_width / 2);
      var y = Math.floor(anchor.y - setting.card_height / 2);
      var s =L(setting.card_name[card_num]) + card_reversed + "<br/>" + read_major_arcana_string(cur.board[i]);
      var p = i;
      if (cur.purpose) {
	if ((cur.purpose == "A00" && i >= 3)
	    || (cur.purpose == "A13" && i < 3)) {
	  p = null;
	}
      }

      var c = {x: x, y: y, width: setting.card_width,
	       height: setting.card_height,
	       func: bind(control_token,
			  {rect: {x: x, y: y, width: setting.card_width,
				  height: setting.card_height},
			   status: s,
			   place: p})};

      if (p != null) {
	game_view.controller_click_array.push(c);
      }
      game_view.controller_move_array.push(c);
    }

    if (true) {
      var w = setting.window_width;
      var h = setting.window_height;
      var s = L({ja: "はじめに好きなところにトークンを置いてください。", en: "Please place the token, at first."}) + restriction;
      var c = {x: 0, y: 0, width: w, height: h,
	       func: bind(control_token,
			  {rect: {x: 0, y: 0, width: w, height: h},
			   status: s,
			   place: null})};
      game_view.controller_move_array.push(c);

      game_view.status_window.innerHTML = s;
    }
  },

  chose_token_place : function () {
    game_view.clear_animation();
    var cur = game_view.model_cur;
    if (cur.token < 3) {
      cur.purpose = "A00";
      cur.talon.push("A13");
    } else {
      cur.purpose = "A13";
      cur.talon.push("A00");
    }
    cur.talon = shuffle_array(cur.talon);

    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "wait_draw_card";
    cur.finish = function () {
      game_view.draw_board();
    }
    
    var c = {x: 0, y: 0,
	     width: setting.window_width, height: setting.window_height,
	     func: function () {
	       game_view.lf.reset_animation();
	       game_view.redraw();
	     }
	    };
    game_view.controller_click_array = [c];
    game_view.controller_move_array = [];

    game_view.animation_temp = {prev_past: 0};
    game_view.lf.set_animation(game_view.animate_chose_token_place);
  },

  animate_chose_token_place : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      game_view.draw_screen();
      game_view.draw_board();
    }

    var terminal;
    if (cur.purpose == "A13") {
      terminal = "A00";
    } else {
      terminal = "A13";
    }

    scene = 5000;
    if (time <= past + scene) {
      var c;
      if (terminal == "A00") {
	game_view.status_window.innerHTML = L({ja: "上卦にトークンが置かれたので、「終了カード」として " + L(setting.card_name[0]) + " を小アルカナの山に挿し入れ、シャッフルします。<br/>これが " + setting.rule_terminals + " 度目に引かれたときがゲーム終了です。", en: "Insert " + L(setting.card_name[0]) + " into the talon of minor arcana and shuffle, because you placed the token on upper trigram.<br/>The game is over if this \"terminal card\" appears " + setting.rule_terminals + " times."});
      } else {
	game_view.status_window.innerHTML = L({ja: "下卦にトークンが置かれたので、終了カードとして " + L(setting.card_name[13]) + " を小アルカナの山に挿し入れ、シャッフルします。<br/>これが " + setting.rule_terminals + " 度目に引かれたときがゲーム終了です。", en: "Insert " + L(setting.card_name[13]) + " into the talon of minor arcana and shuffle, because you placed the token on lower trigram.<br/>The game is over if this \"terminal card\" appears " + setting.rule_terminals + " times."});
      }
      var img = make_card_image(terminal, 0);
      var begin = game_view.anchor_purpose;
      var end = game_view.anchor_talon;

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;
    
    scene = 3000;
    if (time <= past + scene) {
      var img1, img2;
      var anchor1, anchor2;
      if (terminal== "A00") {
	game_view.status_window.innerHTML = L({ja: "終了時、上爻か五爻にトークンがあれば、あなたの勝ちです。", en: "You win at the end if the token places in the top or in the fifth."});
	img1 = make_card_image(cur.board[5].card, 
			       (cur.board[5].upright)? 0 : Math.PI);
	img2 = make_card_image(cur.board[4].card, 
			       (cur.board[4].upright)? 0 : Math.PI);
	anchor1 = game_view.anchor_6;
	anchor2 = game_view.anchor_5;
      } else {
	game_view.status_window.innerHTML = L({ja: "終了時、二爻か五爻にトークンがあれば、あなたの勝ちです。", en: "You win at the end if the token places in the second or in the fifth."});
	img1 = make_card_image(cur.board[1].card, 
			       (cur.board[1].upright)? 0 : Math.PI);
	img2 = make_card_image(cur.board[4].card, 
			       (cur.board[4].upright)? 0 : Math.PI);
	anchor1 = game_view.anchor_2;
	anchor2 = game_view.anchor_5;
      }
      var img3 = game_view.img_token;
      var anchor3 = game_view["anchor_" + (cur.token + 1)];
      ctx.drawImage(img1, Math.floor(anchor1.x - img1.width / 2),
		    Math.floor(anchor1.y - img1.height / 2));
      ctx.drawImage(img2, Math.floor(anchor2.x - img2.width / 2),
		    Math.floor(anchor2.y - img2.height / 2));
      ctx.drawImage(img3, Math.floor(anchor3.x - img3.width / 2),
		    Math.floor(anchor3.y - img3.height / 2));
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    game_view.redraw();
    return false;
  },

  draw_wait_draw_card : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (false) {
      if (! game_view.debug_inited) {
	cur.talon = ["S14", "A13"];
	cur.swords_upper = ["S01", "S02", "S03"];
	cur.coins_lower = ["D01", "D02", "D03", "D14", "D13", "D12"];
	cur.coins_6 = ["D04", "D05", "D06"];
	cur.coins_5 = ["D07", "D08", "D09"];
	cur.coins_4 = ["D10", "D11"];
	cur.cups_3 = ["H14", "H13", "H12", "H11", "H10"];
	cur.cups_2 = ["H09", "H08", "H07", "H06", "H05"];
	cur.cups_1 = ["H04", "H03", "H02", "H01"];

	game_view.debug_inited = true;
      }
    }

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();


    var control_draw_card = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	var img = game_view.img_hilit_talon;
	var anchor = game_view.anchor_talon;
	var x1 = Math.floor(anchor.x - img.width / 2);
	var y1 = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x1, y1);
      }
      if (ev == "click") {
	game_view.drew_card();
      }
    }

    if (1) {
      var img = game_view.img_hilit_talon;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      var c = {x: x, y: y, width: img.width, height: img.height,
	       func: bind(control_draw_card,
			  {rect: {x: x, y: y, width: img.width,
				  height: img.height}})};
      game_view.controller_click_array.push(c);
      game_view.controller_move_array.push(c);
    }
    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }

    game_view.status_window.innerHTML = L({ja: "カードを引いてください。", en: "Please draw a card."});
  },

  drew_card : function () {
    game_view.clear_animation();

    var cur = game_view.model_cur;
    cur.drawn = cur.talon.shift();
//    cur.drawn = "C05"; // for debug.
//    cur.cups_1 = ["H01", "H08"];

    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "wait_draw_card";
    next.drawn = null;

    var suit = cur.drawn.substr(0, 1);
    var score = calc_card_score(cur.drawn);
    var animate;

    if (suit == "A") {
      next.drawn_terminals++;
      if (next.drawn_terminals < setting.rule_terminals) {
	next.talon = shuffle_array(cur.talon.concat([cur.drawn], cur.discarded));
	next.discarded = [];
	animate = game_view.animate_shuffle;
	cur.finish = function () {
	  game_view.draw_board();
	};
      } else {
	next.state = "game_end";
	if ((cur.purpose == "A13" && (cur.token == 5 || cur.token == 4))
	    || (cur.purpose == "A00" && (cur.token == 1 || cur.token == 4))) {
	  next.win_or_lose = "win";
	} else {
	  next.win_or_lose = "lose";
	}
	animate = game_view.animate_game_end;
      }
    } else if (cur.token >= 3) {
      switch (suit) {
      case "S":
	var right = cur.token - 1;
	var left = (cur.token + 1) % 6;

	var max = null;
	var max_score = 0;
	for (var i = 0, l = cur["coins_" + (cur.token + 1)];
	     i < l.length; i++) {
	  var m = calc_card_score(l[i]);
	  if (m > max_score) {
	    max = i;
	    max_score = m;
	  }
	}
	
	var ma_r_score = read_major_arcana(cur.board[right]);
	if (max_score + ma_r_score.sword_defence
	    >  score + ma_r_score.coin_pain) {
	  cur.move_or_stay = "move";
	  next["swords_upper"]
	    = cur["swords_upper"].concat([cur.drawn]);
	  next.token = right;
	} else {
	  cur.move_or_stay = "stay";
	  next.discarded = cur.discarded.concat([cur.drawn]);
	  if (max != null) {
	    var card = cur["coins_" + (cur.token + 1)][max];
	    next["coins_" + (cur.token + 1)]
	      = [].concat(cur["coins_" + (cur.token + 1)]);
	    next["coins_" + (cur.token + 1)].splice(max, 1);
	    var coins = "coins_lower";
	    if (left != 0) {
	      coins = "coins_" + (left + 1);
	    }
	    next[coins] = cur[coins].concat([card]);
	  }
	}

	animate = game_view.animate_upper_sword;
	break;

      case "D":
	cur.move_or_stay = "stay";
	next["coins_" + (cur.token + 1)]
	  = cur["coins_" + (cur.token + 1)].concat([cur.drawn]);
	animate = game_view.animate_upper_coin;
	break;

      case "H":
	var left = (cur.token + 1) % 6;
	var lower = cur.token - 3;

	var ma_score = read_major_arcana(cur.board[cur.token]);
	var ma_l_score = read_major_arcana(cur.board[left]);

	if (score + ma_score.cup_upper > ma_l_score.wand_upper) {
	  cur.move_or_stay = "move";
	  next.token = left;
	} else {
	  cur.move_or_stay = "stay";
	}
	next["cups_" + (lower + 1)] = cur["cups_" + (lower + 1)]
	  .concat([cur.drawn]);

	animate = game_view.animate_upper_cup;
	break;

      case "C":
	var lower = cur.token - 3;

	var ma_score = read_major_arcana(cur.board[cur.token]);
	var ma_l_score = read_major_arcana(cur.board[lower]);

	var max = null;
	var max_score = 0;
	for (var i = 0; i < cur["cups_" + (lower + 1)].length; i++) {
	  var sc = calc_card_score(cur["cups_" + (lower + 1)][i]);
	  if (sc > max_score) {
	    max = i;
	    max_score = sc;
	  }
	}

	var max_c = null;
	var max_c_score = 0;
	var sum_c = 0;
	for (var i = 0; i < cur["coins_" + (cur.token + 1)].length; i++) {
	  var sc = calc_card_score(cur["coins_" + (cur.token + 1)][i]);
	  sum_c += sc;
	  if (sc > max_c_score) {
	    max_c = i;
	    max_c_score = sc;
	  }
	}

	if (max != null
	    && (score + ma_score.wand_upper + max_score + ma_l_score.cup_lower
		> sum_c + ma_score.coin_gain)) {
	  cur.move_or_stay = "move";
	  next.token = lower;
	  next.discarded 
	    = cur.discarded.concat([cur.drawn,
				    cur["cups_" + (lower + 1)][max]]);
	  next["cups_" + (lower + 1)]
	    = [].concat(cur["cups_" + (lower + 1)]);
	  next["cups_" + (lower + 1)].splice(max, 1);
	} else {
	  cur.move_or_stay = "stay";
	  next.discarded
	    = cur.discarded.concat([cur.drawn]);
	  if (max_c != null) {
	    next.coins_lower
	      = cur.coins_lower.concat(cur["coins_" + (cur.token + 1)][max_c]);
	    next["coins_" + (cur.token + 1)] 
	      = [].concat(next["coins_" + (cur.token + 1)]);
	    next["coins_" + (cur.token + 1)].splice(max_c, 1);
	  }
	}

	animate = game_view.animate_upper_wand;
	break;
      }
    } else {
      switch (suit) {
      case "S":
	var upper = cur.token + 3;

	var sum_su = 0;
	var sum_cl = 0;
	var sum_cu = 0;

	for (var i = 0, l = cur.swords_upper; i < l.length; i++) {
	  sum_su += calc_card_score(l[i]);
	}
	for (var i = 0, l = cur.coins_lower; i < l.length; i++) {
	  sum_cl += calc_card_score(l[i]);
	}
	for (var i = 0, l = cur["coins_" + (upper + 1)];
	     i < l.length; i++) {
	  sum_cu += calc_card_score(l[i]);
	}

	var max = null;
	var max_score = 0;
	for (var i = 0, l = cur["cups_" + (cur.token + 1)];
	     i < l.length; i++) {
	  var s = calc_card_score(l[i]);
	  if (s > max_score) {
	    max = i;
	    max_score = s;
	  }
	}
	
	var ma_score = read_major_arcana(cur.board[cur.token]);
	var ma_u_score = read_major_arcana(cur.board[upper]);
	if (score + ma_score.sword_offence + sum_cl
	    > ma_u_score.sword_defence + sum_su + sum_cu) {
	  cur.move_or_stay = "choose";
	  next.state = "choose_move_or_stay";
	  next.drawn = cur.drawn;
	} else {
	  cur.move_or_stay = "stay";
	  next.discarded = cur.discarded.concat([cur.drawn]); 

	  if (max != null) {
	    var card = cur["cups_" + (cur.token + 1)][max];
	    next["cups_" + (cur.token + 1)]
	      = [].concat(cur["cups_" + (cur.token + 1)]);
	    next["cups_" + (cur.token + 1)].splice(max, 1);
	    next.discarded.push(card);
	  }
	}

	animate = game_view.animate_lower_sword;
	break;

      case "D":
	var left = cur.token + 1;
	var upper = cur.token + 3;
	
	var ma_score = read_major_arcana(cur.board[cur.token]);
	var ma_l_score = read_major_arcana(cur.board[left]);
	if (score + ma_score.coin_pain > ma_l_score.coin_gain) {
	  cur.move_or_stay = "move";
	  next["coins_" + (upper + 1)]
	    = cur["coins_" + (upper + 1)].concat([cur.drawn]);
	  next.token = left;
	} else {
	  cur.move_or_stay = "stay";
	  next.coins_lower = cur.coins_lower.concat([cur.drawn]);
	}

	animate = game_view.animate_lower_coin;
	break;

      case "H":
	next["cups_" + (cur.token + 1)]
	  = cur["cups_" + (cur.token + 1)].concat([cur.drawn]);
	cur.move_or_stay = "stay";

	animate = game_view.animate_lower_cup;
	break;

      case "C":
	var right = (cur.token -1 + 6) % 6;

	var ma_score = read_major_arcana(cur.board[cur.token]);
	var ma_r_score = read_major_arcana(cur.board[right]);

	var min = null;
	var min_score = 15;
	
	for (var i = 0; i < cur["cups_" + (cur.token + 1)].length; i++) {
	  var sc = calc_card_score(cur["cups_" + (cur.token + 1)][i]);
	  if (score + ma_score.wand_lower > sc + ma_r_score.cup_lower) {
	    if (sc < min_score) {
	      min = i;
	      min_score = sc;
	    }
	  }
	}
	if (min != null) {
	  cur.move_or_stay = "move";
	  next.token = right;
	  next.discarded
	    = cur.discarded.concat([cur.drawn],
				   cur["cups_" + (cur.token + 1)][min]);
	  next["cups_" + (cur.token + 1)]
	    = [].concat(cur["cups_" + (cur.token + 1)]);
	  next["cups_" + (cur.token + 1)].splice(min, 1);
	} else {
	  cur.move_or_stay = "stay";
	  next.discarded = cur.discarded.concat([cur.drawn]);
	}

	animate = game_view.animate_lower_wand;
	break;
      }
    }
    
    var c = {x: 0, y: 0,
	     width: setting.window_width, height: setting.window_height,
	     func: function () {
	       game_view.lf.reset_animation();
	       game_view.redraw();
	     }
	    };
    game_view.controller_click_array = [c];
    game_view.controller_move_array = [];

    game_view.animation_temp = {prev_past: 0};
    game_view.lf.set_animation(animate);
  },

  animate_game_end : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    if (temp.prev_past <= past) {
      game_view.draw_screen();
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "終了カードを引きました。<br />" + setting.rule_terminals + " 度目なのでゲーム終了です。", en: "You drew the terminal card.<br/>The game is over, because it appeared " + setting.rule_terminals + "times."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 3000;
    if (time <= past + scene) {
      var win_or_lose;
      if (game_view.model_next.win_or_lose == "win") {
	win_or_lose = L({ja: "あなたの勝ちのようです。", en: "The board shows that you win."});
      } else {
	win_or_lose = L({ja: "あなたの負けのようです。", en: "The board shows that you lose."});
      }
	
      var img1, img2;
      var anchor1, anchor2;
      if (cur.purpose== "A13") {
	game_view.status_window.innerHTML = L({ja: "終了時、上爻か五爻にトークンがあれば、あなたの勝ちでした。<br/><em>" + win_or_lose + "</em>", en: "You must win at the end if the token places in the top or in the fifth.<br/><em>" + win_or_lose + "</em>"});
	img1 = make_card_image(cur.board[5].card, 
			       (cur.board[5].upright)? 0 : Math.PI);
	img2 = make_card_image(cur.board[4].card, 
			       (cur.board[4].upright)? 0 : Math.PI);
	anchor1 = game_view.anchor_6;
	anchor2 = game_view.anchor_5;
      } else {
	game_view.status_window.innerHTML = L({ja: "終了時、二爻か五爻にトークンがあれば、あなたの勝ちでした。<br/><em>" + win_or_lose + "</em>", en: "You must win at the end if the token places in the second or in the fifth.<br/><em>" + win_or_lose + "</em>"});
	img1 = make_card_image(cur.board[1].card, 
			       (cur.board[1].upright)? 0 : Math.PI);
	img2 = make_card_image(cur.board[4].card, 
			       (cur.board[4].upright)? 0 : Math.PI);
	anchor1 = game_view.anchor_2;
	anchor2 = game_view.anchor_5;
      }
      var img3 = game_view.img_token;
      var anchor3 = game_view["anchor_" + (cur.token + 1)];
      ctx.drawImage(img1, Math.floor(anchor1.x - img1.width / 2),
		    Math.floor(anchor1.y - img1.height / 2));
      ctx.drawImage(img2, Math.floor(anchor2.x - img2.width / 2),
		    Math.floor(anchor2.y - img2.height / 2));
      ctx.drawImage(img3, Math.floor(anchor3.x - img3.width / 2),
		    Math.floor(anchor3.y - img3.height / 2));
      temp.prev_past = time;
      return true;
    }
    past += scene;

    game_view.redraw();
    return false;
  },

  animate_shuffle : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_board.getContext('2d');
      var img = game_view.img_discarded;
      var anchor = game_view.anchor_discarded;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.clearRect(x, y, img.width, img.height);
    }

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_rest_talon.getContext('2d');
      ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
    }

    scene = 3000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "終了カードを引きました。<br />まだ、" + game_view.model_next.drawn_terminals + " (/" + setting.rule_terminals + ") 度目なので、捨て札を山に戻し、シャッフルします。", en: "You drew the terminal card.<br/>Shuffle the talon with the discarded cards, because it appeared "  + game_view.model_next.drawn_terminals + " (/" + setting.rule_terminals + ") times so far."});

      var img = game_view.img_discarded
      var begin = game_view.anchor_discarded;
      var end = game_view.anchor_talon;

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    game_view.redraw();
    return false;
  },

  animate_upper_sword : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "上卦でソードのカードを引きました。<br/>逆方向の比爻に動くか否かを計算します。", en: "You drew a sword card on upper trigram.<br/>Calculate wheter the token must move right or not."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past && setting.calc_screen) {
      game_view.draw_screen();
    }

    var score = calc_card_score(cur.drawn);
    var right = cur.token - 1;
    var left = (cur.token + 1) % 6;

    var max = null;
    var max_score = 0;
    for (var i = 0, l = cur["coins_" + (cur.token + 1)];
	 i < l.length; i++) {
      var sc = calc_card_score(l[i]);
      if (sc > max_score) {
	max = i;
	max_score = sc;
      }
    }
    var ma_r_score = read_major_arcana(cur.board[right]);
    var ma_r = cur.board[right];

    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "Max(@♦) + (→A)[♠守] &gt; $♠ + (→A)[♦苦]?", en: "Max(@♦) + (→A)[♠defence] &gt; $♠ + (→A)[♦pain]?"});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (! temp.minor_rect1) {
      var l = cur["coins_" + (cur.token + 1)];
      var img;
      if (l && l.length > 0) {
	img = make_cards_image(l);
      } else {
	img = temp.img_drawn;
      }
      temp.minor_rect1 = calc_minor_rect("coins_" + (cur.token + 1), img);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "<em>" + max_score + "(= Max(@♦))</em> + (→A)[♠守] &gt; $♠ + (→A)[♦苦]? ", en: "<em>" + max_score + "(= Max(@♦))</em> + (→A)[♠defence] &gt; $♠ + (→A)[♦pain]?"});
      var anchor = {x: Math.floor((temp.minor_rect1.x
				   + temp.minor_rect1.width / 2)),
		    y: Math.floor((temp.minor_rect1.y
				   + temp.minor_rect1.height / 2))};
      if (max != null) {
	var img = make_card_image(cur["coins_" + (cur.token + 1)][max], 0);

	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
      }
      ctx.fillStyle = 'white';
      var text = max_score;
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + max_score + "(= Max(@♦)) + <em>" + ma_r_score.sword_defence + "(= (→A)[♠守])</em> &gt;  $♠ + (→A)[♦苦]? ", en: "" + max_score + "(= Max(@♦)) + <em>" + ma_r_score.sword_defence + "(= (→A)[♠defence])</em> &gt; $♠ + (→A)[♦pain]?"});
      var img = make_card_image(ma_r.card,
				(ma_r.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (right + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma_r);
      if (time - past > 1000) {
	text = "♠ /" + ma_r_score.sword_defence;
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + max_score + "(= Max(@♦)) + " + ma_r_score.sword_defence + "(= (→A)[♠守]) &gt; <em>" + score + "(= $♠)</em> +  (→A)[♦苦]? ", en: "" + max_score + "(= Max(@♦)) + " + ma_r_score.sword_defence + "(= (→A)[♠defence]) &gt; <em>" + score + "(= $♠)</em> + (→A)[♦pain]?"});

      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText(score, anchor.x, anchor.y);
      ctx.strokeText(score, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + max_score + "(= Max(@♦)) + " + ma_r_score.sword_defence + "(= (→A)[♠守]) &gt; " + score + "(= $♠) + <em>" + ma_r_score.coin_pain + "(= (→A)[♦苦])</em>? ", en: "" + max_score + "(= Max(@♦)) + " + ma_r_score.sword_defence + "(= (→A)[♠defence]) &gt; " + score + "(= $♠) + <em>" + ma_r_score.coin_pain + "(= (→A)[♦pain])</em>?"});
      var img = make_card_image(ma_r.card,
				(ma_r.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (right + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma_r);
      if (time - past > 1000) {
	text = "♦" + ma_r_score.coin_pain + "| ";
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    if (cur.move_or_stay == "move") {
      scene = 1000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (max_score + ma_r_score.sword_defence) + "(= Max(@♦) + (→A)[♠守]) &gt; " + (score + ma_r_score.coin_pain) + "(= $♠ + (→A)[♦苦])? <br/>→ <em>大なり。動く。</em>", en: "" + (max_score + ma_r_score.sword_defence) + "(= Max(@♦) + (→A)[♠defence]) &gt; " + (score + ma_r_score.coin_pain) + "(= (←A)$♠ + (→A)[♦pain])? <br/>→ <em>Yes, MOVE.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (right + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (right + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      if (! temp.minor_rect2) {
	var l = cur["swords_upper"];
	var img;
	if (l && l.length > 0) {
	  img = make_cards_image(l);
	} else {
	  img = temp.img_drawn;
	}
	temp.minor_rect2 = calc_minor_rect("swords_upper", img);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードは上卦のソードのスペースへ。", en: "Place the drawn card onto the upper sword space."});
	var img = temp.img_drawn;
	var begin = game_view.anchor_talon;
	var end = {x: temp.minor_rect2.x + temp.minor_rect2.width / 2,
		   y: temp.minor_rect2.y + temp.minor_rect2.height / 2};

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);

	temp.prev_past = time;
	return true;
      }
      past+= scene;
    } else {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (max_score + ma_r_score.sword_defence) + "(= Max(@♦) + (→A)[♠守]) &gt; " + (score + ma_r_score.coin_pain) + "(= $♠ + (→A)[♦苦])? <br/>→ <em>小なり。留まる。</em>", en: "" + (max_score + ma_r_score.sword_defence) + "(= Max(@♦) + (→A)[♠defence]) &gt; " + (score + ma_r_score.coin_pain) + "(= (←A)$♠ + (→A)[♦pain])? <br/>→ <em>No, STAY.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      var coins = "coins_lower";
      if (left != 0) {
	coins = "coins_" + (left + 1);
      }

      if (! temp.minor_rect2) {
	var img;
	if (cur[coins].length > 0) {
	  img = make_cards_image(cur[coins]);
	} else {
	  img = temp.img_drawn;
	}
	temp.minor_rect2 = calc_minor_rect(coins, img);
      }

      if (temp.prev_past <= past) {
	if (max != null) {
	  temp.max_card = cur["coins_" + (cur.token + 1)][max];
	  temp.img_max = make_card_image(temp.max_card, 0);
	}
	cur["coins_" + (cur.token + 1)] = game_view.model_next["coins_" + (cur.token + 1)];
	game_view.draw_minor();
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "現在爻の最大のコインのカードを順方向の比爻(上爻のときは下卦のコインのスペース)へ。", en: "Place the max coin card of the current place onto the left place (or onto the lower coin space when at the top place)."});
	if (temp.img_max) {
	  var img = temp.img_max;
	  var begin = {x: temp.minor_rect1.x + temp.minor_rect1.width / 2,
		       y: temp.minor_rect1.y + temp.minor_rect1.height / 2};
	  var end = {x: temp.minor_rect2.x + temp.minor_rect2.width / 2,
		     y: temp.minor_rect2.y + temp.minor_rect2.height / 2};

          var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	cur[coins] = game_view.model_next[coins];
	game_view.draw_minor();
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードは捨てます。", en: "Place the drawn card onto the upper place."});
	var img = temp.img_drawn;
	var begin = game_view.anchor_talon;
	var end = game_view.anchor_discarded;

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);

	temp.prev_past = time;
	return true;
      }
      past+= scene;
    }
    
    game_view.redraw();
    return false;
  },

  animate_upper_coin : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "上卦でコインのカードを引きました。<br/>トークンは留まります。", en: "You drew a coin card on upper trigram.<br/>The token must stay."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (! temp.minor_rect) {
      var l = cur["coins_" + (cur.token + 1)];
      var img;
      if (l && l.length > 0) {
	img = make_cards_image(l);
      } else {
	img = temp.img_drawn;
      }
      temp.minor_rect = calc_minor_rect("coins_" + (cur.token + 1), img);
    }

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "引いたカードは現在爻のコインとします。", en: "Place the drawn coin card onto the current place."});
      var img = temp.img_drawn;
      var begin = game_view.anchor_talon;
      var end = {x: temp.minor_rect.x + temp.minor_rect.width / 2,
		 y: temp.minor_rect.y + temp.minor_rect.height / 2};

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }
    past+= scene;
    
    game_view.redraw();
    return false;
  },

  animate_upper_cup : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "上卦でカップのカードを引きました。<br/>順方向の比爻に動くか否かを計算します。", en: "You drew a cup card on upper trigram.<br/>Calculate wheter the token can move left or not."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past && setting.calc_screen) {
      game_view.draw_screen();
    }

    var score = calc_card_score(cur.drawn);
    var left = (cur.token + 1) % 6;
    var lower = cur.token - 3;

    var ma_score = read_major_arcana(cur.board[cur.token]);
    var ma_l_score = read_major_arcana(cur.board[left]);

    var ma = cur.board[cur.token];
    var ma_l = cur.board[left];

    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "$♥ + (@A)[♥上流] &gt; (←A)[♣上流]?", en: "$♥ + (@A)[♥upper] &gt; (←A)[♣upper]?"});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (temp.prev_past <= past) {
      if (cur["cups_" + (lower + 1)].length > 0) {
	temp.img_cups_lower = make_cards_image(cur["cups_" + (lower + 1)]);
	temp.rect_cups_lower
	  = calc_minor_rect("cups_" + (lower + 1), temp.img_cups_lower);
      } else {
	temp.rect_cups_lower
	  = calc_minor_rect("cups_" + (lower + 1), temp.img_drawn);
      }
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "<em>" + score + "(= $♥)</em> + (@A)[♥上流] &gt; (←A)[♣上流]?", en: "<em>" + score + "(= $♥)</em> + (@A)[♥upper] &gt; (←A)[♣upper]?"});
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText(score, anchor.x, anchor.y);
      ctx.strokeText(score, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♥) + <em>" + ma_score.cup_upper + "(= (@A)[♥上流])</em> &gt; (←A)[♣上流]?", en: "" + score + "(= $♥) + <em>" + ma_score.cup_upper + "(= (@A)[♥upper])</em> &gt; (←A)[♣upper]?"});
      var img = make_card_image(ma.card,
				(ma.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (cur.token + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma);
      if (time - past > 1000) {
	text = "♥" + ma_score.cup_upper + "∽ ";
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♥) + " + ma_score.cup_upper + "(= (@A)[♥上流]) &gt; <em>" + ma_l_score.wand_upper + "(= (←A)[♣上流])</em>?", en: "" + score + "(= $♥) + " + ma_score.cup_upper + "(= (@A)[♥upper]) &gt; <em>" + ma_l_score.wand_upper + "(= (←A)[♣upper])</em>?"});
      var img = make_card_image(ma_l.card,
				(ma_l.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (left + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma);
      if (time - past > 1000) {
	text = "♣" + ma_l_score.wand_upper + "∽ ";
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    if (cur.move_or_stay == "move") {
      scene = 1000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.cup_upper) + "(= $♥ + (@A)[♥上流]) &gt; " + ma_l_score.wand_upper + "(= (←A)[♣上流])?<br/>→ <em>大なり。動く。</em>", en: "" + (score + ma_score.cup_upper) + "(= $♥ + (@A)[♥upper]) &gt; " + ma_l_score.wand_upper + "(= (←A)[♣upper])?<br/>→ <em>Yes, MOVE.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (left + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (left + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードは応爻のカップとします。", en: "Place the drawn cup card onto the lower place."});
	var img = temp.img_drawn;
	var begin = game_view.anchor_talon;
	var end = {x: temp.rect_cups_lower.x + temp.rect_cups_lower.width / 2,
		   y: temp.rect_cups_lower.y + temp.rect_cups_lower.height / 2};
	var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);

	temp.prev_past = time;
	return true;
      }
      past += scene;
    } else {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.cup_upper) + "(= $♥ + (@A)[♥上流]) &gt; " + ma_l_score.wand_upper + "(= (←A)[♣上流])?<br/>→ <em>小なり。留まる。</em>", en: "" + (score + ma_score.cup_upper) + "(= $♥ + (@A)[♥upper]) &gt; " + ma_l_score.wand_upper + "(= (←A)[♣upper])?<br/>→ <em>No, STAY.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードは応爻のカップとします。", en: "Place the drawn cup card onto the lower place."});
	var img = temp.img_drawn;
	var begin = game_view.anchor_talon;
	var end = {x: temp.rect_cups_lower.x + temp.rect_cups_lower.width / 2,
		   y: temp.rect_cups_lower.y + temp.rect_cups_lower.height / 2};
	var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);

	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
    
    game_view.redraw();
    return false;
  },

  animate_upper_wand : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "上卦でワンドのカードを引きました。<br/>応爻に動くか否かを計算します。", en: "You drew a wand card on upper trigram.<br/>Calculate wheter the token can move lower or not."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past && setting.calc_screen) {
      game_view.draw_screen();
    }

    var score = calc_card_score(cur.drawn);
    var lower = cur.token - 3;

    var ma_score = read_major_arcana(cur.board[cur.token]);
    var ma_l_score = read_major_arcana(cur.board[lower]);

    var max = null;
    var max_score = 0;
    for (var i = 0; i < cur["cups_" + (lower + 1)].length; i++) {
      var sc = calc_card_score(cur["cups_" + (lower + 1)][i]);
      if (sc > max_score) {
	max = i;
	max_score = sc;
      }
    }

    var max_c = null;
    var max_c_score = 0;
    var sum_c = 0;
    for (var i = 0; i < cur["coins_" + (cur.token + 1)].length; i++) {
      var sc = calc_card_score(cur["coins_" + (cur.token + 1)][i]);
      sum_c += sc;
      if (sc > max_c_score) {
	max_c = i;
	max_c_score = sc;
      }
    }

    var ma = cur.board[cur.token];
    var ma_l = cur.board[lower];

    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "$♣ + (@A)[♣上流] + Max(↓♥(要)) + (↓A)[♥下流] &gt; Sum(@♦) + (@A)[♦喜]?", en: "$♣ + (@A)[♣upper] + Max(↓♥(need)) + (↓A)[♥lower] &gt; Sum(@♦) + (@A)[♦gain]?"});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (temp.prev_past <= past) {
      if (cur["cups_" + (lower + 1)].length > 0) {
	temp.img_cups_lower = make_cards_image(cur["cups_" + (lower + 1)]);
	temp.rect_cups_lower
	  = calc_minor_rect("cups_" + (lower + 1), temp.img_cups_lower);
      } else {
	temp.rect_cups_lower
	  = calc_minor_rect("cups_" + (lower + 1), temp.img_drawn);
      }
      if (cur["coins_" + (cur.token + 1)].length > 0) {
	temp.img_coins = make_cards_image(cur["coins_" + (cur.token + 1)]);
	temp.rect_coins
	  = calc_minor_rect("coins_" + (cur.token + 1), temp.img_coins);
      } else {
	temp.rect_coins
	  = calc_minor_rect("coins_" + (cur.token + 1), temp.img_drawn);
      }
      if (cur.coins_lower.length > 0) {
	temp.img_coins_lower = make_cards_image(cur.coins_lower);
	temp.rect_coins_lower
	  = calc_minor_rect("coins_lower", temp.img_coins_lower);
      } else {
	temp.rect_coins_lower
	  = calc_minor_rect("coins_lower", temp.img_drawn);
      }
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "<em>" + score + "(= $♣)</em> + (@A)[♣上流] + Max(↓♥(要)) + (↓A)[♥下流] &gt; Sum(@♦) + (@A)[♦喜]?", en: "<em>" + score + "(= $♣)</em> + (@A)[♣upper] + Max(↓♥(need)) + (↓A)[♥lower] &gt; Sum(@♦) + (@A)[♦gain]?"});
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText(score, anchor.x, anchor.y);
      ctx.strokeText(score, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♣) + <em>" + ma_score.wand_upper + "(= (@A)[♣上流])</em> + Max(↓♥(要)) + (↓A)[♥下流] &gt; Sum(@♦) + (@A)[♦喜]?", en: "" + score + "(= $♣) + <em>" + ma_score.wand_upper + "(= (@A)[♣upper])</em> + Max(↓♥(need)) + (↓A)[♥lower] &gt; Sum(@♦) + (@A)[♦gain]?"});
      var img = make_card_image(ma.card,
				(ma.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (cur.token + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma);
      if (time - past > 1000) {
	text = "♣" + ma_score.wand_upper + "∽ ";
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣上流]) + <em>" + max_score + "(= Max(↓♥(要)))</em> + (↓A)[♥下流] &gt; Sum(@♦) + (@A)[♦喜]?", en: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣upper]) + <em>" + max_score + "(= Max(↓♥(need)))</em> + (↓A)[♥lower] &gt; Sum(@♦) + (@A)[♦gain]?"});
      var anchor = {x: Math.floor((temp.rect_cups_lower.x
				   + temp.rect_cups_lower.width / 2)),
		    y: Math.floor((temp.rect_cups_lower.y
				   + temp.rect_cups_lower.height / 2))};
      if (max != null) {
	var img = make_card_image(cur["cups_" + (lower + 1)][max], 0);

	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
      }
      ctx.fillStyle = 'white';
      var text = max_score;
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (max == null) {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣上流]) + " + max_score + "(= Max(↓♥(要))) + (↓A)[♥下流] &gt; Sum(@♦) + (@A)[♦喜]?<br/>→ <em>応爻にカップがない。留まる。</em>", en: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣upper]) + " + max_score + "(= Max(↓♥(need))) + (↓A)[♥lower] &gt; Sum(@♦) + (@A)[♦gain]?<br/>→ <em>There is no cup on the lower place.  STAY.</em>"});

	temp.prev_past = time;
	return true;
      }
      past += scene;
    } else {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣上流]) + " + max_score + "(= Max(↓♥(要))) + <em>" + ma_l_score.cup_lower + "(= (↓A)[♥下流])</em> &gt; Sum(@♦) + (@A)[♦喜]?", en: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣upper]) + " + max_score + "(= Max(↓♥(need))) + <em>" + ma_l_score.cup_lower + "(= (↓A)[♥lower])</em> &gt; Sum(@♦) + (@A)[♦gain]?"});
	var img = make_card_image(ma_l.card,
				  (ma_l.upright)? 0 : Math.PI);
	var anchor = game_view["anchor_" + (lower + 1)];
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
	ctx.fillStyle = 'white';
	var text = read_major_arcana_string(ma_l);
	if (time - past > 1000) {
	  text = "♥ ∽" + ma_l_score.cup_lower;
	}
	ctx.fillText(text, anchor.x, anchor.y);
	ctx.strokeText(text, anchor.x, anchor.y);
      
	temp.prev_past = time;
	return true;
      }
      past += scene;

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣上流]) + " + max_score + "(= Max(↓♥(要))) + " + ma_l_score.cup_lower + "(= (↓A)[♥下流]) &gt; <em>" + sum_c + "(= Sum(@♦))</em> + (@A)[♦喜]?", en: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣upper]) + " + max_score + "(= Max(↓♥(need))) + " + ma_l_score.cup_lower + "(= (↓A)[♥lower]) &gt; <em>" + sum_c + "(= Sum(@♦))</em> + (@A)[♦gain]?"});
	var anchor = {x: Math.floor((temp.rect_coins.x
				     + temp.rect_coins.width / 2)),
		      y: Math.floor((temp.rect_coins.y
				     + temp.rect_coins.height / 2))};
	if (max != null && temp.img_coins) {
	  var img = temp.img_coins;

	  var x = Math.floor(anchor.x - img.width / 2);
	  var y = Math.floor(anchor.y - img.height / 2);
	  ctx.drawImage(img, x, y);
	  ctx.beginPath();
	  ctx.rect(x, y, img.width, img.height);
	  ctx.closePath()
	  ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	  ctx.fill();
	}
	ctx.fillStyle = 'white';
	var text = sum_c;
	ctx.fillText(text, anchor.x, anchor.y);
	ctx.strokeText(text, anchor.x, anchor.y);
      
	temp.prev_past = time;
	return true;
      }
      past += scene;

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣上流]) + " + max_score + "(= Max(↓♥(要))) + " + ma_l_score.cup_lower + "(= (↓A)[♥下流]) &gt; " + sum_c + "(= Sum(@♦)) + <em>" + ma_score.coin_gain + "(= (@A)[♦喜])</em>?", en: "" + score + "(= $♣) + " + ma_score.wand_upper + "(= (@A)[♣upper]) + " + max_score + "(= Max(↓♥(need))) + " + ma_l_score.cup_lower + "(= (↓A)[♥lower]) &gt; " + sum_c + "(= Sum(@♦)) + <em>" + ma_score.coin_gain + "(= (@A)[♦gain])</em>?"});
	var img = make_card_image(ma.card,
				  (ma.upright)? 0 : Math.PI);
	var anchor = game_view["anchor_" + (cur.token + 1)];
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
	ctx.fillStyle = 'white';
	var text = read_major_arcana_string(ma_l);
	if (time - past > 1000) {
	  text = "♦ |" + ma_score.coin_gain;
	}
	ctx.fillText(text, anchor.x, anchor.y);
	ctx.strokeText(text, anchor.x, anchor.y);
	
	temp.prev_past = time;
	return true;
      }
      past += scene;
    }

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    if (cur.move_or_stay == "move") {
      scene = 1000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.wand_upper + max_score + ma_l_score.cup_lower) + "(= $♣ + (@A)[♣上流] + Max(↓♥(要)) + (↓A)[♥下流]) &gt; " + (sum_c + ma_score.coin_gain) + "(= Sum(@♦) + (@A)[♦喜])?<br/>→ <em>大なり。動く。</em>", en: "" + (score + ma_score.wand_upper + max_score + ma_l_score.cup_lower) + "(= $♣ + (@A)[♣upper] + Max(↓♥(need)) + (↓A)[♥lower]) &gt; " + (sum_c + ma_score.coin_gain) + "(= Sum(@♦) + (@A)[♦gain])?<br/>→ <em>Yes, MOVE.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (lower + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (lower + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
	temp.img_max = make_card_image(cur["cups_" + (lower + 1)][max], 0);
	cur["cups_" + (lower + 1)] = game_view.model_next["cups_" + (lower + 1)];
	game_view.draw_minor();
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードと応爻の最大のカップを捨てます。", en: "Discard the drawn wand and the max cup of the lower place."});
	if (temp.img_max) {
	  var img = temp.img_max;
	  var begin = {x: temp.rect_cups_lower.x + temp.rect_cups_lower.width / 2,
		       y: temp.rect_cups_lower.y + temp.rect_cups_lower.height / 2};
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    } else {
      if (max != null) {
	scene = 2000;
	if (time <= past + scene) {
	  game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.wand_upper + max_score + ma_l_score.cup_lower) + "(= $♣ + (@A)[♣上流] + Max(↓♥(要)) + (↓A)[♥下流]) &gt; " + (sum_c + ma_score.coin_gain) + "(= Sum(@♦) + (@A)[♦喜])?<br/>→ <em>小なり。留まる。</em>", en: "" + (score + ma_score.wand_upper + max_score + ma_l_score.cup_lower) + "(= $♣ + (@A)[♣upper] + Max(↓♥(need)) + (↓A)[♥lower]) &gt; " + (sum_c + ma_score.coin_gain) + "(= Sum(@♦) + (@A)[♦gain])?<br/>→ <em>No, STAY.</em>"});
	  temp.prev_past = time;
	  return true;
	}
	past += scene;
      }

      if (temp.prev_past <= past) {
	if (max_c != null) {
	  temp.img_max = make_card_image(cur["coins_" + (cur.token + 1)][max_c], 0);
	  cur["coins_" + (cur.token + 1)] = game_view.model_next["coins_" + (cur.token + 1)];
	  game_view.draw_minor();
	}
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "現在爻の最大のコインを下卦のコインのスペースへ。", en: "Place the drawn wand onto the lower coin space."});
	if (temp.img_max) {
	  var img = temp.img_max;
	  var begin = {x: temp.rect_coins.x + temp.rect_coins.width / 2,
		       y: temp.rect_coins.y + temp.rect_coins.height / 2};
	  var end = game_view.anchor_coins_lower;
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
	cur.coins_lower = game_view.model_next.coins_lower;
	game_view.draw_minor();
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードを捨てます。", en: "Discard the drawn wand."});
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded;
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
    
    game_view.redraw();
    return false;
  },

  animate_lower_sword : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "下卦でソードのカードを引きました。<br/>応爻に動くか否かを計算します。", en: "You drew a sword card on lower trigram.<br/>Calculate wheter the token can move upper or not."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past && setting.calc_screen) {
      game_view.draw_screen();
    }

    var score = calc_card_score(cur.drawn);
    var upper = cur.token + 3;

    var sum_su = 0;
    var sum_cl = 0;
    var sum_cu = 0;

    for (var i = 0, l = cur.swords_upper; i < l.length; i++) {
      sum_su += calc_card_score(l[i]);
    }
    for (var i = 0, l = cur.coins_lower; i < l.length; i++) {
      sum_cl += calc_card_score(l[i]);
    }
    for (var i = 0, l = cur["coins_" + (upper + 1)];
	 i < l.length; i++) {
      sum_cu += calc_card_score(l[i]);
    }

    var max = null;
    var max_score = 0;
    for (var i = 0, l = cur["cups_" + (cur.token + 1)];
	 i < l.length; i++) {
      var s = calc_card_score(l[i]);
      if (s > max_score) {
	max = i;
	max_score = s;
      }
    }
	
    var ma_score = read_major_arcana(cur.board[cur.token]);
    var ma_u_score = read_major_arcana(cur.board[upper]);
    var ma = cur.board[cur.token];
    var ma_u = cur.board[upper];

    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "$♠ + (@A)[♠攻] + Sum(↓♦) &gt; (↑A)[♠守] + Sum(↑♦) + Sum(↑♠)?", en: "$♠ + (@A)[♠offence] + Sum(↓♦) &gt; (↑A)[♠defence] + Sum(↑♦) + Sum(↑♠)?"});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (temp.prev_past <= past) {
      if (cur.coins_lower.length > 0) {
	temp.img_coins_lower = make_cards_image(cur.coins_lower);
	temp.rect_coins_lower
	  = calc_minor_rect("coins_lower", temp.img_coins_lower);
      } else {
	temp.rect_coins_lower
	  = calc_minor_rect("coins_lower", temp.img_drawn);
      }
      if (cur["coins_" + (upper + 1)].length > 0) {
	temp.img_coins_upper = make_cards_image(cur["coins_" + (upper + 1)]);
	temp.rect_coins_upper
	  = calc_minor_rect("coins_" + (upper + 1), temp.img_coins_upper);
      } else {
	temp.rect_coins_upper
	  = calc_minor_rect("coins_" + (upper + 1), temp.img_drawn);
      }
      if (cur.swords_upper.length > 0) {
	temp.img_swords_upper = make_cards_image(cur.swords_upper);
	temp.rect_swords_upper
	  = calc_minor_rect("swords_upper", temp.img_swords_upper);
      } else {
	temp.rect_swords_upper
	  = calc_minor_rect("swords_upper", temp.img_drawn);
      }
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "<em>" + score + "(= $♠)</em> + (@A)[♠攻] + Sum(↓♦) &gt; (↑A)[♠守] + Sum(↑♦) + Sum(↑♠)?", en: "<em>" + score + "(= $♠)</em> + (@A)[♠offence] + Sum(↓♦) &gt; (↑A)[♠defence] + Sum(↑♦) + Sum(↑♠)?"});
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText(score, anchor.x, anchor.y);
      ctx.strokeText(score, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♠) + <em>" + ma_score.sword_offence + "(= (@A)[♠攻])</em> + Sum(↓♦) &gt; (↑A)[♠守] + Sum(↑♦) + Sum(↑♠)?", en: "" + score + "(= $♠) + <em>" + ma_score.sword_offence + "(= (@A)[♠offence])</em> + Sum(↓♦) &gt; (↑A)[♠defence] + Sum(↑♦) + Sum(↑♠)?"});
      var img = make_card_image(ma.card,
				(ma.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (cur.token + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma);
      if (time - past > 1000) {
	text = "♠" + ma_score.sword_offence + "/ ";
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;


    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♠) + " + ma_score.sword_offence + "(= (@A)[♠攻]) + <em>" + sum_cl + "(= Sum(↓♦))</em> &gt; (↑A)[♠守] + Sum(↑♦) + Sum(↑♠)?", en: "" + score + "(= $♠) + " + ma_score.sword_offence + "(= (@A)[♠offence]) + <em>" + sum_cl + "(= Sum(↓♦))</em> &gt; (↑A)[♠defence] + Sum(↑♦) + Sum(↑♠)?"});
      var anchor = {x: Math.floor((temp.rect_coins_lower.x
				   + temp.rect_coins_lower.width / 2)),
		    y: Math.floor((temp.rect_coins_lower.y
				   + temp.rect_coins_lower.height / 2))};
      var img = temp.img_coins_lower;
      if (img) {
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
      }
      ctx.fillStyle = 'white';
      ctx.fillText(sum_cl, anchor.x, anchor.y);
      ctx.strokeText(sum_cl, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♠) + " + ma_score.sword_offence + "(= (@A)[♠攻]) + " + sum_cl + "(= Sum(↓♦)) &gt; <em>" + ma_u_score.sword_defence + "(= (↑A)[♠守])</em> + Sum(↑♦) + Sum(↑♠)?", en: "" + score + "(= $♠) + " + ma_score.sword_offence + "(= (@A)[♠offence]) + " + sum_cl + "(= Sum(↓♦)) &gt; <em>" + ma_u_score.sword_defence + "(= (↑A)[♠defence])</em> + Sum(↑♦) + Sum(↑♠)?"});
      var img = make_card_image(ma_u.card,
				(ma_u.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (upper + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma_u);
      if (time - past > 1000) {
	text = "♠ /" + ma_u_score.sword_offence;
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♠) + " + ma_score.sword_offence + "(= (@A)[♠攻]) + " + sum_cl + "(= Sum(↓♦)) &gt; " + ma_u_score.sword_defence + "(= (↑A)[♠守]) + <em>" + sum_cu + "(= Sum(↑♦))</em> + Sum(↑♠)?", en: "" + score + "(= $♠) + " + ma_score.sword_offence + "(= (@A)[♠offence]) + " + sum_cl + "(= Sum(↓♦)) &gt; " + ma_u_score.sword_defence + "(= (↑A)[♠defence]) + <em>" + sum_cu + "(= Sum(↑♦))</em> + Sum(↑♠)?"});
      var anchor = {x: Math.floor((temp.rect_coins_upper.x
				   + temp.rect_coins_upper.width / 2)),
		    y: Math.floor((temp.rect_coins_upper.y
				   + temp.rect_coins_upper.height / 2))};
      var img = temp.img_coins_upper;
      if (img) {
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
      }
      ctx.fillStyle = 'white';
      ctx.fillText(sum_cu, anchor.x, anchor.y);
      ctx.strokeText(sum_cu, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♠) + " + ma_score.sword_offence + "(= (@A)[♠攻]) + " + sum_cl + "(= Sum(↓♦)) &gt; " + ma_u_score.sword_defence + "(= (↑A)[♠守]) + " + sum_cu + "(= Sum(↑♦)) + <em>" + sum_su + "(= Sum(↑♠))</em>?", en: "" + score + "(= $♠) + " + ma_score.sword_offence + "(= (@A)[♠offence]) + " + sum_cl + "(= Sum(↓♦)) &gt; " + ma_u_score.sword_defence + "(= (↑A)[♠defence]) + " + sum_cu + "(= Sum(↑♦)) + <em>" + sum_su + "(= Sum(↑♠))</em>?"});
      var anchor = {x: Math.floor((temp.rect_swords_upper.x
				   + temp.rect_swords_upper.width / 2)),
		    y: Math.floor((temp.rect_swords_upper.y
				   + temp.rect_swords_upper.height / 2))};
      var img = temp.img_swords_upper;
      if (img) {
	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
      }
      ctx.fillStyle = 'white';
      ctx.fillText(sum_su, anchor.x, anchor.y);
      ctx.strokeText(sum_su, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    if (cur.move_or_stay == "choose") {
      scene = 1000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.sword_offence + sum_cl) + "(= $♠ + (@A)[♠攻] + Sum(↓♦)) &gt; " + (ma_u_score.sword_defence + sum_cu + sum_su) + "(= (↑A)[♠守] + Sum(↑♦) + Sum(↑♠))?<br/>→ <em>大なり。選ぶ。</em>", en: "" + (score + ma_score.sword_offence + sum_cl) + "(= $♠ + (@A)[♠offence] + Sum(↓♦)) &gt; " + (ma_u_score.sword_defence + sum_cu + sum_su) + "(= (↑A)[♠defence] + Sum(↑♦) + Sum(↑♠))? <br/>→ <em>Yes, CHOOSE.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;
    } else {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.sword_offence + sum_cl) + "(= $♠ + (@A)[♠offence] + Sum(↓♦)) &gt; " + (ma_u_score.sword_defence + sum_cu + sum_su) + "(= (↑A)[♠defence] + Sum(↑♦) + Sum(↑♠))?<br/>→ <em>小なり。留まる。</em>", en: "" + (score + ma_score.sword_offence + sum_cl) + "(= $♠ + (@A)[♠offence] + Sum(↓♦)) &gt; " + (ma_u_score.sword_defence + sum_cu + sum_su) + "(= (↑A)[♠defence] + Sum(↑♦) + Sum(↑♠))? <br/>→ <em>No, STAY.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      var cups = "cups_" + (cur.token + 1);

      if (temp.prev_past <= past) {
	var img;
	if (cur[cups].length > 0) {
	  img = make_cards_image(cur[cups]);
	} else {
	  img = temp.img_drawn;
	}
	temp.rect_cups = calc_minor_rect(cups, img);

	if (max != null) {
	  temp.max_card = cur[cups][max];
	  temp.img_max = make_card_image(temp.max_card, 0);
	  cur[cups] = game_view.model_next[cups];
	  game_view.draw_minor();
	}
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードと現在爻の最大のカップのカードを捨てます。", en: "Discard the drawn card and the max cup card of the current place."});
	if (temp.img_max) {
	  var img = temp.img_max;
	  var begin = {x: temp.rect_cups.x + temp.rect_cups.width / 2,
		       y: temp.rect_cups.y + temp.rect_cups.height / 2};
	  var end = game_view.anchor_discarded;

          var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded;

          var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past+= scene;
    }
    
    game_view.redraw();
    return false;
  },

  animate_lower_sword2 : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    var score = calc_card_score(cur.drawn);
    var upper = cur.token + 3;

    var sum_su = 0;
    var sum_cl = 0;
    var sum_cu = 0;

    for (var i = 0, l = cur.swords_upper; i < l.length; i++) {
      sum_su += calc_card_score(l[i]);
    }
    for (var i = 0, l = cur.coins_lower; i < l.length; i++) {
      sum_cl += calc_card_score(l[i]);
    }
    for (var i = 0, l = cur["coins_" + (upper + 1)];
	 i < l.length; i++) {
      sum_cu += calc_card_score(l[i]);
    }

    var max = null;
    var max_score = 0;
    for (var i = 0, l = cur["cups_" + (cur.token + 1)];
	 i < l.length; i++) {
      var s = calc_card_score(l[i]);
      if (s > max_score) {
	max = i;
	max_score = s;
      }
    }
	
    var ma_score = read_major_arcana(cur.board[cur.token]);
    var ma_u_score = read_major_arcana(cur.board[upper]);
    var ma = cur.board[cur.token];
    var ma_u = cur.board[upper];

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (temp.prev_past <= past) {
      if (cur.coins_lower.length > 0) {
	temp.img_coins_lower = make_cards_image(cur.coins_lower);
	temp.rect_coins_lower
	  = calc_minor_rect("coins_lower", temp.img_coins_lower);
      } else {
	temp.rect_coins_lower
	  = calc_minor_rect("coins_lower", temp.img_drawn);
      }
      if (cur["coins_" + (upper + 1)].length > 0) {
	temp.img_coins_upper = make_cards_image(cur["coins_" + (upper + 1)]);
	temp.rect_coins_upper
	  = calc_minor_rect("coins_" + (upper + 1), temp.img_coins_upper);
      } else {
	temp.rect_coins_upper
	  = calc_minor_rect("coins_" + (upper + 1), temp.img_drawn);
      }
      if (cur.swords_upper.length > 0) {
	temp.img_swords_upper = make_cards_image(cur.swords_upper);
	temp.rect_swords_upper
	  = calc_minor_rect("swords_upper", temp.img_swords_upper);
      } else {
	temp.rect_swords_upper
	  = calc_minor_rect("swords_upper", temp.img_drawn);
      }
      if (cur["cups_" + (cur.token + 1)].length > 0) {
	temp.img_cups = make_cards_image(cur["cups_" + (cur.token + 1)]);
	temp.rect_cups
	  = calc_minor_rect("cups_" + (cur.token + 1), temp.img_cups);
      } else {
	temp.rect_cups
	  = calc_minor_rect("cups" + (cur.token + 1), temp.img_drawn);
      }
    }

    if (cur.move_or_stay == "move") {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "動きます。", en: "Now, move the token."});
	temp.prev_past = time;
	return true;
      }
      past += scene;
      
      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (upper + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (upper + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      if (temp.prev_past <= past) {
	cur.coins_lower = [];
	cur.swords_upper = [];
	game_view.draw_minor();
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "上卦のスペースのソードと下卦のスペースのコインを捨てます。", en: "Discard the swords at the upper space and the coins at the lower space."});
	if (temp.img_coins_lower) {
	  var img = temp.img_coins_lower;
	  var begin = {x: temp.rect_coins_lower.x + temp.rect_coins_lower.width / 2,
		     y: temp.rect_coins_lower.y + temp.rect_coins_lower.height / 2};
	  var end = game_view.anchor_discarded;
          var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}
	if (temp.img_swords_upper) {
	  var img = temp.img_swords_upper;
	  var begin = {x: temp.rect_swords_upper.x + temp.rect_swords_upper.width / 2,
		      y: temp.rect_swords_upper.y + temp.rect_swords_upper.height / 2};
	  var end = game_view.anchor_discarded;
          var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたソードは上卦のスペースへ。", en: "Place the drawn sword onto the the upper space."});

	var img = temp.img_drawn;
	var begin = game_view.anchor_talon;
	var end = game_view.anchor_swords_upper;
        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);

	temp.prev_past = time;
	return true;
      }
      past += scene;

      if (temp.prev_past <= past) {
	cur.swords_upper = [cur.drawn];
	game_view.draw_minor();
      }
    } else {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "留まります。", en: "You chose the token to stay."});
	temp.prev_past = time;
	return true;
      }
      past += scene;

      if (temp.prev_past <= past) {
	cur["cups_" + (cur.token + 1)] = [];
	game_view.draw_minor();

	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたソードと現在爻のカップをすべて捨てます。", en: "Discard the drawn sword and all cups of the current place."});
	if (temp.img_cups) {
	  var img = temp.img_cups;
	  var begin = {x: temp.rect_cups.x + temp.rect_cups.width / 2,
		     y: temp.rect_cups.y + temp.rect_cups.height / 2};
	  var end = game_view.anchor_discarded;
          var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded;
          var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
    
    game_view.redraw();
    return false;
  },

  animate_lower_coin : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "下卦でコインのカードを引きました。<br/>順方向の比爻に動くか否かを計算します。", en: "You drew a coin card on lower trigram.<br/>Calculate wheter the token must move left or not."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past && setting.calc_screen) {
      game_view.draw_screen();
    }

    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "$♦ + (@A)[♦苦] &gt; (←A)[♦喜]?", en: "$♦ + (@A)[♦pain] &gt; (←A)[♦gain]?"});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    var score = calc_card_score(cur.drawn);

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "<em>" + score + "(= $♦)</em> + (@A)[♦苦] &gt; (←A)[♦喜]?", en: "<em>" + score + "(= $♦)</em> + (@A)[♦pain] &gt; (←A)[♦gain]?"});

      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText(score, anchor.x, anchor.y);
      ctx.strokeText(score, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    var ma = cur.board[cur.token];
    var ma_score = read_major_arcana(ma);

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♦) + <em>" + ma_score.coin_pain + "(= (@A)[♦苦])</em> &gt; (←A)[♦喜]?", en: "" + score + "(= $♦) + <em>" + ma_score.coin_pain + "(= (@A)[♦pain])</em> &gt; (←A)[♦gain]?"});

      var img = make_card_image(ma.card,
				(ma.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (cur.token + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma);
      if (time - past > 1000) {
	text = "♦" + ma_score.coin_pain + " ";
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    var ma_l = cur.board[cur.token + 1];
    var ma_l_score = read_major_arcana(ma_l);

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(= $♦) + " + ma_score.coin_pain + "(= (@A)[♦苦]) &gt; <em>" + ma_l_score.coin_gain + "(= (←A)[♦喜])</em>?", en: "" + score + "(= $♦) + " + ma_score.coin_pain + "(= (@A)[♦pain]) &gt; <em>" + ma_l_score.coin_gain + "(= (←A)[♦gain])</em>?"});

      var img = make_card_image(ma_l.card,
				(ma_l.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (cur.token + 1 + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma_l);
      if (time - past > 1000) {
	text = "♦ |" + ma_l_score.coin_gain;
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    if (cur.move_or_stay == "move") {
      scene = 1000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.coin_pain) + "(= $♦ + (@A)[♦苦]) &gt; " + ma_l_score.coin_gain + "(= (←A)[♦喜])? <br/>→ <em>大なり。動く。</em>", en: "" + (score + ma_score.coin_pain) + "(= $♦ + (@A)[♦pain]) &gt; " + ma_l_score.coin_gain + "(= (←A)[♦gain])? <br/>→ <em>Yes, MOVE.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      var left = cur.token + 1;

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (left + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (left + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      var upper = cur.token + 3;

      if (! temp.minor_rect) {
	var l = cur["coins_" + (upper + 1)];
	var img;
	if (l && l.length > 0) {
	  img = make_cards_image(l);
	} else {
	  img = temp.img_drawn;
	}
	temp.minor_rect = calc_minor_rect("coins_" + (upper + 1), img);
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードは応爻へ。", en: "Place the drawn card onto the upper place."});
	var img = temp.img_drawn;
	var begin = game_view.anchor_talon;
	var end = {x: temp.minor_rect.x + temp.minor_rect.width / 2,
		   y: temp.minor_rect.y + temp.minor_rect.height / 2};

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);

	temp.prev_past = time;
	return true;
      }
      past+= scene;
    } else {
      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.coin_pain) + "(= $♦ + (@A)[♦苦]) &gt; " + ma_l_score.coin_gain + "(= (←A)[♦喜])? <br/>→ <em>小なり。留まる。</em>", en: "" + (score + ma_score.coin_pain) + "(= $♦ + (@A)[♦pain]) &gt; " + ma_l_score.coin_gain + "(= (←A)[♦gain])? <br/>→ <em>No, STAY.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (! temp.minor_rect) {
	var l = cur["coins_lower"];
	var img;
	if (l && l.length > 0) {
	  img = make_cards_image(l);
	} else {
	  img = temp.img_drawn;
	}
	temp.minor_rect = calc_minor_rect("coins_lower", img);
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードは下卦のコインのスペースへ。", en: "Place the drawn card onto the lower coin space."});
	var img = temp.img_drawn;
	var begin = game_view.anchor_talon;
	var end = {x: temp.minor_rect.x + temp.minor_rect.width / 2,
		   y: temp.minor_rect.y + temp.minor_rect.height / 2};

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r);
	var y = Math.floor(begin.y + (end.y - begin.y) * r);
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);

	temp.prev_past = time;
	return true;
      }
      past+= scene;
    }
    
    game_view.redraw();
    return false;
  },

  animate_lower_cup : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "下卦でカップのカードを引きました。<br/>トークンは留まります。", en: "You drew a cup card on lower trigram.<br/>The token must stay."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (! temp.rect_cups) {
      var l = cur["cups_" + (cur.token + 1)];
      var img;
      if (l && l.length > 0) {
	img = make_cards_image(l);
      } else {
	img = temp.img_drawn;
      }
      temp.rect_cups = calc_minor_rect("cups_" + (cur.token + 1), img);
    }

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "引いたカードは現在爻のカップとします。", en: "Place the drawn cup card onto the current place."});
      var img = temp.img_drawn;
      var begin = game_view.anchor_talon;
      var end = {x: temp.rect_cups.x + temp.rect_cups.width / 2,
		 y: temp.rect_cups.y + temp.rect_cups.height / 2};

      var r = (time - past) / scene;
      var x = Math.floor(begin.x + (end.x - begin.x) * r);
      var y = Math.floor(begin.y + (end.y - begin.y) * r);
      x = Math.floor(x - img.width / 2);
      y = Math.floor(y - img.height / 2);
      ctx.drawImage(img, x, y);

      temp.prev_past = time;
      return true;
    }
    past+= scene;
    
    game_view.redraw();
    return false;
  },

  animate_lower_wand : function (time) {
    var cur = game_view.model_cur;
    var temp = game_view.animation_temp;
    var ctx = game_view.pane_animation.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    game_view.status_window.innerHTML = "";
    var past = 0;
    var scene;

    if (temp.prev_past == 0) {
      temp.img_drawn = make_card_image(cur.drawn, 0);
    }

    scene = 1000;
    if (time <= past + scene) {
      var img = temp.img_drawn;
      var r = Math.floor(((time - past) / scene) * 5);
      var img2 = make_card_image("B" + r, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.drawImage(img2, x, y);

      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      var ctx2 = game_view.pane_drawn.getContext('2d');
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx2.drawImage(img, x, y);
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "下卦でワンドのカードを引きました。<br/>逆方向の比爻に動くか否かを計算します。", en: "You drew a wand card on lower trigram.<br/>Calculate wheter the token can move right or not."});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past && setting.calc_screen) {
      game_view.draw_screen();
    }

    var score = calc_card_score(cur.drawn);
    var right = (cur.token - 1 + 6) % 6;

    var ma_score = read_major_arcana(cur.board[cur.token]);
    var ma_r_score = read_major_arcana(cur.board[right]);

    var min = null;
    var min_score = 15;
    var minimum_score = 15;

    for (var i = 0; i < cur["cups_" + (cur.token + 1)].length; i++) {
      var sc = calc_card_score(cur["cups_" + (cur.token + 1)][i]);
      if (score + ma_score.wand_lower > sc + ma_r_score.cup_lower) {
	if (sc < min_score) {
	  min = i;
	  min_score = sc;
	}
      }
      if (sc < minimum_score) {
	minimum_score = sc;
      }
    }
    if (minimum_score == 15) {
      minimum_score = 0;
    }
    if (min == null) {
      min_score = minimum_score;
    }

    var ma = cur.board[cur.token];
    var ma_r = cur.board[right];

    scene = 1000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "$♣ + (@A)[♣下流] &gt; Suitable(@♥(要)) + (→A)[♥下流]?", en: "$♣ + (@A)[♣lower] &gt; Suitable(@♥(need)) + (→A)[♥lower]?"});
      temp.prev_past = time;
      return true;
    }
    past += scene;

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (temp.prev_past <= past) {
      if (cur["cups_" + (cur.token + 1)].length > 0) {
	temp.img_cups = make_cards_image(cur["cups_" + (cur.token + 1)]);
	temp.rect_cups
	  = calc_minor_rect("cups_" + (cur.token + 1), temp.img_cups);
      } else {
	temp.rect_cups
	  = calc_minor_rect("cups_" + (cur.token + 1), temp.img_drawn);
      }
    }

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "<em>" + score + "(=$♣)</em> + (@A)[♣下流] &gt; Suitable(@♥(要)) + (→A)[♥下流]?", en: "<em>" + score + "(= $♣)</em> + (@A)[♣lower] &gt; Suitable(@♥(need)) + (→A)[♥lower]?"});
      var img = temp.img_drawn;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText(score, anchor.x, anchor.y);
      ctx.strokeText(score, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(=$♣) + <em>" + ma_score.wand_lower + "(= (@A)[♣下流])</em> &gt; Suitable(@♥(要)) + (→A)[♥下流]?", en: "" + score + "(= $♣) + <em>" + ma_score.wand_lower + "(= (@A)[♣lower])</em> &gt; Suitable(@♥(need)) + (→A)[♥lower]?"});
      var img = make_card_image(ma.card,
				(ma.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (cur.token + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma);
      if (time - past > 1000) {
	text = "♣ ∽" + ma_score.wand_lower;
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(=$♣) + " + ma_score.wand_lower + "(= (@A)[♣下流]) &gt; <em>" + min_score + "(= Suitable(@♥(要)))</em> + (→A)[♥下流]?", en: "" + score + "(= $♣) + " + ma_score.wand_lower + "(= (@A)[♣lower]) &gt; <em>" + min_score + "(= Suitable(@♥(need)))</em> + (→A)[♥lower]?"});
      var anchor = {x: Math.floor((temp.rect_cups.x
				   + temp.rect_cups.width / 2)),
		    y: Math.floor((temp.rect_cups.y
				   + temp.rect_cups.height / 2))};
      if (min != null) {
	var img = make_card_image(cur["cups_" + (cur.token + 1)][min], 0);

	var x = Math.floor(anchor.x - img.width / 2);
	var y = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x, y);
	ctx.beginPath();
	ctx.rect(x, y, img.width, img.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
	ctx.fill();
      }
      ctx.fillStyle = 'white';
      var text = min_score;
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    scene = 2000;
    if (time <= past + scene) {
      game_view.status_window.innerHTML = L({ja: "" + score + "(=$♣) + " + ma_score.wand_lower + "(= (@A)[♣下流]) &gt; " + min_score + "(= Suitable(@♥(要))) + <em>" + ma_r_score.cup_lower + "(= (→A)[♥下流])</em>?", en: "" + score + "(= $♣) + " + ma_score.wand_lower + "(= (@A)[♣lower]) &gt; " + min_score + "(= Suitable(@♥(need))) + <em>" + ma_r_score.cup_lower + "(= (→A)[♥lower])</em>?"});
      var img = make_card_image(ma_r.card,
				(ma_r.upright)? 0 : Math.PI);
      var anchor = game_view["anchor_" + (right + 1)];
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
      ctx.beginPath();
      ctx.rect(x, y, img.width, img.height);
      ctx.closePath()
      ctx.fillStyle = "rgba(155, 187, 89, 0.9)";
      ctx.fill();
      ctx.fillStyle = 'white';
      var text = read_major_arcana_string(ma_r);
      if (time - past > 1000) {
	text = "♥ ∽" + ma_r_score.cup_lower;
      }
      ctx.fillText(text, anchor.x, anchor.y);
      ctx.strokeText(text, anchor.x, anchor.y);
      
      temp.prev_past = time;
      return true;
    }
    past += scene;

    if (temp.prev_past <= past) {
      game_view.clear_screen();
    }

    if (cur.move_or_stay == "move") {
      scene = 1000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.wand_lower) + "(=$♣ + (@A)[♣下流]) &gt; " + (min_score + ma_r_score.cup_lower) + "(= Suitable(@♥(要)) + (→A)[♥下流])?<br/>→ <em>大なり。動く。</em>", en: "" + (score + ma_score.wand_lower) + "(= $♣ + (@A)[♣lower]) &gt; " + (min_score + ma_r_score.cup_lower) + "(= Suitable(@♥(need)) + (→A)[♥lower])?<br/>→ <em>Yes, MOVE.</em>"});
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	var img = game_view.img_token;
	var begin = game_view["anchor_" + (cur.token + 1)];
	var end = game_view["anchor_" + (right + 1)];

        var r = (time - past) / scene;
	var x = Math.floor(begin.x + (end.x - begin.x) * r
			   + setting.card_width * 0.7 * Math.sin(Math.PI * r));
	var y = Math.floor(begin.y + (end.y - begin.y) * r
			   - setting.card_height * 0.7 * Math.sin(Math.PI * r));
	x = Math.floor(x - img.width / 2);
	y = Math.floor(y - img.height / 2);
	ctx.drawImage(img, x, y);
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_token.getContext('2d');
	var img = game_view.img_token;
	var anchor = game_view["anchor_" + (right + 1)];
	ctx2.drawImage(img,
		       Math.floor(anchor.x - img.width / 2),
		       Math.floor(anchor.y - img.height / 2));
      }

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
	temp.img_min = make_card_image(cur["cups_" + (cur.token + 1)][min], 0);
	cur["cups_" + (cur.token + 1)] = game_view.model_next["cups_" + (cur.token + 1)];
	game_view.draw_minor();
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードと条件を満たす最小の現在爻のカップを捨てます。", en: "Discard the drawn wand and the minimum cup of the current place which satisfies the condition."});
	if (1) {
	  var img = temp.img_min;
	  var begin = {x: temp.rect_cups.x + temp.rect_cups.width / 2,
		       y: temp.rect_cups.y + temp.rect_cups.height / 2};
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded 
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    } else {
      scene = 2000;
      if (time <= past + scene) {
	if (cur["cups_" + (cur.token + 1)].length > 0) {
	  game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.wand_lower) + "(=$♣ + (@A)[♣下流]) &gt; " + (min_score + ma_r_score.cup_lower) + "(= Suitable(@♥(要)) + (→A)[♥下流])?<br/>→ <em>小なり。留まる。</em>", en: "" + (score + ma_score.wand_lower) + "(= $♣ + (@A)[♣lower]) &gt; " + (min_score + ma_r_score.cup_lower) + "(= Suitable(@♥(need)) + (→A)[♥lower])?<br/>→ <em>No, STAY.</em>"});
	} else {
	  game_view.status_window.innerHTML = L({ja: "" + (score + ma_score.wand_lower) + "(=$♣ + (@A)[♣下流]) &gt; " + (min_score + ma_r_score.cup_lower) + "(= Suitable(@♥(要)) + (→A)[♥下流])?<br/>→ <em>現在爻にカップなし。留まる。</em>", en: "" + (score + ma_score.wand_lower) + "(= $♣ + (@A)[♣lower]) &gt; " + (min_score + ma_r_score.cup_lower) + "(= Suitable(@♥(need)) + (→A)[♥lower])?<br/>→ <em>There is no cup at the current place. STAY.</em>"});
	}
	temp.prev_past = time;
	return true;
      }
      past+= scene;

      if (temp.prev_past <= past) {
	var ctx2 = game_view.pane_drawn.getContext('2d');
	ctx2.clearRect(0, 0, setting.window_width, setting.window_height);
      }

      scene = 2000;
      if (time <= past + scene) {
	game_view.status_window.innerHTML = L({ja: "引いたカードを捨てます。", en: "Discard the drawn wand."});
	if (1) {
	  var img = temp.img_drawn;
	  var begin = game_view.anchor_talon;
	  var end = game_view.anchor_discarded;
	  var r = (time - past) / scene;
	  var x = Math.floor(begin.x + (end.x - begin.x) * r);
	  var y = Math.floor(begin.y + (end.y - begin.y) * r);
	  x = Math.floor(x - img.width / 2);
	  y = Math.floor(y - img.height / 2);
	  ctx.drawImage(img, x, y);
	}

	temp.prev_past = time;
	return true;
      }
      past += scene;
    }
    
    game_view.redraw();
    return false;
  },

  draw_choose_move_or_stay : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (1) {
      var ctx = game_view.pane_drawn.getContext('2d');
      var img = make_card_image(cur.drawn, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
    }

    var ctx = game_view.pane_status.getContext('2d');
    ctx.font = setting.dialog_window_font;

    var x = game_view.anchor_5.x;
    var y = game_view.anchor_purpose.y;
    var text_move = L({ja: "動く", en: "MOVE"});
    var text_stay = L({ja: "留まる", en: "STAY"});
    var w_move = ctx.measureText(text_move).width;
    var w_stay = ctx.measureText(text_stay).width;
    var h = setting.dialog_window_height;
    var rect_move = {x: x - 8 - 8 - 8 - w_move,
		     y: Math.floor(y - h/2),
		     width: 16 + w_move,
		     height: h};
    var rect_stay = {x: x + 8,
		     y: Math.floor(y - h/2),
		     width: 16 + w_stay,
		     height: h};
    ctx.beginPath();
    ctx.rect(rect_move.x, rect_move.y,
	     rect_stay.x + rect_stay.width - rect_move.x,
	     rect_stay.y + rect_stay.height - rect_move.y);
    ctx.closePath();
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fill();

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    ctx.fillText(text_move, Math.floor(rect_move.x + 8 + w_move / 2), y);
    ctx.strokeText(text_move, Math.floor(rect_move.x + 8 + w_move / 2), y);
    ctx.fillText(text_stay, Math.floor(rect_stay.x + 8 + w_stay / 2), y);
    ctx.strokeText(text_stay, Math.floor(rect_stay.x + 8 + w_stay / 2), y);

    var control_choose = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	ctx.beginPath()
	ctx.rect(rect.x, rect.y, rect.width, rect.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.7)";
	ctx.fill();
      }
      if (ev == "click") {
	cur.move_or_stay = this.choice;
	game_view.chose_move_or_stay();
      }
    }

    var cm = {x: rect_move.x, y: rect_move.y,
	      width: rect_move.width, height: rect_move.height,
	      func: bind(control_choose, {rect: rect_move, choice: "move"})};
    game_view.controller_click_array.push(cm);
    game_view.controller_move_array.push(cm);

    var cs = {x: rect_stay.x, y: rect_stay.y,
	      width: rect_stay.width, height: rect_stay.height,
	      func: bind(control_choose, {rect: rect_stay, choice: "stay"})};
    game_view.controller_click_array.push(cs);
    game_view.controller_move_array.push(cs);

    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }

    game_view.status_window.innerHTML = L({ja: "動くか留まるか決めてください。", en: "Decide whether the token should move or stay."});
  },

  chose_move_or_stay : function () {
    game_view.clear_animation();
    if (1) {
      var ctx = game_view.pane_status.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    }
    var cur = game_view.model_cur;

    if (1) {
      var ctx = game_view.pane_drawn.getContext('2d');
      var img = make_card_image(cur.drawn, 0);
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      ctx.drawImage(img, x, y);
    }

    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "wait_draw_card";
    next.drawn = null;

    if (cur.move_or_stay == "move") {
      next.discarded = cur.discarded.concat(cur.swords_upper,
					    cur.coins_lower);
      next.swords_upper = [cur.drawn];
      next.coins_lower = [];
      next.token = cur.token + 3;
      if (typeof(setting.rule_replacement) != "number"
	  || setting.rule_replacement != 0) {
	next.replacements = 0
	next.replacements_coins_lower = 0
	next.state = "choose_replacement";
      }
    } else {
      next.discarded = cur.discarded.concat(cur["cups_" + (cur.token + 1)],
					   [cur.drawn]);
      next["cups_" + (cur.token + 1)] = [];
    }

    var c = {x: 0, y: 0,
	     width: setting.window_width, height: setting.window_height,
	     func: function () {
	       game_view.lf.reset_animation();
	       game_view.redraw();
	     }
	    };
    game_view.controller_click_array = [c];
    game_view.controller_move_array = [];

    game_view.animation_temp = {prev_past: 0};
    game_view.lf.set_animation(game_view.animate_lower_sword2);
  },

  draw_choose_replacement : function () {
    game_view.clear_animation();
    game_view.clear_screen();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }

    var control_draw_card = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	var img = game_view.img_hilit_talon;
	var anchor = game_view.anchor_talon;
	var x1 = Math.floor(anchor.x - img.width / 2);
	var y1 = Math.floor(anchor.y - img.height / 2);
	ctx.drawImage(img, x1, y1);
      }
      if (ev == "click") {
	game_view.drew_card();
      }
    }

    if (1) {
      var img = game_view.img_hilit_talon;
      var anchor = game_view.anchor_talon;
      var x = Math.floor(anchor.x - img.width / 2);
      var y = Math.floor(anchor.y - img.height / 2);
      var c = {x: x, y: y, width: img.width, height: img.height,
	       func: bind(control_draw_card,
			  {rect: {x: x, y: y, width: img.width,
				  height: img.height}})};
      game_view.controller_click_array.push(c);
      game_view.controller_move_array.push(c);
    }


    var control_choose_place = function (ev, x, y) {
      var rect = this.rect;
      var hilit = this.hilit;
      var name = this.name;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	var img = hilit;
	ctx.drawImage(img, rect.x, rect.y);
      }
      if (ev == "click") {
	game_view.chose_replacement(name);
      }
    }

    var replacable = false;
    for (var i = 0, l = ["swords_upper", "coins_lower",
			 "coins_6", "coins_5", "coins_4",
			 "cups_3", "cups_2", "cups_1"];
	 i < l.length; i++) {
      if (l[i] == "swords_upper" && setting.rule_cross_border != "all") {
	continue;
      }
      if (cur[l[i]].length == 0) {
	continue;
      }
      replacable = true;
      var img = make_cards_image(cur[l[i]]);
      var hilit = make_overlay_image(img);
      var rect = calc_minor_rect(l[i], img);

      var c = {x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	       func: bind(control_choose_place,
			  {rect: rect, hilit: hilit, name: l[i]})};
      game_view.controller_click_array.push(c);
      game_view.controller_move_array.push(c);
    }

    game_view.controller_click_array.reverse();
    game_view.controller_move_array.reverse();


    if (! replacable) {
      var next = {};
      game_view.model_next = next;
      for (var n in cur) {
	next[n] = cur[n];
      }
      next.state = "wait_draw_card";
      next.drawn = null;
      game_view.redraw();
    } else {
      var repl_char = setting.rule_replacement;
      if (setting.rule_replacement == "infinity") {
	repl_char = "∞";
      }
      var repl_char2 = setting.rule_replacement_coins_lower;
      if (setting.rule_replacement_coins_lower == "infinity") {
	repl_char2 = "∞";
      }
      game_view.status_window.innerHTML = L({ja: "戦乱置換: " + cur.replacements + "/" + repl_char + " (うち↓♦へ: " + cur.replacements_coins_lower + "/" + repl_char2 + ")。置換するカードを選んで下さい。置換しない場合は、山からカードを引いてください。", en: "War Replacement: " + cur.replacements + "/" + repl_char + " (to ↓♦: " + cur.replacements_coins_lower + "/" + repl_char2 + "). Please choose a card to replace or draw a card from the talon without replacement."});
    }
  },

  chose_replacement : function (name) {
    game_view.clear_animation();

    var cur = game_view.model_cur;
    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "choose_replacement_card";
    next.chosen_place = name;
    next.drawn = null;
    game_view.redraw();
  },

  draw_choose_replacement_card : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    game_view.draw_screen();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (1) {
      var func = function (ev, x, y) {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	if (ev == "click") {
	  var next = {};
	  game_view.model_next = next;
	  for (var n in cur) {
	    next[n] = cur[n];
	  }
	  next.state = "choose_replacement";
	  next.chosen_place = null;
	  game_view.redraw();
	}
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
      game_view.controller_click_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }

    var cards = cur[cur.chosen_place];
    var w = 10;
    var h = 3;
    if (cards.length / w > h) {
      h = Math.ceil(cards.length / w);
    }

    var card_hilit = make_overlay_image(make_card_image("S01", 0));

    var control_choose_card = function (ev, x, y) {
      var rect = this.rect;
      var hilit = this.hilit;
      var card = this.card;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	var img = hilit;
	ctx.drawImage(img, rect.x, rect.y);
      }
      if (ev == "click") {
	game_view.chose_replacement_card(card);
      }
    }

    var ctx = game_view.pane_animation.getContext('2d');
    for (var i = 0; i < cards.length; i++) {
      var img = make_card_image(cards[i], 0);
      var cx = i % w;
      var cy = Math.floor(i / w);
      var x = game_view.window_left + ((game_view.window_right - game_view.window_left - setting.card_width) / (w - 1)) * cx;
      var y = game_view.window_top + ((game_view.window_bottom - game_view.window_top - setting.card_height) / (h - 1)) * cy;
      var rect = {x: x, y: y, width: img.width, height: img.height};
      ctx.drawImage(img, x, y);
      
      var c = {x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	       func: bind(control_choose_card,
			  {rect: rect, hilit: card_hilit, card: cards[i]})};
      game_view.controller_click_array.push(c);
      game_view.controller_move_array.push(c);
    }

    game_view.controller_click_array.reverse();
    game_view.controller_move_array.reverse();

    game_view.status_window.innerHTML = L({ja: "置換するカードを選んで下さい。", en: "Please choose a card to replace."});
  },

  chose_replacement_card : function (card) {
    game_view.clear_animation();
    game_view.clear_screen();

    var cur = game_view.model_cur;
    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    next.state = "choose_replacement_place";
    next.chosen_card = card;
    var l = next[next.chosen_place];
    var r = [];
    for (i = 0; i < l.length; i++) {
      if (l[i] != card) {
	r.push(l[i]);
      }
    }
    next[next.chosen_place] = r;
    next.drawn = null;
    game_view.redraw();
  },

  draw_choose_replacement_place : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    var card_img = make_card_image(cur.chosen_card, 0);

    if (1) {
      var ctx = game_view.pane_control.getContext('2d');
      var anchor = game_view.anchor_talon;
      var x1 = Math.floor(anchor.x - (card_img.width / 2));
      var y1 = Math.floor(anchor.y - (card_img.height / 2));
      ctx.drawImage(card_img, x1, y1);
    }

    if (1) {
      var func = function (ev, x, y) {
	var card_img = this.card_img;
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	var x1 = Math.floor(x - (card_img.width / 2));
	var y1 = Math.floor(y - (card_img.height / 2));
	if (x1 < 0) {
	  x1 = 0;
	}
	if (x1 + card_img.width > setting.window_width) {
	  x1 = setting.window_width - card_img.width;
	}
	if (y1 < 0) {
	  y1 = 0;
	}
	if (y1 + card_img.height > setting.window_height) {
	  y1 = setting.window_height - card_img.height;
	}
	ctx.drawImage(card_img, x1, y1);

	if (ev == "click") {
	  var next = {};
	  game_view.model_next = next;
	  for (var n in cur) {
	    next[n] = cur[n];
	  }
	  next.state = "choose_replacement";
	  next[next.chosen_place].push(next.chosen_card);
	  next.chosen_place = null;
	  next.chosen_card = null;
	  game_view.redraw();
	}
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height,
	       func: bind(func, {card_img: card_img})});
      game_view.controller_click_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height,
	       func: bind(func, {card_img: card_img})});
    }


    var control_choose_place = function (ev, x, y) {
      var rect = this.rect;
      var hilit = this.hilit;
      var card_img = this.card_img
      var name = this.name;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	var img = hilit;
	ctx.drawImage(img, rect.x, rect.y);
      }
      var x1 = Math.floor(x - (card_img.width / 2));
      var y1 = Math.floor(y - (card_img.height / 2));
      if (x1 < 0) {
	x1 = 0;
      }
      if (x1 + card_img.width > setting.window_width) {
	x1 = setting.window_width - card_img.width;
      }
      if (y1 < 0) {
	y1 = 0;
      }
      if (y1 + card_img.height > setting.window_height) {
	y1 = setting.window_height - card_img.height;
      }
      ctx.drawImage(card_img, x1, y1);
      if (ev == "click") {
	game_view.chose_replacement_place(name);
      }
    }

    for (var i = 0, l = ["swords_upper", "coins_lower",
			 "coins_6", "coins_5", "coins_4",
			 "cups_3", "cups_2", "cups_1", "discarded"];
	 i < l.length; i++) {
      if (l[i] == "swords_upper" && setting.rule_cross_border != "all") {
	continue;
      }
      if (setting.rule_cross_border == "none"
	  && ((cur.chosen_place.match(/^coins_/) && ! l[i].match(/^coins_/))
	      || (cur.chosen_place.match(/^cups_/) && ! l[i].match(/^cups_/)))) {
	continue;
      }
      if (setting.rule_cross_border == "cups_and_coins"
	  && (! (l[i].match(/^coins_/) || l[i].match(/^cups_/)))) {
	continue;
      }
      if (l[i] == "coins_lower"
	  && setting.rule_replacement_coins_lower != "infinity"
	  && (cur.replacements_coins_lower
	      >= setting.rule_replacement_coins_lower)) {
	continue;
      }
      var hilit;
      var rect;
      if (l[i] == "discarded") {
	hilit = make_overlay_image(game_view.img_discarded);
	var anchor = game_view.anchor_discarded;
	var y = Math.floor(anchor.y - (hilit.height / 2));
	if ((y + hilit.height) > game_view.window_bottom) {
	  y = game_view.window_bottom - hilit.height;
	}
	var x = Math.floor(anchor.x - (hilit.width / 2))
	rect = {x: x, y: y, width: hilit.width, height: hilit.height};
      } else {
	if (cur[l[i]].length == 0) {
	  hilit = make_overlay_image(make_cards_image(["S01", "S02", "S03"]));
	} else {
	  hilit = make_overlay_image(make_cards_image(cur[l[i]]));
	}
	var rect = calc_minor_rect(l[i], hilit);
      }
      var c = {x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	       func: bind(control_choose_place,
			  {rect: rect, hilit: hilit, name: l[i],
			   card_img: card_img})};
      game_view.controller_click_array.push(c);
      game_view.controller_move_array.push(c);
    }

    game_view.controller_click_array.reverse();
    game_view.controller_move_array.reverse();

    game_view.status_window.innerHTML = L({ja: "カードを置いて下さい。", en: "Please place the card."});
  },

  chose_replacement_place : function (place) {
    game_view.clear_animation();

    var cur = game_view.model_cur;
    var next = {};
    game_view.model_next = next;
    for (var n in cur) {
      next[n] = cur[n];
    }
    if (place != cur.chosen_place) {
      next.replacements ++;
      if (place == "coins_lower") {
	next.replacements_coins_lower ++;
      }
    }
    if (typeof(setting.rule_replacement) != "number"
	|| next.replacements < setting.rule_replacement) {
      next.state = "choose_replacement";
    } else {
      next.state = "wait_draw_card";
    }
    next[place].push(next.chosen_card);
    next.chosen_card = null;
    next.chosen_place = null;
    next.drawn = null;
    game_view.redraw();
  },

  draw_game_end : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (1) {
      game_view.draw_screen();
    }

    var x = Math.floor(setting.window_width / 2);
    var y1 = Math.floor(setting.window_height / 2) - setting.dialog_window_height;
    var y2 = Math.floor(setting.window_height / 2) + setting.dialog_window_height;

    var text1;
    if (cur.win_or_lose == "win") {
      text1 = L({ja: "勝ち", en: "YOU WIN"});
      game_view.status_window.innerHTML = L({ja: "あなたの勝ちです。", en: "You win the game."});
    } else {
      text1 = L({ja: "負け", en: "YOU LOSE"});
      game_view.status_window.innerHTML = L({ja: "あなたの負けです。", en: "You lose the game."});
    }
    var text2 = L({ja: "タイトルに戻ります。", en: "Go back to the title."});

    var ctx = game_view.pane_status.getContext('2d');

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    ctx.fillText(text1, x, y1);
    ctx.strokeText(text1, x, y1);

    var w = ctx.measureText(text2).width;
    var h = setting.dialog_window_height;
    var rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y2 - h / 2),
		width: w + 8 * 2, height: h};
    ctx.fillText(text2, x, y2);
    ctx.strokeText(text2, x, y2);

    var control_goto_title = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	ctx.beginPath()
	ctx.rect(rect.x, rect.y, rect.width, rect.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.7)";
	ctx.fill();
      }
      if (ev == "click") {
	game_view.model_cur = {state: "title"};
	game_view.redraw();
      }
    }

    var c = {x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_goto_title, {rect: rect})};
    game_view.controller_click_array.push(c);
    game_view.controller_move_array.push(c);

    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }
  },

  draw_game_end_0 : function () {
    game_view.clear_animation();
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];

    game_view.draw_minor();
    game_view.draw_token();
    game_view.draw_rest_talon();

    var cur = game_view.model_cur;
    game_view.model_next = null;

    if (1) {
      game_view.draw_screen();
    }

    game_view.status_window.innerHTML = L({ja: "設定の「終了カードの繰り返し」が 0 または数値でないため、ここで終了します。", en: "Go back to the title, because the option \"Terminal Card Appears\" is 0 or not a number."});

    var x = Math.floor(setting.window_width / 2);
    var y1 = Math.floor(setting.window_height / 2) - setting.dialog_window_height;
    var y2 = Math.floor(setting.window_height / 2) + setting.dialog_window_height;

    var text2 = L({ja: "タイトルに戻ります。", en: "Go back to the title."});

    var ctx = game_view.pane_status.getContext('2d');

    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    var w = ctx.measureText(text2).width;
    var h = setting.dialog_window_height;
    var rect = {x: Math.floor(x - w / 2) - 8, y: Math.floor(y2 - h / 2),
		width: w + 8 * 2, height: h};
    ctx.fillText(text2, x, y2);
    ctx.strokeText(text2, x, y2);

    var control_goto_title = function (ev, x, y) {
      var rect = this.rect;
      var ctx = game_view.pane_control.getContext('2d');
      ctx.clearRect(0, 0, setting.window_width, setting.window_height);
      if (x != null && y != null
	  && x >= rect.x && x < rect.x + rect.width
	  && y >= rect.y && y < rect.y + rect.height) {
	ctx.beginPath()
	ctx.rect(rect.x, rect.y, rect.width, rect.height);
	ctx.closePath()
	ctx.fillStyle = "rgba(155, 187, 89, 0.7)";
	ctx.fill();
      }
      if (ev == "click") {
	game_view.model_cur = {state: "title"};
	game_view.redraw();
      }
    }

    var c = {x: rect.x, y: rect.y, width: rect.width, height: rect.height,
	     func: bind(control_goto_title, {rect: rect})};
    game_view.controller_click_array.push(c);
    game_view.controller_move_array.push(c);

    if (1) {
      var func = function () {
	var ctx = game_view.pane_control.getContext('2d');
	ctx.clearRect(0, 0, setting.window_width, setting.window_height);
	return true;
      }
      game_view.controller_move_array
	.push({x: 0, y: 0, width: setting.window_width,
	       height: setting.window_height, func: func});
    }
  },

  draw_board : function () {
    var purpose = game_view.model_cur.purpose;
    var purpose_degree = game_view.model_cur.purpose_degree;
    var board = game_view.model_cur.board;
    var ctx = game_view.pane_board.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    
    for (var i = 0; i < 6; i++) {
      var anchor = game_view["anchor_" + (i + 1)];
      var card = board[i].card;
      var rotation = 0;
      if (! board[i].upright) {
	rotation = Math.PI;
      }
			
      var img = make_card_image(card, rotation);
      ctx.drawImage(img,
		    Math.floor(anchor.x - (img.width / 2)),
		    Math.floor(anchor.y - (img.height / 2)));
    }

    if (purpose) {
      var rot;
      if (purpose_degree == null) {
	rot = 0;
      } else if (purpose_degree == "whirl") {
	rot = Math.PI / 2;
      } else if (purpose_degree == "eclipse") {
	rot = 3 * Math.PI / 2;
      }
      var anchor = game_view.anchor_purpose;
      var img = make_card_image(purpose, rot);
      var x = Math.floor(anchor.x - (img.width / 2));
      var y = Math.floor(anchor.y - (img.height / 2));
      if (x < game_view.window_left) {
	x = game_view.window_left;
      }
      ctx.drawImage(img, x, y);
    } else {
      var anchor = game_view.anchor_purpose;
      var img = make_cards_image(["A13", "A00"]);
      ctx.drawImage(img,
		    Math.floor(anchor.x - (img.width / 2)),
		    Math.floor(anchor.y - (img.height / 2)));
    }
    
    if (1) {
      var anchor = game_view.anchor_talon;
      var img = game_view.img_talon;
      ctx.drawImage(img,
		    Math.floor(anchor.x - (img.width / 2)),
		    Math.floor(anchor.y - (img.height / 2)));
    }

    if (1) {
      var anchor = game_view.anchor_discarded;
      var img = game_view.img_discarded;
      var y = Math.floor(anchor.y - (img.height / 2));
      if ((y + img.height) > game_view.window_bottom) {
	y = game_view.window_bottom - img.height;
      }
      ctx.drawImage(img,
		    Math.floor(anchor.x - (img.width / 2)),
		    y);
    }
  },

  draw_minor : function () {
    var ctx = game_view.pane_minor.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    for (var i = 0, l = ["swords_upper", "coins_lower",
			 "coins_6", "coins_5", "coins_4",
			 "cups_3", "cups_2", "cups_1"];
	 i < l.length; i++) {
      var cards = game_view.model_cur[l[i]];
      if (cards && cards.length > 0) {
	var img = make_cards_image(cards);
	var rect = calc_minor_rect(l[i], img);
	ctx.drawImage(img, rect.x, rect.y);
      }
    }
  },

  draw_rest_talon : function () {
    var ctx = game_view.pane_rest_talon.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    var num = game_view.model_cur.talon.length;
    var x = game_view.anchor_talon.x;
    var y = game_view.anchor_talon.y;
    if (game_view.img_talon.height > setting.card_height) {
      y = Math.floor(y - game_view.img_talon.height / 2
		     - setting.dialog_window_height / 2);
    } else {
      y = Math.floor(y - setting.card_height / 2
		     - setting.dialog_window_height / 2);
    }
    ctx.font = setting.dialog_window_font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    ctx.fillText(num, x, y);
    ctx.strokeText(num, x, y);
  },

  draw_token : function () {
    var ctx = game_view.pane_token.getContext('2d');
    ctx.clearRect(0, 0, setting.window_width, setting.window_height);
    var img = game_view.img_token;
    var anchor = game_view["anchor_" + (game_view.model_cur.token + 1)];
    var x = Math.floor(anchor.x - img.width / 2);
    var y = Math.floor(anchor.y - img.height / 2);
    ctx.drawImage(img, x, y);
  },

  draw_screen : function () {
    game_view.pane_screen.style.display = "block";
  },

  clear_screen : function () {
    game_view.pane_screen.style.display = "none";
  },

  clear_animation : function () {
    game_view.animation_temp = {};
    for (var i = 0, l = ["pane_control", "pane_animation", "pane_drawn"];
	 i < l.length; i++) {
      var pane = game_view[l[i]];
      var ctx = pane.getContext('2d');
      ctx.clearRect(0, 0, pane.width, pane.height);
    }
    game_view.clear_screen();
  },

  clear_all : function () {
    game_view.controller_move_array = [];
    game_view.controller_click_array = [];
    game_view.status_window.style.display = "none";
    game_view.setting_window.style.display = "none";
    game_view.animation_temp = {};
    for (var i = 0; i < game_view.panes.length; i++) {
      var pane = game_view[game_view.panes[i]];
      var ctx = pane.getContext('2d');
      ctx.clearRect(0, 0, pane.width, pane.height);
    }
    game_view.pane_screen.style.display = "none";
    if (1) {
      var ctx2 = game_view.pane_screen.getContext('2d');
      ctx2.beginPath();
      ctx2.rect(0, 0, setting.window_width, setting.window_height);
      ctx2.closePath()
      ctx2.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx2.fill();
    }
  }
};

function reload_images (callback) {
  if (current_cards && current_cards == setting.cards) {
    callback();
    return;
  }

  var div = game_view.main_window;
  var ad = game_view.ad_area;

  div.innerHTML = "";

  document.body.style.background = setting.page_background;

  div.style.position = "absolute";
  div.style.width = "" + setting.window_width + "px";
  div.style.height = "" + setting.window_height + "px";
//  div.style.border = "solid 2px black";
  div.style.background = setting.window_background;
  if (ad) {
    ad.style.position = "absolute";
    ad.style.width = "100%";
    ad.style.left = "0px";
  }

  window.onresize = function () {
    var div = game_view.main_window;
    var ad = game_view.ad_area;
    var iw = window.innerWidth || document.body.clientWidth;
    var ih = window.innerHeight || document.body.clientHeight;
    if (iw > setting.window_width) {
      div.style.left = "" + Math.floor((iw - setting.window_width) / 2) + "px";
    } else {
      div.style.left = "0px";
    }
    if (ad) {
      if (iw > setting.window_width) {
	ad.style.width = "100%";
      } else {
	ad.style.width = "" + setting.window_width + "px";
      }
    }
    if (ad) {
      var ah = (ad.innerHeight || ad.clientHeight) + 10;
      if (ih > setting.window_height + ah) {
	div.style.top = "" + Math.floor((ih - setting.window_height - ah) / 2) + "px";
	ad.style.top = "" + (Math.floor((ih - setting.window_height - ah) / 2)
			     + setting.window_height + 10) + "px";
	ad.style.display = "block";
      } else {
	div.style.top = "0px";
	ad.style.top = "" + (setting.window_height + 10) + "px";
      }
    } else {
      if (ih > setting.window_height) {
	div.style.top = "" + Math.floor((ih - setting.window_height) / 2) + "px";
      } else {
	div.style.top = "0px";
      }
    }
  }
  window.onresize();

  game_view.panes = [];
  for (var i = 0, l = [["pane_control", 100],
		       ["pane_temp", 99],
		       ["pane_dialog", 60],
		       ["pane_animation", 50],
		       ["pane_status", 20],
		       ["pane_screen", 15],
		       ["pane_rest_talon", 14],
		       ["pane_drawn", 11],
		       ["pane_token", 10],
		       ["pane_minor", 2],
		       ["pane_board", 1]];
       i < l.length; i++) {
    var n = l[i][0];
    var z = l[i][1];
    
    var w = document.createElement('canvas');
    w.style.position = "absolute";
    w.style.top = "0px";
    w.style.left = "0px";
    w.width = setting.window_width;
    w.height = setting.window_height;
    div.appendChild(w);
    w.style.zIndex = z;

    game_view[n] = w;
    game_view.panes.push(n);
  }
  game_view.pane_temp.style.display = "none";

  game_view.window_top = 4;
  game_view.window_bottom = setting.window_height - setting.status_window_height - 4;
  game_view.window_left = 4;
  game_view.window_right = setting.window_width - 4;
  
  for (var i = 0, l = ["logo", "cards", "backs", "talon", "discarded", "token"];
       i < l.length; i++) {
    game_view["img_" + l[i]] = load_image(setting["img_" + l[i]]);
  }

  current_cards  = setting.cards;
  setting.load_status = 'waiting';
  set_cookie("load_status", 'waiting');
  wait_load(bind(reload_images_2, {callback: callback}));
  return;
}

function reload_images_2 () {
  game_view.img_hilit_talon
    = make_overlay_image(game_view.img_talon);

  if (1) {
    var x1 = game_view.window_left;
    var y1 = game_view.window_top;
    var x2 = game_view.window_right;
    var y2 = game_view.window_bottom;
    var yc;
    var xc;
    var xtmp;
    var ytmp;

    if (game_view.img_talon.width > setting.card_width) { 
      x2 = x2 - game_view.img_talon.width;
      xtmp = x2 + Math.floor(game_view.img_talon.width / 2);
    } else {
      x2 = x2 - setting.card_width;
      xtmp = x2 + Math.floor(setting.card_width / 2);
    }
    if (game_view.img_talon.height > setting.card_height) {
      ytmp = y2 - Math.ceil(game_view.img_talon.height / 2);
    } else {
      ytmp = y2 - Math.ceil(setting.card_height / 2);
    }
    game_view.anchor_talon = {x: xtmp, y: ytmp};
    x2 = x2 - game_view.img_discarded.width;
    xtmp = x2 + Math.floor(game_view.img_discarded.width / 2);
    game_view.anchor_discarded = {x: xtmp, y: null};
    xtmp = x1 + Math.floor((setting.card_width + (setting.card_width / 2))/2);
    x1 = x1 + setting.card_width + Math.floor(setting.card_width / 2);
    game_view.anchor_purpose = {x: xtmp, y: null};
    xc = Math.floor((x1 + x2) / 2);
    yc = Math.floor((y1 + y2) / 2);
    game_view.anchor_discarded.y = yc;
    game_view.anchor_purpose.y = yc;
    ytmp = y1 + Math.ceil(setting.card_height / 2);
    game_view.anchor_swords_upper = {x: xc, y: ytmp};
    ytmp = y2 - Math.ceil(setting.card_height / 2);
    game_view.anchor_coins_lower = {x: xc, y: ytmp};
    ytmp = Math.floor(y2 - (y2 - yc) / 3);
    xtmp = Math.floor(x2 - (setting.card_width / 2));
    game_view.anchor_1 = {x: xtmp, y: ytmp};
    xtmp = Math.floor(x1 + (setting.card_width / 2));
    game_view.anchor_3 = {x: xtmp, y: ytmp};
    xtmp = Math.floor((x2 + xc) / 2);
    ytmp = Math.floor(y1 + (yc - y1) / 3);
    game_view.anchor_4 = {x: xtmp, y: ytmp};
    xtmp = Math.floor((x1 + xc) / 2);
    game_view.anchor_6 = {x: xtmp, y: ytmp};
    ytmp = Math.floor(yc + (y2 - yc) / 3);
    game_view.anchor_2 = {x: xc, y: ytmp};
    ytmp = Math.floor(yc - (yc - y1) / 3);
    game_view.anchor_5 = {x: xc, y: ytmp};
  }

  var pc = game_view.pane_control;
  pc.addEventListener("mousemove", function (ev) {
    var x = ev.offsetX || ev.layerX || (window.event && window.event.offsetX);
    var y = ev.offsetY || ev.layerY || (window.event && window.event.offsetY);

    game_view.lf.process_event("move", x, y);
  }, false);
  pc.addEventListener("mouseout", function (ev) {
    var x = ev.offsetX || ev.layerX || (window.event && window.event.offsetX);
    var y = ev.offsetY || ev.layerY || (window.event && window.event.offsetY);

    game_view.lf.process_event("move", x, y);
  }, false);
  pc.addEventListener("click", function (ev) {
    var x = ev.offsetX || ev.layerX || (window.event && window.event.offsetX);
    var y = ev.offsetY || ev.layerY || (window.event && window.event.offsetY);
    game_view.lf.process_event("click", x, y);
  }, false);

  var status_window = document.createElement('div');
  status_window.id = "status_window";
  status_window.style.position = "absolute";
  status_window.style.top = "" + (setting.window_height
			       - setting.status_window_height) + "px";
  status_window.style.left = "0px";
  status_window.style.width = "" + (setting.window_width - 20) + "px";
  status_window.style.height = "" + (setting.status_window_height - 30) + "px";
  status_window.style.display = "none";
  game_view.main_window.appendChild(status_window);
  game_view.status_window = status_window;

  var setting_window = document.createElement('div');
  setting_window.id = "setting_window";
  setting_window.style.position = "absolute";
  setting_window.style.width = "" + Math.floor(setting.window_width * 0.8) + "px";
  setting_window.style.left = "" + Math.floor(setting.window_width * 0.1) + "px";
  setting_window.style.height = "" + Math.floor(setting.window_height * 0.8) + "px";
  setting_window.style.top = "" + Math.floor(setting.window_height * 0.1) + "px";
  setting_window.style.display = "none";
  game_view.main_window.appendChild(setting_window);
  game_view.setting_window = setting_window;

  set_cookie("load_status", 'done');
  setting.load_status = 'done';

  this.callback();
  return;
}

function init () {
  var div = document.getElementById('main');
  game_view.main_window = div;
  var ad = document.getElementById('ad_area');
  game_view.ad_area = ad;
			     

  var c1 = document.createElement('canvas');

  if (! c1 || ! c1.getContext) {
    game_view.main_window.innerHTML = '<h2>易双六 ～ Youscout Tarot Solitaire</h2>'
      + '<p>This page needs Canvas on JavaScript. The author tested this program on Firefox 8, InternetExplorer 9 and Google Chrome 15.</p>';
    return;
  }

  read_setting();
  LANG = setting.lang;

  reload_images(bind(game_view.draw_title, game_view));
//  alert("OK");
}

window.onload = init;
</script>

</head>

<body>
<div id="main"></div>
<noscript>
<h2>易双六 ～ Youscout Tarot Solitaire</h2>
<p>This page needs JavaScript. Sorry.</p>
</noscript>

<!-- Google AdSense - Cocolog Youscout -->
<!--
<div id="ad_area">
<div id="ad_google">
<script type="text/javascript">
    google_ad_client = "ca-pub-0065765675450647";
    google_ad_slot = "6210687822";
    google_ad_width = 728;
    google_ad_height = 90;
</script>
<script type="text/javascript"
src="//pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
-->

</body>
</html>
